# 高质量C++/C编程指南及编码规范

## 指南及规范0013_代码行内的空格2
【规则 2-3-4】‘逗号’之后要留空格，如 Function(x, y, z)。如果‘分号’不是一行的结束符号，其后要留空格，如 for (initialization; condition; update)。

【规则 2-3-5】赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符等二元操作符的前后应当加空格。

【规则 2-3-6】一元操作符前后不加空格。

【规则 2-3-7】象取值运算符这类操作符前后不加空格。

【建议 2-3-1】对于表达式比较长的 for 语句和 if 语句，为了紧凑起见可以适当地去掉一些空格，

## 指南及规范0015_长行拆分
【规则 2-5-1】代码行最大长度宜控制在 70 至 80 个字符以内。代码行不要过长， 否则眼睛看不过来，也不便于打印。  
【规则 2-5-2】长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首（以便突出操作符）。拆分出的新行要进行适当的缩进，使排版整齐，语句可读。

## 指南及规范0017_注释
【规则 2-7-1】注释是对代码的“提示”，而不是文档。程序中的注释不可喧宾夺主，注释太多了会让人眼花缭乱。注释的花样要少。  
【规则 2-7-2】如果代码本来就是清楚的，则不必加注释。否则多此一举，令人厌烦。  例如 i++; // i 加 1，多余的注释
【规则 2-7-3】边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。  
【规则 2-7-4】注释应当准确、易懂，防止注释有二义性。错误的注释不但无益反而有害。 
【规则 2-7-5】尽量避免在注释中使用缩写，特别是不常用缩写。  
【规则 2-7-6】注释的位置应与被描述的代码相邻，可以放在代码的上方或右方， 不可放在下方。  
【规则 2-7-8】当代码比较长，特别是有多重嵌套时，应当在一些段落的结束处加注释，便于阅读。

## 指南及规范0018_类的版式
类的版式主要有两种方式：
（1）将 private 类型的数据写在前面，而将 public 类型的函数写在后面，如示例 2-7（a）。采用这种版式的程序员主张类的设计“以数据为中心”，重点关注类的内部结构。
（2）将 public 类型的函数写在前面，而将 private 类型的数据写在后面，如示例 2-7（b）采用这种版式的程序员主张类的设计“以行为为中心”，重点关注的是类应该提供什么样的接口（或服务）。
建议读者采用“以行为为中心”的书写方式，即首先考虑类应该提供什么样的函数。


## 指南及规范0021_共性规则3

【规则 3-1-5】程序中不要出现标识符完全相同的局部变量和全局变量，尽管两者的作用域不同而不会发生语法错误，但会使人误解。  
  
【规则 3-1-6】变量的名字应当使用“名词”或者“形容词＋名词”的格式。

## 指南及规范0022_共性规则4
【规则 3-1-7】全局函数的名字应当使用“动词”或者“动词＋名词”（动宾词组）。类的成员函数应当只使用“动词”，被省略掉的名词就是对象本身。

【规则 3-1-8】用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。

## 指南及规范0025_简单的 Windows 应用程序命名规则2
简单的 Windows 应用程序命名规则2：
【规则 3-2-3】常量全用大写的字母，用下划线分割单词。
【规则 3-2-4】静态变量加前缀 s_（表示 static）。

## 指南及规范0026_简单的 Windows 应用程序命名规则3
【规则 3-2-5】如果不得已需要全局变量，则使全局变量加前缀 g_（表示 global）。  
【规则 3-2-6】类的数据成员加前缀 m_（表示 member），这样可以避免数据成员与成员函数的参数同名。
【规则 3-2-7】为了防止某一软件库中的一些标识符和其它软件库中的冲突，可以为各种标识符加上能反映软件性质的前缀。例如三维图形标准 OpenGL 的所有库函数均以 gl 开头，所有常量（或宏定义）均以 GL 开头。

## 指南及规范0027_运算符的优先级
略

## 指南及规范0028_规则 4-1-1
【规则 4-1-1】如果代码行中的运算符比较多，用括号确定表达式的操作顺序， 避免使用默认的优先级 。
由于将运算符优先级表熟记是比较困难的，为了防止产生歧义并提高可读性，应当用括号确定表达式的操作顺序。

## 指南及规范0029_复合表达式1
如a = b = c = 0这样的表达式称为复合表达式。允许复合表达式存在的理由是书写简洁，并且可以提高编译效率，但要防止滥用复合表达式。

## 指南及规范0030_复合表达式2
【规则 4-2-1】不要编写太复杂的复合表达式。
【规则 4-2-2】不要有多用途的复合表达式。
【规则 4-2-3】不要把程序中的复合表达式与“真正的数学表达式”混淆

## 指南及规范0031_if 语句_布尔变量与零值比较
【规则 4-3-1】不应直接用TRUE、FALSE或者，1、0，来比较布尔变量。
根据布尔类型的定义，零值表示“假”（记为FALSE），任何非零值表示“真”（记为TRUE）。不同编程语言中TRUE的具体取值并无统一标准，例如Visual C++中TRUE为1，而Visual Basic中TRUE为负一。
以布尔变量名为flag为例，正确的比较方式如下：
if (flag) // 表示flag为真；
if (非flag) // 表示flag为假；除此以外的比较方式都被视为不良编程风格。

## 指南及规范0032_if 语句_整型变量与零值比较

【规则 4-3-2】应当将整型变量用“等于等于”或“不等于”直接与 0 比较。

## 指南及规范0033_if 语句_浮点变量与零值比较
【规则 4-3-3】不可将浮点变量用“等于等于”，或“不等于”与任何数字比较。

千万要留意，无论是 float 还是 double 类型的变量，都有精度限制。所以一定要避免将浮点变量用“等于等于”，或“不等于”与数字比较，应该设法转化成“大于等于”或“小于等于”的 形式。

## 指南及规范0034_if 语句_指针变量与零值比较
【规则 4-3-4】应当将指针变量用“等于等于”或“不等于”与 NULL 比较。  
  
指针变量的零值是“空”（记为 NULL）。尽管 NULL 的值与 0 相同，但是两者意义不同。假设指针变量的名字为 p，它与零值比较的标准 if 语句如下：
if (p 等于等于 NULL);
或者if (p 不等于 NULL)

## 指南及规范0036_循环语句的效率1
【建议 4-4-1】在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层，以减少 CPU 跨切循环层的次数。

## 指南及规范0037_循环语句的效率2
【建议 4-4-2】如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面。

## 指南及规范0038_for 语句的循环控制变量  
【规则 4-5-1】不可在 for 循环体内修改循环变量，防止 for 循环失去控制。  
【建议 4-5-1】建议 for 语句的循环控制变量的取值采用“半开半闭区间”写法。

## 指南及规范0039_switch 语句
【规则 4-6-1】每个 case 语句的结尾不要忘了加 break，否则将导致多个分支重叠（除非有意使多个分支重叠）。  
  
【规则 4-6-2】不要忘记最后那个 default 分支。即使程序真的不需要 default 处理，也应该保留语句 default : break; 这样做并非多此一举，而是为了 防止别人误以为你忘了 default 处理
## 指南及规范0040_goto 语句

goto 语句至少有一处可显神通，它能从多重循环体中咻地一下子跳到外面，用不着写很多次的 break 语句;  
例如

## 指南及规范0042_const 与 \#define 的比较

C++ 语言可以用 const 来定义常量，也可以用\#define 来定义常量。但是前者比后者有更多的优点：
一、 const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换时，可能会产生意料不到的错误（边际效应）。
二、 有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。

## 指南及规范0053_返回值的规则2

【规则 6-2-3】不要将正常值和错误标志混在一起返回。正常值用输出参数获得， 而错误标志用 return 语句返回。

【建议 6-2-1】有时候函数原本不需要返回值，但为了增加灵活性如支持链式表达，可以附加返回值。
## 指南及规范0056_函数内部实现的规则2

【规则 6-3-2】在函数体的“出口处”，对 return 语句的正确性和效率进行检查。 如果函数有返回值，那么函数的“出口处”是 return 语句。不要轻视 return 语句。如果 return 语句写得不好，函数要么出错，要么效率低下。

注意事项如下：
（1）return 语句不可返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。
（2）要搞清楚返回的究竟是“值”、“指针”还是“引用”。 
（3）如果函数返回值是一个对象，要考虑 return 语句的效率。

例如:return String(s1 + s2);这是临时对象的语法，表示“创建一个临时对象并返回它”。不要以为它与“先创建一个局部对象 temp 并返回它的结果”是等价的，如 String temp(s1 + s2); return temp;
首先，temp 对象被创建，同时完成初始化； 然后拷贝构造函数把 temp 拷贝到保存返回值的外部存储单元中；最后，temp 在函数结束时被销毁（调用析构函数）。
然而“创建一个临时对象并返回它”的过程是不同的，编译器直接把临时对象创建并初始化在外部存储单元中，省去了拷贝和析构的花费，提高了效率。 

类似的，不要将 return int(x + y);写成int temp = x + y; return temp;
由于内部数据类型如 int， float， double 的变量不存在构造函数与析构函数，虽然该“临时变量的语法”不会提高多少效率，但是程序更加简洁易读。

## 指南及规范0059_其它建议3
【建议 6-4-4】不仅要检查输入参数的有效性，还要检查通过其它途径进入函数体内的变量的有效性，例如全局变量、文件句柄等。  
  
【建议 6-4-5】用于出错处理的返回值一定要清楚，让使用者不容易忽视或误解错误情况。

## 指南及规范0063_使用断言4

【规则 6-5-1】使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的。  
  
【规则 6-5-2】在函数的入口处，使用断言检查参数的有效性（合法性）。

## 指南及规范0065_引用与指针的比较1

以下程序中，n 是 m 的一个引用物（reference），m 是被引用物（referent）。
n 相当于 m 的别名（绰号），对 n 的任何操作就是对 m 的操作。例如有人名叫王小毛，他的绰号是“三毛”。说“三毛”怎么怎么的，其实就是对王小毛说三道四。 所以 n 既不是 m 的拷贝，也不是指向 m 的指针，其实 n 就是 m 它自己。

引用的一些规则如下：
（1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。
（2）不能有 NULL 引用，引用必须与合法的存储单元关联（指针则可以是 NULL）。
（3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。

## 指南及规范0066_引用与指针的比较2

引用的主要功能是传递函数的参数和返回值。C++语言中，函数的参数和返回值的传递方式有三种： 值传递、指针传递和引用传递。

以下是“值传递”的示例程序。由于 Func1 函数体内的 x 是外部变量 n 的一份拷贝，改变 x 的值不会影响 n, 所以 n 的值仍然是 0。

以下是“指针传递”的示例程序。由于 Func2 函数体内的 x 是指向外部变量 n的指针，改变该指针的内容将导致 n 的值改变，所以 n 的值成为 10。

以下是“引用传递”的示例程序。由于 Func3 函数体内的 x 是外部变量 n 的引用，x 和 n 是同一个东西，改变 x 等于改变 n，所以 n 的值成为 10。

## 指南及规范0067——内存分配方式
内存分配方式主要有三种：
首先是从静态存储区域分配。这种分配方式发生在程序编译阶段，用于存储全局变量和静态变量，它们在整个程序运行期间都存在，不会随着函数的执行而动态变化。

其次是在栈上创建。栈内存用于存储函数执行时的局部变量，这些变量在函数执行期间动态创建，并且在函数执行结束时自动释放。栈内存的分配和释放由处理器的指令集管理，因此效率很高，但可分配的内存空间有限。
最后是从堆上分配，也称为动态内存分配。通过调用 malloc 或 new 函数，程序可以在运行时申请任意大小的内存空间。动态内存的生命周期由程序员控制，需要手动调用 free 或 delete 函数来释放已分配的内存。这种方式灵活性很高，但也容易引发内存泄漏等问题，需要谨慎使用。
这三种内存分配方式各有其特点和适用场景，合理选择和使用可以提高程序的效率和可靠性。


## 指南及规范0068——常见的内存错误及其对策1
常见的内存错误及其对策1:内存分配未成功，却使用了它。

这是编程新手常犯的一种错误，因为他们没有意识到内存分配会不成功。常用的解决办法是在使用内存之前检查指针是否为 NULL。如果指针 p 是函数的参数，那么在函数的入口处用 assert(p 不等于 NULL) 进行检查。如果是用 malloc 或 new 来申请内存，应该用 i f (p 等于 NULL) 或 i f (p 不等于 NULL) 进行防错处理。

## 指南及规范0069——常见的内存错误及其对策2
常见的内存错误及其对策之二：
有时候我们会成功分配内存，但在使用之前却忘记对其进行初始化。
出现这种错误通常有两个原因：一是缺乏初始化的意识；二是误认为内存的默认值都是零，从而在使用时出现初值错误（比如在数组中）。
事实上，内存的默认值并没有统一的标准，有时候是零值，但不能完全依赖此假设。因此，无论使用何种方式创建数组，都应该记得进行初始化，即使只是赋予零值也不可忽略。

## 指南及规范0071——常见的内存错误及其对策4
常见的内存错误之一是忘记释放内存，从而导致内存泄漏。这种错误的函数每被调用一次，就会丢失一块内存。刚开始时，系统的内存充足，你看不到错误，但最终程序会突然死掉，系统会提示内存耗尽。动态内存的申请与释放必须配对，程序中 malloc 与 free 的使用次数一定要相同，否则肯定会有错误，同样的道理也适用于 new 和 delete。


## 指南及规范0075——下面以字符串为例比较指针与数组的特性——1.修改内容

下例中：
字符数组 a 的容量是 6 个字符，其内容为 hello\0。a 的内容可以改变，如 a[0]等于 'X'。
指针 p 指向常量字符串“world”（位于静态存储区，内容为 world\0），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句 p[0]等于 'X'有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。

## 指南及规范0092——成员函数的重载、覆盖与隐藏_重载与覆盖

成员函数被重载的特征：
（1）相同的范围（在同一个类中）。
（2）函数名字相同。
（3）参数不同。
（4）virtual 关键字可有可无。
覆盖是指派生类函数覆盖基类函数，特征是：
（1）不同的范围（分别位于派生类与基类）。
（2）函数名字相同。
（3）参数相同。
（4）基类函数必须有 virtual 关键字。
## 指南及规范0093——成员函数的重载、覆盖与隐藏_令人迷惑的隐藏规则

派生类的函数屏蔽了与其同名的基类函数，规则如下：
（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载混淆）。
（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。


## 指南及规范0094——成员函数的重载、覆盖与隐藏_摆脱隐藏
如果语句一定要调用基类的函数，那么在派生类中直接以基类，双冒号，函数名的格式调用即可。

## 指南及规范0095——参数的缺省值

有一些参数的值在每次函数调用时都相同，书写这样的语句会使人厌烦。C++语言采用参数的缺省值使书写变得简洁（在编译时，缺省值由编译器自动插入）。

【规则 8-3-1】参数缺省值只能出现在函数的声明中，而不能出现在定义体中。

【规则 8-3-2】如果函数有多个参数，参数只能从后向前挨个儿缺省，否则将导致函数调用语句怪模怪样。

要注意，使用参数的缺省值并没有赋予函数新的功能，仅仅是使书写变得简洁一些。它可能会提高函数的易用性，但是也可能会降低函数的可理解性。所以只能适当地使用参数的缺省值，要防止使用不当产生负面效果。

## 指南及规范0096——运算符重载_概念
在 C++语言中，可以用关键字 operator 加上运算符来表示函数，叫做运算符重载。
运算符与普通函数在调用时的不同之处是：1、对于普通函数，参数出现在圆括号内；2、而对于运算符，参数出现在其左、右侧。
如果运算符被重载为全局函数，那么只有一个参数的运算符叫做一元运算符， 有两个参数的运算符叫做二元运算符。
如果运算符被重载为类的成员函数，那么一元运算符没有参数，二元运算符只有一个右侧参数，因为对象自己成了左侧参数。
运算符的重载规则如下：1、所有的一元运算符都建议重载为成员函数；2、等于号，小括号，中括号，箭头符号这四类，只能重载为成员函数；3、加等于，减等于，除等于，乘等于，与等于，或等于，非等于，取模等于，右移等于，左移等于这些符号，建议重载为成员函数；剩下的所有其它运算符，建议重载为全局函数。

## 指南及规范0097——运算符重载_不能被重载的运算符
在 C++运算符集合中，有一些运算符是不允许被重载的。这种限制是出于安全方面的考虑，可防止错误和混乱。
（1）不能改变 C++内部数据类型（如 int, float 等）的运算符。
（2）不能重载点运算符，因为点运算符在类中对任何成员都有意义，已经成为标准用法。
（3）不能重载目前 C++运算符集合中没有的符号，如井号，艾特符号，美元符号等。原因有两点，一是难以理解，二是难以确定优先级。
（4）对已经存在的运算符进行重载时，不能改变优先级规则，否则将引起混乱。

## 指南及规范0098——函数内联_用内联取代宏代码
C++ 语言的函数内联机制既具备宏代码的效率，又增加了安全性，而且可以自由操作类的数据成员。  
所以在 C++ 程序中，应该用内联函数取代所有宏代码，“断言 assert”是唯一的例外。

## 指南及规范0099——函数内联_内联函数的编程风格
关于内联函数的编程风格有以下要点：关键字 `inline` 必须与函数定义体放在一起才能使函数成为内联函数。如果仅将 `inline` 放在函数声明前面，则不会起到内联函数的作用。

在类声明中定义的成员函数会自动成为内联函数，这是编译器的默认行为。

## 指南及规范0100——函数内联_慎用内联
慎用函数内联。
内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。但如果函数体内的代码较长，内联会导致内存消耗代价较高。另外，如果函数体内包含循环，执行函数体内代码的时间可能比函数调用的开销大，此时使用内联效果有限。
总之，内联应根据具体情况而定，不宜滥用。