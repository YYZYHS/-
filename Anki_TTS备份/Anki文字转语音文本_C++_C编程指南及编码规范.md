# 高质量C++/C编程指南及编码规范

## 指南及规范0001_C/C++中的文件
C++/C 程序通常分为两个文件：
一个文件用于保存程序的声明（declaration），称为头文件，以“.h”为后缀。这些文件包含了类、函数、变量等的声明，供其他文件引用和使用。
另一个文件用于保存程序的实现（implementation），称为定义（definition）文件。对于 C 程序，这些文件以“.c”为后缀；对于 C++ 程序，通常以“.cpp”为后缀（也有一些系统使用“.cc”或“.cxx”为后缀）。这些文件包含了具体的函数、类成员函数等的实现代码，将声明中定义的内容具体化。
通过将声明和定义分离，可以提高代码的模块化和可维护性，同时使得代码更易于重复使用和理解。

## 指南及规范0004_规则 1-2-1 ~ 规则 1-2-3
【规则 1-2-1】为了防止头文件被重复引用，应当用 ifndef、define、endif 结构产生预处理块。

【规则 1-2-2】用 # include 尖括号，文件名 格式来引用标准库的头文件（编译器将从标准库目录开始搜索）。

【规则 1-2-3】用 # include 双引号，文件名 格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。

## 指南及规范0005_建议 1-2-1 ~ 建议 1-2-2
建议 1-2-1】头文件中只存放“声明”而不存放“定义” 
在 C++ 语法中，类的成员函数可以在声明的同时被定义，并且自动成为内联函数。这虽然会带来书写上的方便，但却造成了风格不一致，弊大于利。建议将成员函数的定义与声明分开，不论该函数体有多么小。
【建议 1-2-2】不提倡使用全局变量，尽量不要在头文件中出现诸如 extern int value 这类声明。

## 指南及规范0006_定义文件的结构
定义文件通常由三部分内容组成。首先，在文件的开头会有版权和版本声明，这是用来注明文件的版权信息和版本号。其次，文件中会引用一些头文件，这些头文件是程序运行所需的外部资源或库。最后，是程序的实现部分，这部分包括具体的数据和代码，用于实现程序的功能。

## 指南及规范0007_头文件的作用
头文件在编程中的作用是十分关键的。它最初在C++或C语言中被引入，用于调用库功能和加强类型安全检查。用户通过头文件的接口声明来调用库功能，而编译器则据此提取相应代码，避免直接访问源代码或二进制库。此外，头文件定义了函数或类的声明，使得编译器在实现或使用接口时能够进行一致性检查，从而减少了错误的发生。头文件的另一个重要作用是隐藏了实现细节，使得用户能够专注于接口而非底层细节，有助于提高代码的保密性和简化调试过程。总体而言，理解头文件的作用对于初学者来说至关重要，因为它们是C++/C语言中良好编程实践的核心之一。

## 指南及规范0008_目录结构
建议的目录结构设计如下：
如果软件包含大量头文件（超过十个），建议按如下方式组织：将头文件存放于 include 目录，定义文件则放在 source 目录，可以考虑采用多级目录结构。对于私有头文件，即不被用户程序直接引用的，可以与相应的定义文件放在同一目录，以增强信息隐藏效果。这样做有利于提高代码的组织性和维护性，同时也降低了文件查找的复杂度。通过隐藏私有头文件的声明，能有效地隔离实现细节，使软件更模块化。总的来说，这些建议旨在优化代码的可读性和可维护性，确保项目的整体结构更加清晰和易于理解。

## 指南及规范0010_规则 2-2-1~规则 2-2-2
【规则 2-2-1】一行代码只做一件事情，如只定义一个变量，或只写一条语句。 这样的代码容易阅读，并且方便于写注释。  
【规则 2-2-2】if、for、while、do 等语句自占一行，执行语句不得紧跟其后。 不论执行语句有多少都要加花括号 。这样可以防止书写失误。

## 指南及规范0011_建议 2-2-1
【建议 2-2-1】尽可能在定义变量的同时初始化该变量（就近原则）

## 指南及规范0012_代码行内的空格1
【规则 2-3-1】关键字之后要留空格。  
象 const、virtual、inline、case 等关键字之后至少要留一个空格，否则无法辨析关键字。象 if、for、while 等关键字之后应留一个空格再跟左括号‘（’，以突出关键字。
【规则 2-3-2】函数名之后不要留空格，紧跟左括号‘（’，以与关键字区别。  
  【规则 2-3-3】左括号‘（’向后紧跟，右括号‘）,顿号’、,逗号,分号,‘;’向前紧跟，紧跟处不留空格。

## 指南及规范0013_代码行内的空格2
【规则 2-3-4】‘逗号’之后要留空格，如 Function(x, y, z)。如果‘分号’不是一行的结束符号，其后要留空格，如 for (initialization; condition; update)。

【规则 2-3-5】赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符等二元操作符的前后应当加空格。

【规则 2-3-6】一元操作符前后不加空格。

【规则 2-3-7】象取值运算符这类操作符前后不加空格。

【建议 2-3-1】对于表达式比较长的 for 语句和 if 语句，为了紧凑起见可以适当地去掉一些空格，

## 指南及规范0014_对齐
【规则 2-4-1】程序的分界符‘左花括号’和‘右花括号’应独占一行并且位于同一列，同时与引用它们的语句左对齐。
【规则 2-4-2】花括号之内的代码块在‘左花括号’右边数格处左对齐。

## 指南及规范0015_长行拆分
【规则 2-5-1】代码行最大长度宜控制在 70 至 80 个字符以内。代码行不要过长， 否则眼睛看不过来，也不便于打印。  
【规则 2-5-2】长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首（以便突出操作符）。拆分出的新行要进行适当的缩进，使排版整齐，语句可读。

## 指南及规范0016_修饰符的位置
print函数的基本语法需要注意一些规则，例如【规则2-6-1】，修饰符 星号 和 取地址符号 应该紧靠变量名。举个例子，char 星号name; int 星号x, y; 这里y不会被误解为指针。至于修饰符 星号 和 取地址符号 应该靠近数据类型还是靠近变量名，这个问题有些争议。如果将修饰符 星号 靠近数据类型，例如 int星号 x; 从语义上讲，这种写法比较直观，意思是 x 是 int 类型的指针。然而，这种写法的弊端在于容易引起误解，例如 int星号 x, y; 这种情况下，y 容易被误解为指针变量。虽然将 x 和 y 分行定义可以避免误解，但并不是每个人都愿意这样做。

## 指南及规范0017_注释
【规则 2-7-1】注释是对代码的“提示”，而不是文档。程序中的注释不可喧宾夺主，注释太多了会让人眼花缭乱。注释的花样要少。  
【规则 2-7-2】如果代码本来就是清楚的，则不必加注释。否则多此一举，令人厌烦。  例如 i++; // i 加 1，多余的注释
【规则 2-7-3】边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。  
【规则 2-7-4】注释应当准确、易懂，防止注释有二义性。错误的注释不但无益反而有害。 
【规则 2-7-5】尽量避免在注释中使用缩写，特别是不常用缩写。  
【规则 2-7-6】注释的位置应与被描述的代码相邻，可以放在代码的上方或右方， 不可放在下方。  
【规则 2-7-8】当代码比较长，特别是有多重嵌套时，应当在一些段落的结束处加注释，便于阅读。

## 指南及规范0018_类的版式
类的版式主要有两种方式：
（1）将 private 类型的数据写在前面，而将 public 类型的函数写在后面，如示例 2-7（a）。采用这种版式的程序员主张类的设计“以数据为中心”，重点关注类的内部结构。
（2）将 public 类型的函数写在前面，而将 private 类型的数据写在后面，如示例 2-7（b）采用这种版式的程序员主张类的设计“以行为为中心”，重点关注的是类应该提供什么样的接口（或服务）。
建议读者采用“以行为为中心”的书写方式，即首先考虑类应该提供什么样的函数。

## 指南及规范0019_共性规则1
【规则 3-1-1】标识符应当直观且可以拼读，可望文知意，不必进行“解码”。
【规则 3-1-2】标识符的长度应当符合“min length, AND, max information”原则。

## 指南及规范0021_共性规则3

【规则 3-1-5】程序中不要出现标识符完全相同的局部变量和全局变量，尽管两者的作用域不同而不会发生语法错误，但会使人误解。  
  
【规则 3-1-6】变量的名字应当使用“名词”或者“形容词＋名词”的格式。

## 指南及规范0022_共性规则4
【规则 3-1-7】全局函数的名字应当使用“动词”或者“动词＋名词”（动宾词组）。类的成员函数应当只使用“动词”，被省略掉的名词就是对象本身。

【规则 3-1-8】用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。

## 指南及规范0024_简单的 Windows 应用程序命名规则


## 指南及规范0025_简单的 Windows 应用程序命名规则2
简单的 Windows 应用程序命名规则2：
【规则 3-2-3】常量全用大写的字母，用下划线分割单词。
【规则 3-2-4】静态变量加前缀 s_（表示 static）。

## 指南及规范0026_简单的 Windows 应用程序命名规则3
【规则 3-2-5】如果不得已需要全局变量，则使全局变量加前缀 g_（表示 global）。  
【规则 3-2-6】类的数据成员加前缀 m_（表示 member），这样可以避免数据成员与成员函数的参数同名。
【规则 3-2-7】为了防止某一软件库中的一些标识符和其它软件库中的冲突，可以为各种标识符加上能反映软件性质的前缀。例如三维图形标准 OpenGL 的所有库函数均以 gl 开头，所有常量（或宏定义）均以 GL 开头。

## 指南及规范0027_运算符的优先级
略

## 指南及规范0028_规则 4-1-1
【规则 4-1-1】如果代码行中的运算符比较多，用括号确定表达式的操作顺序， 避免使用默认的优先级 。
由于将运算符优先级表熟记是比较困难的，为了防止产生歧义并提高可读性，应当用括号确定表达式的操作顺序。

## 指南及规范0029_复合表达式1
如a = b = c = 0这样的表达式称为复合表达式。允许复合表达式存在的理由是书写简洁，并且可以提高编译效率，但要防止滥用复合表达式。

## 指南及规范0030_复合表达式2
【规则 4-2-1】不要编写太复杂的复合表达式。
【规则 4-2-2】不要有多用途的复合表达式。
【规则 4-2-3】不要把程序中的复合表达式与“真正的数学表达式”混淆

## 指南及规范0031_if 语句_布尔变量与零值比较
【规则 4-3-1】不应直接用TRUE、FALSE或者，1、0，来比较布尔变量。
根据布尔类型的定义，零值表示“假”（记为FALSE），任何非零值表示“真”（记为TRUE）。不同编程语言中TRUE的具体取值并无统一标准，例如Visual C++中TRUE为1，而Visual Basic中TRUE为负一。
以布尔变量名为flag为例，正确的比较方式如下：
if (flag) // 表示flag为真；
if (非flag) // 表示flag为假；除此以外的比较方式都被视为不良编程风格。

## 指南及规范0032_if 语句_整型变量与零值比较

【规则 4-3-2】应当将整型变量用“等于等于”或“不等于”直接与 0 比较。

## 指南及规范0033_if 语句_浮点变量与零值比较
【规则 4-3-3】不可将浮点变量用“等于等于”，或“不等于”与任何数字比较。

千万要留意，无论是 float 还是 double 类型的变量，都有精度限制。所以一定要避免将浮点变量用“等于等于”，或“不等于”与数字比较，应该设法转化成“大于等于”或“小于等于”的 形式。

## 指南及规范0034_if 语句_指针变量与零值比较
【规则 4-3-4】应当将指针变量用“等于等于”或“不等于”与 NULL 比较。  
  
指针变量的零值是“空”（记为 NULL）。尽管 NULL 的值与 0 相同，但是两者意义不同。假设指针变量的名字为 p，它与零值比较的标准 if 语句如下：
if (p 等于等于 NULL);
或者if (p 不等于 NULL)

## 指南及规范0036_循环语句的效率1
【建议 4-4-1】在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层，以减少 CPU 跨切循环层的次数。

## 指南及规范0037_循环语句的效率2
【建议 4-4-2】如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面。

## 指南及规范0038_for 语句的循环控制变量  
【规则 4-5-1】不可在 for 循环体内修改循环变量，防止 for 循环失去控制。  
【建议 4-5-1】建议 for 语句的循环控制变量的取值采用“半开半闭区间”写法。

## 指南及规范0039_switch 语句
【规则 4-6-1】每个 case 语句的结尾不要忘了加 break，否则将导致多个分支重叠（除非有意使多个分支重叠）。  
  
【规则 4-6-2】不要忘记最后那个 default 分支。即使程序真的不需要 default 处理，也应该保留语句 default : break; 这样做并非多此一举，而是为了 防止别人误以为你忘了 default 处理
## 指南及规范0040_goto 语句

goto 语句至少有一处可显神通，它能从多重循环体中咻地一下子跳到外面，用不着写很多次的 break 语句;  
例如

## 指南及规范0041_为什么需要常量
【规则 5-1-1】 尽量使用含义直观的常/量来表示那些将在程序中多次出现的数字或字符串。


## 指南及规范0042_const 与 \#define 的比较

C++ 语言可以用 const 来定义常量，也可以用\#define 来定义常量。但是前者比后者有更多的优点：
一、 const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换时，可能会产生意料不到的错误（边际效应）。
二、 有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。

## 指南及规范0043_规则 5-2-1
【规则 5-2-1】在 C++ 程序中只使用 const 常量而不使用宏常量，即 const 常量完全取代宏常量。

## 指南及规范0044_常量定义规则
【规则 5-3-1】需要对外公开的常/量放在头文件中，不需要对外公开的常/量放在定义文件的头部。为便于管理，可以把不同模块的常/量集中存放在一个公共的头文件中。
【规则 5-3-2】如果某一常/量与其它常/量密切相关，应在定义中包含这种关系， 而不应给出一些孤立的值。

## 指南及规范0045_类中的常量
类中的常量具有一些特性，其中 const 数据成员的特性是 const 数据成员只在某个对象的生存期内是常量，而在整个类的范围内是可变的，因为可以创建多个对象，每个对象的 const 数据成员的值可以不同。因此，不能在类声明中初始化 const 数据成员。  

## 指南及规范0046_类中的常量2
类中的常量部分有一个特别需要注意的点，就是初始化 const 数据成员的方法。为了初始化 const 数据成员，我们需要在类的构造函数的初始化列表中进行设置。具体做法是通过构造函数的参数来传递值，从而实现对 const 数据成员的初始化。这样可以确保 const 数据成员在对象创建时就已经被正确赋值，从而保证其不变性。

## 指南及规范0047_类中的常量3
在类中，我们可以使用常量，也可以使用枚举常量。枚举常量在整个类中都是常量，不占用对象的存储空间，并且在编译时会被全部求值。例如，定义一个类A，其中包含枚举常量SIZE1和SIZE2，分别表示100和200。随后，使用这些枚举常量来定义两个数组array1和array2，它们的大小分别为SIZE1和SIZE2。然而，枚举常量也有其缺点，比如其隐含的数据类型为整数，表示范围有限，不能表示浮点数（例如PI等于3.14159）。总体来看，枚举常量是一个在整个类中使用常量的有效选择，但在使用时需要注意其数据类型和表示范围的限制。

## 指南及规范0048_参数的规则
【规则 6-1-1】参数的书写要完整，不要贪图省事只写参数的类型而省略参数名字。如果函数没有参数，则用 void 填充。

## 指南及规范0050_参数的规则3
【规则 6-1-3】如果参数是指针，且仅作输入用，则应在类型前加 const，以防止该指针在函数体内被意外修改。
【规则 6-1-4】如果输入参数以值传递的方式传递对象，则宜改用“const 引用”方式来传递，这样可以省去临时对象的构造和析构过程，从而提高效率。

## 指南及规范0051_参数的规则4
【建议 6-1-1】避免函数有太多的参数，参数个数尽量控制在 5 个以内。如果参数太多，在使用时容易将参数类型或顺序搞错。  
  
【建议 6-1-2】尽量不要使用类型和数目不确定的参数。
以C标准库函数printf为例，它采用了不确定参数的形式，原型为 int printf(const char *format, argument......);。这种风格的函数在编译时会丧失严格的类型安全检查。

## 指南及规范0052_返回值的规则1
返回值的规则1。首先，遵循规则6-2-1，不要省略返回值的类型。在C语言中，所有没有明确指定类型的函数会默认按整型处理，这样做不会带来任何好处，反而容易被误解为void类型。而C++语言对类型检查非常严格，不允许这种情况发生。为了避免混乱，C++和C函数都必须有明确的类型声明。如果函数没有返回值，那么应声明为void类型。

接着是规则6-2-2，函数名字与返回值类型在语义上不可冲突。一个典型的违反此规则的例子是C标准库函数getchar。比如：
char c;
c = getchar();
if (c == EOF)

根据getchar这个名字，我们会自然地将变量c声明为char类型，但实际上getchar的返回类型是int，其原型如下：

int getchar(void);

由于c是char类型，其取值范围是负的128,到127，如果宏EOF的值超出了char的取值范围，那么if语句将总是失败。这个错误并不是用户的责任，而是因为函数getchar的命名误导了使用者。

## 指南及规范0053_返回值的规则2

【规则 6-2-3】不要将正常值和错误标志混在一起返回。正常值用输出参数获得， 而错误标志用 return 语句返回。

【建议 6-2-1】有时候函数原本不需要返回值，但为了增加灵活性如支持链式表达，可以附加返回值。

## 指南及规范0054_返回值的规则3
在编写函数时，如果返回值是一个对象，有些情况下可以用“引用传递”替代“值传递”来提高效率。然而，在某些场合下只能用“值传递”，否则会出错。

举个例子：

在 String 类中，有一个赋值函数和一个相加函数。如果没有 friend 修饰，相加函数只能有一个右侧参数。赋值函数的实现如下：首先检查当前对象是否是传入的对象，如果是则直接返回当前对象的引用。否则，释放当前对象的数据，分配新的内存并复制传入对象的数据，最后返回当前对象的引用。这样做的好处是避免了不必要的拷贝，提高了效率。具体来说，如果用“引用传递”的方式返回 String 对象，当我们执行 a = b; 这样的赋值操作时，只需要返回 *this 的引用，而不需要将 *this 拷贝到外部存储单元，避免了不必要的开销。

对于相加函数，函数创建一个临时对象 temp，释放 temp 原有的数据，然后分配新内存存储两个对象相加后的结果。最后返回临时对象 temp。这种情况下用“值传递”是必要的，因为 temp 是局部对象，如果用“引用传递”，当函数结束时 temp 被销毁，返回的引用将无效。具体来说，如果用“引用传递”，函数返回值是一个指向局部对象 temp 的“引用”，由于 temp 在函数结束时被自动销毁，将导致返回的“引用”无效。例如，执行 c = a + b; 时，a + b 并不返回期望值，c 将什么也得不到，留下了隐患。

通过这个例子可以看到，在函数返回 String 对象时，选择合适的传递方式对于提高效率和避免错误是非常重要的。在赋值函数中使用“引用传递”，而在相加函数中使用“值传递”，可以确保函数的正确性和高效性。

## 指南及规范0056_函数内部实现的规则2

【规则 6-3-2】在函数体的“出口处”，对 return 语句的正确性和效率进行检查。 如果函数有返回值，那么函数的“出口处”是 return 语句。不要轻视 return 语句。如果 return 语句写得不好，函数要么出错，要么效率低下。

注意事项如下：
（1）return 语句不可返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。
（2）要搞清楚返回的究竟是“值”、“指针”还是“引用”。 
（3）如果函数返回值是一个对象，要考虑 return 语句的效率。

例如:return String(s1 + s2);这是临时对象的语法，表示“创建一个临时对象并返回它”。不要以为它与“先创建一个局部对象 temp 并返回它的结果”是等价的，如 String temp(s1 + s2); return temp;
首先，temp 对象被创建，同时完成初始化； 然后拷贝构造函数把 temp 拷贝到保存返回值的外部存储单元中；最后，temp 在函数结束时被销毁（调用析构函数）。
然而“创建一个临时对象并返回它”的过程是不同的，编译器直接把临时对象创建并初始化在外部存储单元中，省去了拷贝和析构的花费，提高了效率。 

类似的，不要将 return int(x + y);写成int temp = x + y; return temp;
由于内部数据类型如 int， float， double 的变量不存在构造函数与析构函数，虽然该“临时变量的语法”不会提高多少效率，但是程序更加简洁易读。

## 指南及规范0057_其它建议1
【建议 6-4-1】函数的功能要单一，不要设计多用途的函数。  
【建议 6-4-2】函数体的规模要小，尽量控制在 50 行代码之内。

## 指南及规范0058_其它建议2
【建议 6-4-3】尽量避免函数带有“记忆”功能。相同的输入应当产生相同的输出。  
  
带有“记忆”功能的函数，其行为可能是不可预测的，因为它的行为可能取决于某种“记忆状态”。这样的函数既不易理解又不利于测试和维护。  
在 C/C++语言中， 函数的 static 局部变量是函数的“记忆”存储器。建议尽量少用 static 局部变量，除非必需。

## 指南及规范0059_其它建议3
【建议 6-4-4】不仅要检查输入参数的有效性，还要检查通过其它途径进入函数体内的变量的有效性，例如全局变量、文件句柄等。  
  
【建议 6-4-5】用于出错处理的返回值一定要清楚，让使用者不容易忽视或误解错误情况。

## 指南及规范0061_使用断言2
断言 assert 是仅在 Debug 版本起作用的宏，用于检查“不应该”发生的情况。示例 6-5 是一个内存复制函数。在运行过程中，如果 assert 的参数为假，那么程序就会中止，一般地还会出现提示对话，说明在什么地方引发了 assert。这个函数 memcpy 的实现过程是这样的：首先使用断言检查传入的指针是否为空，接着将两个指针类型转换为 byte 类型以防止地址改变，然后通过一个 while 循环逐字节复制源地址的数据到目标地址，最后返回目标地址。

## 指南及规范0062_使用断言3
使用断言时，assert 并不是一个随意拼凑的宏。为了确保在程序的调试版本和发布版本中没有差别，assert 不应产生任何副作用。因此，assert 不是一个函数，而是一个宏。程序员可以将 assert 视为在任何系统状态下都可以安全使用的无害测试手段。如果程序在 assert 处终止了，这并不意味着包含该 assert 的函数有错误，而是调用者出了问题。assert 可以帮助找到发生错误的原因。

跟踪到程序的断言却不知道该断言的作用，是一件非常令人沮丧的事。你花费了大量时间，不是为了排除错误，而是为了弄清楚这个错误到底是什么。有时，程序员还会偶尔设计出有错误的断言。因此，如果不清楚断言检查的是什么，就很难判断错误是出现在程序中还是断言中。幸运的是，这个问题可以通过清晰的注释轻松解决。虽然这是显而易见的事情，但很少有程序员这样做。这就像在森林里看到树上钉着一个写有“危险”的大牌子，但危险是什么呢？树要倒？有废井？有野兽？除非明确告知人们“危险”是什么，否则这个警告牌难以起到积极有效的作用。同样，不易理解的断言常常被程序员忽略，甚至被删除。[Maguire, p8-p30] 

## 指南及规范0063_使用断言4

【规则 6-5-1】使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的。  
  
【规则 6-5-2】在函数的入口处，使用断言检查参数的有效性（合法性）。

## 指南及规范0064_使用断言5
【建议 6-5-1】在编写函数时，要进行反复的考查，并且自问：“我打算做哪些假定？”一旦确定了假定，就要使用断言对假定进行检查。  
  
【建议 6-5-2】一般教科书都鼓励程序员们进行防错设计，但要记住这种编程风格可能会隐瞒错误。当进行防错设计时，如果“不可能发生”的事情的确发生  
了，则要使用断言进行报警。


## 指南及规范0065_引用与指针的比较1

以下程序中，n 是 m 的一个引用物（reference），m 是被引用物（referent）。
n 相当于 m 的别名（绰号），对 n 的任何操作就是对 m 的操作。例如有人名叫王小毛，他的绰号是“三毛”。说“三毛”怎么怎么的，其实就是对王小毛说三道四。 所以 n 既不是 m 的拷贝，也不是指向 m 的指针，其实 n 就是 m 它自己。

引用的一些规则如下：
（1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。
（2）不能有 NULL 引用，引用必须与合法的存储单元关联（指针则可以是 NULL）。
（3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。

## 指南及规范0066_引用与指针的比较2

引用的主要功能是传递函数的参数和返回值。C++语言中，函数的参数和返回值的传递方式有三种： 值传递、指针传递和引用传递。

以下是“值传递”的示例程序。由于 Func1 函数体内的 x 是外部变量 n 的一份拷贝，改变 x 的值不会影响 n, 所以 n 的值仍然是 0。

以下是“指针传递”的示例程序。由于 Func2 函数体内的 x 是指向外部变量 n的指针，改变该指针的内容将导致 n 的值改变，所以 n 的值成为 10。

以下是“引用传递”的示例程序。由于 Func3 函数体内的 x 是外部变量 n 的引用，x 和 n 是同一个东西，改变 x 等于改变 n，所以 n 的值成为 10。

## 指南及规范0067——内存分配方式
内存分配方式主要有三种：
首先是从静态存储区域分配。这种分配方式发生在程序编译阶段，用于存储全局变量和静态变量，它们在整个程序运行期间都存在，不会随着函数的执行而动态变化。

其次是在栈上创建。栈内存用于存储函数执行时的局部变量，这些变量在函数执行期间动态创建，并且在函数执行结束时自动释放。栈内存的分配和释放由处理器的指令集管理，因此效率很高，但可分配的内存空间有限。
最后是从堆上分配，也称为动态内存分配。通过调用 malloc 或 new 函数，程序可以在运行时申请任意大小的内存空间。动态内存的生命周期由程序员控制，需要手动调用 free 或 delete 函数来释放已分配的内存。这种方式灵活性很高，但也容易引发内存泄漏等问题，需要谨慎使用。
这三种内存分配方式各有其特点和适用场景，合理选择和使用可以提高程序的效率和可靠性。


## 指南及规范0068——常见的内存错误及其对策1
常见的内存错误及其对策1:内存分配未成功，却使用了它。

这是编程新手常犯的一种错误，因为他们没有意识到内存分配会不成功。常用的解决办法是在使用内存之前检查指针是否为 NULL。如果指针 p 是函数的参数，那么在函数的入口处用 assert(p 不等于 NULL) 进行检查。如果是用 malloc 或 new 来申请内存，应该用 i f (p 等于 NULL) 或 i f (p 不等于 NULL) 进行防错处理。

## 指南及规范0069——常见的内存错误及其对策2
常见的内存错误及其对策之二：
有时候我们会成功分配内存，但在使用之前却忘记对其进行初始化。
出现这种错误通常有两个原因：一是缺乏初始化的意识；二是误认为内存的默认值都是零，从而在使用时出现初值错误（比如在数组中）。
事实上，内存的默认值并没有统一的标准，有时候是零值，但不能完全依赖此假设。因此，无论使用何种方式创建数组，都应该记得进行初始化，即使只是赋予零值也不可忽略。

## 指南及规范0070——常见的内存错误及其对策3
常见的内存错误之一是在内存分配成功并且已初始化后，却在操作过程中越过了内存的边界。比如，在使用数组时经常会出现下标“多 1”或者“少 1”的错误。特别是在 for 循环语句中，循环次数容易出错，导致数组越界操作。

## 指南及规范0071——常见的内存错误及其对策4
常见的内存错误之一是忘记释放内存，从而导致内存泄漏。这种错误的函数每被调用一次，就会丢失一块内存。刚开始时，系统的内存充足，你看不到错误，但最终程序会突然死掉，系统会提示内存耗尽。动态内存的申请与释放必须配对，程序中 malloc 与 free 的使用次数一定要相同，否则肯定会有错误，同样的道理也适用于 new 和 delete。

## 指南及规范0072——常见的内存错误及其对策5
常见的内存错误及其对策包括释放了内存却继续使用它。具体来说，有三种情况需要特别注意：
首先，当程序中的对象调用关系过于复杂，难以准确判断某个对象是否已经释放内存时，建议重新设计数据结构，以彻底解决对象管理的混乱。
其次，要注意函数中 return 语句的正确性，避免返回指向栈内存的指针或引用，因为这些内存在函数结束时会自动销毁，可能导致后续的非法访问。
最后，使用 free 或 delete 释放内存后，务必将指针设置为 NULL，防止产生野指针，从而避免潜在的内存访问错误。
以上是常见的内存错误及其相应的解决对策。

## 指南及规范0073——常见的内存错误及其对策6
【规则 7-2-1】用 malloc 或 new 申请内存之后，应该立即检查指针值是否为 NULL。 防止使用指针值为 NULL 的内存。  
  
【规则 7-2-2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。  
  
【规则 7-2-3】避免数组或指针的下标越界，特别要当心发生“多 1”或者“少 1”操作。  
  
【规则 7-2-4】动态内存的申请与释放必须配对，防止内存泄漏。  
  
【规则 7-2-5】用 free 或 delete 释放了内存之后，立即将指针设置为 NULL，防止产生“野指针”。

## 指南及规范0074——指针与数组的对比
指针与数组有一些不同。数组要么在静态存储区被创建，如全局数组，要么在栈上被创建。数组名对应着一块内存，其地址与容量在生命周期内保持不变，只有数组的内容可以改变。而指针可以随时指向任意类型的内存块，它的特征是“可变”，因此常用指针来操作动态内存。虽然指针比数组灵活得多，但它们也更危险。

## 指南及规范0075——下面以字符串为例比较指针与数组的特性——1.修改内容

下例中：
字符数组 a 的容量是 6 个字符，其内容为 hello\0。a 的内容可以改变，如 a[0]等于 'X'。
指针 p 指向常量字符串“world”（位于静态存储区，内容为 world\0），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句 p[0]等于 'X'有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。

## 指南及规范0076——下面以字符串为例比较指针与数组的特性——2.内容复制与比较
以字符串为例，来比较指针与数组的特性。首先，不能对数组名进行直接复制与比较。如果想把数组 a 的内容复制给数组 b，不能使用语句 b 等于 a，否则会产生编译错误。应该使用标准库函数 strcpy 来进行复制。同样，比较数组 b 和数组 a 的内容是否相同时，不能使用 if(b 等于 a) 这样的判断方式，而应该使用标准库函数 strcmp 进行比较。另外，语句 p 等于 a 并不能把数组 a 的内容复制到指针 p，而是把数组 a 的地址赋给了指针 p。

## 指南及规范0077——下面以字符串为例比较指针与数组的特性——3.计算内存容量
下面以字符串为例比较指针与数组的特性。首先，计算内存容量时，可以用运算符 sizeof 计算出数组的容量（字节数）。在下面的例子中，sizeof(a) 的值是 12，因为别忘了字符串末尾的 "\0"。指针 p 指向数组 a，但是 sizeof(p) 的值是 4。这是因为 sizeof(p) 得到的是一个指针变量的字节数，相当于 sizeof(char*)，而不是 p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。需要注意的是，当数组作为函数的参数进行传递时，该数组会自动退化为同类型的指针。在下面的代码中，char a[] = "hello world"; char *p = a; c out << sizeof(a) << endl; 的输出是 12 字节，c out << sizeof(p) << endl; 的输出是 4 字节。在函数 void Func(char a[100]) 中，c out << sizeof(a) << endl; 的输出是 4 字节，而不是 100 字节。

## 指南及规范0078——指针参数是如何传递内存的1
当函数的参数是一个指针时，不要指望用该指针去申请动态内存。例如，在下面的代码中，Test函数中的语句GetMemory(str, 100)并没有使str获得期望的内存，str依旧是NULL。

这是因为当指针作为函数参数时，传递的是指针的副本而不是指针本身。在函数内部修改指针的值不会影响原始指针。另外，由于GetMemory函数内部没有释放动态分配的内存，每次调用该函数都会导致内存泄漏。

## 指南及规范0079——指针参数是如何传递内存的2
指针参数是如何传递内存的。 如果必须使用指针参数去申请内存，那么应该改用“指向指针的指针”。例如，在以下代码中，函数 GetMemory2 通过双重指针申请内存，并在 Test2 函数中使用这个申请到的内存：

在 GetMemory2 函数中，接受一个指向指针的指针，并根据传入的数值 num 申请相应大小的内存。 具体实现是通过 malloc 函数进行内存分配。 在 Test2 函数中，首先定义一个指针变量 str 并初始化为 NULL。 然后调用 GetMemory2 函数，将 str 的地址传递过去并申请 100 字节的内存。 注意这里传递的是 取地址str 而不是 str。 接着，将字符串 "hello" 复制到申请到的内存中，并输出。 最后，释放申请到的内存。
## 指南及规范0081——指针参数是如何传递内存的4
指针参数是如何传递内存的。用函数返回值来传递动态内存的方法虽然很方便，但常有人会误用 return 语句。需要特别注意，不要用 return 语句返回指向“栈内存”的指针，因为这种内存在函数结束时会自动消失。同样，如果 return 返回的是一个常量字符串，由于它位于静态存储区，所以在程序的整个生命周期内都是恒定不变的，无论什么时候调用该函数，返回的始终是同一个“只读”的内存块。
比如，有一个函数返回了一个局部数组的指针，由于该数组在函数结束时被销毁，所以返回的指针指向的是无效的内存地址，使用这个指针会导致程序输出垃圾内容。相反，如果函数返回一个指向常量字符串的指针，由于该字符串位于静态存储区，所以返回的指针始终是有效的，程序可以正确输出字符串内容。

## 指南及规范0082——free 和 delete 把指针怎么啦？
free,和delete,只会释放指针所指向的内存，但不会影响指针本身。指针p被free之后，其地址仍然不变（不是NULL），只是该地址对应的内存变成了垃圾，p成了“野指针”。如果此时不将p设置为NULL，可能会误导认为p是一个合法的指针。如果用if (p 不等于 NULL)语句进行防错处理，此时该语句并不起到防错作用，因为即便p不是NULL指针，它也不指向合法的内存块。示例代码中，首先分配了一块内存并赋值给指针p，然后将字符串"hello"复制到p指向的内存。接着，调用free(p)释放p指向的内存，但p本身的地址并未改变。之后的if (p 不等于 NULL)语句并未起到防错作用，因为p虽然不是NULL，但其指向的内存已经无效，因此继续操作会导致错误。

## 指南及规范0083——动态内存会被自动释放吗？
动态内存不会被自动释放。在函数体内的局部变量会在函数结束时自动消亡，但由程序员在函数体内主动申请到堆上的内存则不会被自动释放。即使指针消亡了，也不意味着它所指的内存会被自动释放。同样，内存被释放了也不意味着指针会消亡或者变成 NULL 指针。

## 指南及规范0085——有了 malloc/free 为什么还要 new/delete
有了 malloc 和 free，为什么还需要 new 和 delete 呢？malloc 和 free 是 C++/C 语言的标准库函数，而 new 和 delete 是 C++ 的运算符。它们都可以用于申请动态内存和释放内存。然而，由于 malloc 和 free 是库函数，而不是运算符，它们不在编译器的控制权限之内，因此无法执行构造函数和析构函数的任务。这就是为什么 C++ 需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete。需要注意的是，new 和 delete 并不是库函数。

## 指南及规范0087——malloc/free 的使用要点
使用 malloc 和 free 的要点如下。函数 malloc 的原型是 void * malloc(size_t size)，而 free 的原型是 void free(void * memblock)。malloc 的返回值类型是 void *，因此在调用 malloc 时，需要显式地将 void * 转换为所需的指针类型。malloc 函数并不关心申请的内存是什么类型，只关心内存的总字节数。如果指针 p 是 NULL，那么无论对 p 调用 free 多少次都不会有问题。但如果 p 不是 NULL，对 p 连续调用 free 两次会导致程序运行错误。

## 指南及规范0088——new/delete 的使用要点
在使用new,和delete时需要注意几个要点。new,内置了sizeof、类型转换和类型安全检查功能，对于非内部数据类型的对象，new在创建动态对象的同时完成了初始化工作。如果用new创建对象数组，那么只能使用对象的无参数构造函数。在用delete释放对象数组时，要注意不要遗漏中括号''。

## 指南及规范0089——函数重载的概念_重载的起源
在 C++ 程序中，可以将语义和功能相似的几个函数用同一个名字表示，这就是函数重载。函数重载有助于记忆并提高函数的易用性，这是 C++ 语言采用重载机制的一个原因。C++ 语言采用重载机制的另一个原因是类的构造函数需要重载机制，因为 C++ 规定构造函数与类同名，所以构造函数只能有一个名字。

例如，示例 8-1-1 中的函数 EatBeef、EatFish 和 EatChicken，可以用同一个函数名 Eat 表示，通过不同类型的参数来加以区别。EatBeef 可以改为 Eat(Beef 参数)，EatFish 可以改为 Eat(Fish 参数)，EatChicken 可以改为 Eat(Chicken 参数)。

## 指南及规范0090——函数重载的概念_重载是如何实现的？
函数重载的概念在于，编译器根据参数为每个重载函数产生不同的内部标识符。不同的编译器可能会产生不同风格的内部标识符。由于编译后的名字不同，C++程序不能直接调用C函数。为了解决这个问题，C++提供了一个C连接交换指定符号:extern "C"。需要注意的是，并不是两个函数的名字相同就能构成重载。全局函数和类的成员函数同名不算重载，因为它们的作用域不同。为了与成员函数Print区别，全局函数被调用时应加“定义域,即双冒号”标志，表示Print是全局函数而非成员函数。
例如：
extern "C" :
{
void foo(int x, int y);
// 其它函数;
}
// 或者写成
extern "C" :
{
\# include "myheader.h"
// 其它C头文件;
}
这就告诉C++编译器，函数foo是个C连接，应该到库中找名字_foo而不是_foo_int_int。C++编译器开发商已经对C标准库的头文件作了extern "C"处理，所以可以用#include直接引用这些头文件。

## 指南及规范0091——函数重载的概念_当心隐式类型转换导致重载函数产生二义性
函数重载的概念需要注意隐式类型转换导致重载函数产生二义性的问题。举个例子，下列代码中有两个 output 函数，第一个的参数是 int 类型，第二个的参数是 float 类型。由于数字本身没有类型，当数字作为参数传递时会自动进行类型转换，这被称为隐式类型转换。例如，语句 output(0.5) 会导致编译错误，因为编译器不知道该将 0.5 转换成 int 还是 float 类型的参数。尽管隐式类型转换在很多地方可以简化代码的书写，但也可能导致潜在的问题。在这段代码中，output(int x) 和 output(float x) 分别处理 int 和 float 类型的参数，并输出相应的结果。在 main 函数中，output(x) 输出 int 1，output(y) 输出 float 1，output(1) 输出 int 1，而 output(0.5) 会导致错误，因为存在二义性。通过显式转换，可以解决这个问题，如 output(int(0.5)) 输出 int 0，而 output(float(0.5)) 输出 float 0.5。 

## 指南及规范0092——成员函数的重载、覆盖与隐藏_重载与覆盖

成员函数被重载的特征：
（1）相同的范围（在同一个类中）。
（2）函数名字相同。
（3）参数不同。
（4）virtual 关键字可有可无。
覆盖是指派生类函数覆盖基类函数，特征是：
（1）不同的范围（分别位于派生类与基类）。
（2）函数名字相同。
（3）参数相同。
（4）基类函数必须有 virtual 关键字。
## 指南及规范0093——成员函数的重载、覆盖与隐藏_令人迷惑的隐藏规则

派生类的函数屏蔽了与其同名的基类函数，规则如下：
（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载混淆）。
（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。


## 指南及规范0094——成员函数的重载、覆盖与隐藏_摆脱隐藏
如果语句一定要调用基类的函数，那么在派生类中直接以基类，双冒号，函数名的格式调用即可。

## 指南及规范0095——参数的缺省值

有一些参数的值在每次函数调用时都相同，书写这样的语句会使人厌烦。C++语言采用参数的缺省值使书写变得简洁（在编译时，缺省值由编译器自动插入）。

【规则 8-3-1】参数缺省值只能出现在函数的声明中，而不能出现在定义体中。

【规则 8-3-2】如果函数有多个参数，参数只能从后向前挨个儿缺省，否则将导致函数调用语句怪模怪样。

要注意，使用参数的缺省值并没有赋予函数新的功能，仅仅是使书写变得简洁一些。它可能会提高函数的易用性，但是也可能会降低函数的可理解性。所以只能适当地使用参数的缺省值，要防止使用不当产生负面效果。

## 指南及规范0096——运算符重载_概念
在 C++语言中，可以用关键字 operator 加上运算符来表示函数，叫做运算符重载。
运算符与普通函数在调用时的不同之处是：1、对于普通函数，参数出现在圆括号内；2、而对于运算符，参数出现在其左、右侧。
如果运算符被重载为全局函数，那么只有一个参数的运算符叫做一元运算符， 有两个参数的运算符叫做二元运算符。
如果运算符被重载为类的成员函数，那么一元运算符没有参数，二元运算符只有一个右侧参数，因为对象自己成了左侧参数。
运算符的重载规则如下：1、所有的一元运算符都建议重载为成员函数；2、等于号，小括号，中括号，箭头符号这四类，只能重载为成员函数；3、加等于，减等于，除等于，乘等于，与等于，或等于，非等于，取模等于，右移等于，左移等于这些符号，建议重载为成员函数；剩下的所有其它运算符，建议重载为全局函数。

## 指南及规范0097——运算符重载_不能被重载的运算符
在 C++运算符集合中，有一些运算符是不允许被重载的。这种限制是出于安全方面的考虑，可防止错误和混乱。
（1）不能改变 C++内部数据类型（如 int, float 等）的运算符。
（2）不能重载点运算符，因为点运算符在类中对任何成员都有意义，已经成为标准用法。
（3）不能重载目前 C++运算符集合中没有的符号，如井号，艾特符号，美元符号等。原因有两点，一是难以理解，二是难以确定优先级。
（4）对已经存在的运算符进行重载时，不能改变优先级规则，否则将引起混乱。

## 指南及规范0098——函数内联_用内联取代宏代码
C++ 语言的函数内联机制既具备宏代码的效率，又增加了安全性，而且可以自由操作类的数据成员。  
所以在 C++ 程序中，应该用内联函数取代所有宏代码，“断言 assert”是唯一的例外。

## 指南及规范0099——函数内联_内联函数的编程风格
关于内联函数的编程风格有以下要点：关键字 `inline` 必须与函数定义体放在一起才能使函数成为内联函数。如果仅将 `inline` 放在函数声明前面，则不会起到内联函数的作用。

在类声明中定义的成员函数会自动成为内联函数，这是编译器的默认行为。

## 指南及规范0100——函数内联_慎用内联
慎用函数内联。
内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。但如果函数体内的代码较长，内联会导致内存消耗代价较高。另外，如果函数体内包含循环，执行函数体内代码的时间可能比函数调用的开销大，此时使用内联效果有限。
总之，内联应根据具体情况而定，不宜滥用。