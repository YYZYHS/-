# 数据结构
## 数据结构0006 数据结构
数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

## 数据结构0007 数据对象VS数据结构
数据对象和数据结构之间有着微妙的区别和联系。数据对象侧重于描述具有相同性质的数据集合，而数据结构则更关注于数据元素之间的组织和关系。在不同的条件下，相同的数据对象可以构建出不同的数据结构；同样地，相同的数据元素也可以在不同的背景下形成不同的数据结构。此外，不同的数据元素也能够组合成具有相同结构的数据集合。
数据结构这门学科特别强调了对数据元素之间关系的理解和操作，而对数据项具体内容的细节则不作为关注点。

## 数据结构0018 数据类型、抽象数据类型
数据类型，指的是一个值的集合以及定义在这个集合上的一组操作的总称。原子类型是指那些值不可再分的数据类型。而结构类型则是可以将其值分解为若干成分或分量的数据类型。抽象数据类型（ADT）是指一种数学模型，用来描述数据类型的抽象特性和对应的操作。

## 数据结构0021 “好”算法的特质
好算法的特质包括几个重要方面。首先是正确性，即算法必须能够准确地解决问题，不论问题的复杂程度如何。其次是可读性，良好的可读性有助于他人理解算法的设计和逻辑。算法还应具备健壮性，即使在面对非法输入数据时，也能做出适当的响应或处理，而不会产生意外的输出结果。此外，算法的效率是评判其优劣的重要标准，通常通过时间复杂度和空间复杂度来衡量。高效率意味着算法在执行时花费较少的时间，即时间复杂度低；而低存储量需求则表示算法在运行过程中占用较少的内存空间，即空间复杂度低。

## 数据结构0026 计算时间复杂度的技巧分析
当分析算法的时间复杂度时，有几个关键的技巧需要注意。
首先，顺序执行的代码通常只会对常数项有影响，因此在计算时间复杂度时可以忽略这部分。
其次，对于循环结构，我们只需挑选其中一个基本操作来分析其执行次数与输入规模 ( n ) 的关系。这意味着，无论循环内部的具体操作多复杂，我们只关注其执行次数与 ( n ) 的增长关系。
最后，如果算法中存在多层嵌套循环，我们只需关注最深层循环内部语句的执行次数，即这些语句会执行多少次，因为这通常决定了整体算法的时间复杂度。


## 数据结构0040 静态分配_C语言版_静态顺序表的插入
C语言版-静态顺序表的插入：
注释：
一、List Insert 函数用于在顺序表 L 的第 i 个位置插入元素 e。
二、在插入和删除时，需要进行位置的合法性检查，包括检查插入位置是否合法，顺序表是否已满以及删除位置是否合法。
三、插入时，需要将第 i 个位置及其后的元素依次后移，并将元素 e 插入到第 i 个位置。
四、索引 i 从1开始。
五、插入和删除的时间复杂度为大O(n)。
## 数据结构0042 静态分配_C语言版_静态顺序表的查找
C语言版-静态顺序表的查找:
注释：
一、Locate Element 函数用于按值查找元素 e 在顺序表 L 中的位置，返回其位序（位序从1开始）。
二、Get Element 函数用于按位查找顺序表 L 中位序为 i 的元素，返回其值。
三、若查找失败，Locate Element 返回0，Get Element 返回错误标志。

## 数据结构0045 静态分配_C++版_静态顺序表初始化和销毁
C++版-静态顺序表初始化和销毁：
注释：
一、Sequential List() 函数是默认构造函数，用于初始化顺序表，将长度初始化为0。
二、波浪号Sequential List() 函数是析构函数，用于清理顺序表的资源。由于静态顺序表的内存是在栈上分配的，因此无需手动释放内存，内存会在函数执行结束时自动释放，所以该析构函数为空函数。

## 数据结构0046 静态分配_C++版_静态顺序表插入
C++版-静态顺序表插入：
注释：
一、List Insert 函数用于在顺序表的第 i 个位置插入元素 e。
二、在插入和删除时，需要进行位置的合法性检查，包括检查插入位置是否合法，顺序表是否已满以及删除位置是否合法。
三、插入时，需要将第 i 个位置及其后的元素依次后移，并将元素 e 插入到第 i 个位置。
四、索引 i 从1开始。
五、插入和删除的时间复杂度为大O(n)。
## 数据结构0050 动态分配_C语言版_动态顺序表初始化和销毁
C语言版-动态顺序表初始化和销毁：
注释：
一、Init List() 函数用于初始化动态顺序表 L。
二、Destroy List() 函数用于销毁动态顺序表 L。
三、使用 malloc() 函数动态分配数组空间。malloc()原型 ：void *malloc(size_t size);malloc() 函数用于在堆上动态分配指定大小的内存空间，并返回一个指向该内存空间的指针。如果分配失败，则返回 NULL。
四、使用 free() 函数销毁数组空间。free()原型：void free(void *ptr);free() 函数用于释放之前使用 malloc()、calloc() 或 realloc() 分配的动态内存空间。被释放的内存空间会被归还给系统，并可以被系统重新分配给其他用途。
五、将顺序表的指针 data 置为 NULL。在释放动态分配的内存空间后，将指向该内存空间的指针设置为 NULL，可以防止程序继续引用已经释放的内存，避免产生野指针。
六、如果内存分配失败，需要进行相应的错误处理。
七、将顺序表的长度初始化为0，最大容量初始化为 MaxSize。

## 数据结构0051 动态分配_C语言版_动态顺序表的扩容
C语言版-动态顺序表的扩容：
Increase Size（） 函数用于增加顺序表的最大长度，它的主要工作如下：
一、将表的最大长度增加为原来的两倍。
二、使用 malloc 函数重新分配内存空间，并将新空间地址赋给 L点data指针。
三、如果分配失败，则输出提示信息。

## 数据结构0052 动态分配_C语言版_动态顺序表的按位插入
C语言版-动态顺序表的按位插入：
List Insert 函数用于在顺序表 L 的第 i 个位置插入元素 e。
如果插入位置不合法，则输出提示信息并返回。
如果顺序表已满，则调用 Increase Size 函数增加表最大长度。
插入元素后，顺序表的长度增加1。

## 数据结构0053 动态分配_C语言版_动态顺序表的按位删除
C语言版-动态顺序表的按位删除：
Lis tDelete 函数用于删除顺序表 L 的第 i 个位置的元素，并将删除的元素值存放到 e 中。如果删除位置不合法，则输出提示信息并返回。删除元素后，顺序表的长度减少1。
## 数据结构0054 动态分配_C语言版_动态顺序表的查找
C语言版-动态顺序表的查找:
注释：
一、Locate Element 函数用于按值查找顺序表 L 中元素 e，返回其在顺序表中的位置。如果找到元素，则返回其在顺序表中的位置（从1开始）。如果未找到元素，则返回0。
二、Get Element 函数用于按位查找顺序表 L 中第 i 个位置的元素。如果位置不合法，则输出提示信息并返回错误值。如果位置合法，则返回第 i 个位置的元素值。索引 i 从1开始。
三、插入和删除的时间复杂度为大O(n)。

## 数据结构0057 动态分配_C++版_动态顺序表初始化和销毁
C++版-动态顺序表初始化和销毁。
注释：
一、Dynamic Sequential List() 是默认构造函数，用于初始化顺序表，将容量初始化为某个值。默认构造函数是在没有提供任何参数的情况下调用的构造函数。在该情况下，Dynamic Sequential List() 会被调用，用于创建顺序表对象并将其容量初始化为某个值。
二、使用 new 关键字动态分配数组空间。new 关键字用于在堆上动态分配内存空间。在这里，new 被用来分配一个大小为 maxSize 的数组空间，并返回指向该空间的指针。
三、使用 delete 关键字销毁动态分配的数组空间。delete 关键字用于释放之前使用 new 关键字分配的动态内存空间。在这里，delete 中括号 被用来释放动态分配的数组空间。
四、波浪号Dynamic Sequential List() 是析构函数，用于释放顺序表的内存。析构函数是在对象销毁时自动调用的函数。在这里，波浪号Dynamic Sequential List() 被用来释放顺序表对象所分配的内存空间。
