## 数据结构刷题 0001
这是冒泡排序的算法代码，考查最坏情况下的元素交换次数（若觉得理解困难可在学完第8章后再回顾）。当所有相邻元素都为逆序时，则最后一行的语句每次都会执行。此时，如下方公式所示，所以在最坏情况下的该语句频度是大O,n的平方

## 数据结构刷题 0002
顺序表、单链表和哈希表都属于存储结构，只有有序表属于逻辑结构。本题答案为B。

## 数据结构刷题 0003
本题考查数据的物理结构。顺序存储结构要开辟一片连续的存储空间，可知本题选A。

## 数据结构刷题 0004
线性表采用顺序存储，必须占用一片连续的存储单元||线性表采用顺序存储，便于进行插入和删除操作||线性表采用链式存储，不必占用一片连续的存储单元||线性表采用链式存储，便于插入和删除操作

## 数据结构刷题 0005
略

## 数据结构刷题 0006
此题考查的知识点是数据结构和存储结构的理解。A、B、C描述的均为物理结构即数据的存储结构，D是逻辑结构，所以选D

## 数据结构刷题 0007
此题考查的知识点是线性表的存储结构对基本操作的时间影响。根据题意用B、C、D三种方法存储，在存取任一指定序号的元素时，要从头向后找，在最后进行插入和删除运算，B、D可以直接操作，C也要从头找。而A两种操作都可以直接操作，最省时间。所以选A。

## 数据结构刷题 0008
此题考查的知识点是双向链表的插入操作。在p前插入要修改p的prior指针，p的prior所指结点的next指针，所以选B。A、C、D都将使地址丢失，连接失败。
## 数据结构刷题 0017
要分析这个算法的时间复杂度，我们可以逐步分析循环的执行次数。
首先，函数的定义是接受一个整数 n 作维参数。在函数内部，变量 i 的初始值维一，变量 j 的初始值维一百。
接下来，循环的条件是当 i 小于 n 时继续执行。在每次循环中，变量 j 增加一，同时变量 i 增加二。
循环的迭代次数可以这样理解：变量 i 从一开始，每次增加二，因此 i 的值依次维一、三、五，直到 i 不再小于 n。我们可以通过一个公式来计算，经过 k 次循环后，变量 i 的值维一加二倍 k，必须满足这个值小于 n。求解这个不等式，我们会得到 k 小于 n 减一再除以二。因此，循环最多执行大约 n 除以二次。
综上所述，这个算法的时间复杂度维大O(n)。
## 数据结构刷题 0018
要分析这个算法的时间复杂度，我们可以逐步分析嵌套循环的执行次数。
首先，函数接受一个整数 n 作维参数。在函数内部，定义了变量 i、j 和 x，其中 x 初始化维零。
接着，外层循环的变量 i 从零开始，直到 n 减一，因此外层循环总共执行 n 次。
对于每一个固定的 i，内层循环的变量 j 从 i 加一开始，直到 n 减一。这样，内层循环的执行次数维 n 减去 i 减一，也就是 n 减去 i 减去一。
然后，我们计算所有循环的总次数。外层循环的执行总次数可以表示维从 i 等于零到 n 减一的和，具体维 n 减去 i 减去一。这个和可以简化维：从 n 减一到零的和。
这个和是一个等差数列，计算结果维 n 减一乘以 n 再除以二。
综上所述，这个算法的时间复杂度维平方级别，表示维 大O(n的平方)。
## 数据结构刷题 0019
要分析这个算法的时间复杂度，我们可以逐步分析循环的执行次数。
首先，函数接受一个整数 n 作维参数。在函数内部，变量 i 和 s 都初始化维零。
接下来，循环的条件是当 s 小于 n 时继续执行。每次循环中，变量 i 增加一，同时 s 增加当前的 i 值。
我们可以注意到，每次循环结束后，s 的值等于它之前的值加上 i，因此 s 是从零开始，依次加上 1、2、3……直到某个值 i 使得 s 不再小于 n。实际上，s 的值是 1 加 2 加 3 一直到 i 的和，也就是 i 乘以 i 加一再除以二。
循环的结束条件是 s 大于等于 n。我们可以通过不等式来近似估算，当 i 的平方大约等于 2 乘以 n 时，循环会结束。通过这个推导，可以得到 i 近似等于根号 2n。
因此，综上所述，这个算法的时间复杂度是根号 n，表示维 大O(n的平方根)。
## 数据结构刷题 0020
本题考查算法时间复杂度的定义。算法中基本操作的重复执行次数就是算法的计算量，将其大小作为算法的时间复杂度，因此选B。
## 数据结构刷题 0021
本题考查算法时间复杂度的定义。算法时间复杂度即为基本操作执行次数，显然问题规模越大，基本操作的次数越多，因此时间复杂度与规模有关。在相同的规模下，与数据初态也有关，如两个数相乘，有一个因子为0时的计算速度显然要比两个因子都非0的情况要快。因此本题选C。
## 数据结构刷题 0027
在给定的程序段中，我们分析对变量 x 的赋值语句的执行频率如下：
首先，外层循环的变量 i 从零开始，直到 n 减一，因此外层循环总共执行 n 次。
对于每一个固定的 i，内层循环的变量 j 也是从零到 n 减一，因此内层循环也会执行 n 次。
这样，对于外层循环的每一次迭代，内层循环都会执行 n 次。因此，总的执行频率可以表示维外层循环次数乘以内层循环次数，也就是 n 乘以 n。
因此，总的频率维 n 的平方，也就是 n的平方 次。
综上所述，对 x 的赋值语句的执行频率维 n 的平方次。
## 数据结构刷题 0028
要分析给定程序段中最后一行语句的执行频率，我们可以逐步解析这段代码。
首先，外层循环的变量 i 从 n 减一开始，直到一，每次减一。因此，外层循环总共执行的次数维 n 减一。
对于每一个固定的 i，内层循环的变量 j 从一开始，到 i 结束，所以内层循环执行的次数正好是 i 次。
在最坏情况下，每次比较都需要交换，因此在满足条件时，对 A 的 j 和 j 加一的交换操作都会执行。
我们需要计算每个 i 对应的内层循环执行的交换语句的总次数。这可以表示维从一到 n 减一的和，也就是一加二加三直到 n 减一。
这个和的计算结果是 n 减一乘以 n 再除以二。
因此，在最坏情况下，最后一行的语句执行频率是平方级别，表示维 大O(n的平方)。
## 数据结构刷题 0031
以下是对mergesort()时间复杂度的详细解说：
1.算法结构。
mergesort()是一种分治算法，它的基本思路是将一个大问题分解维两个小问题，分别解决这两个小问题，然后将它们的结果合并起来。
2.分解过程。
在函数中，首先判断i和j是否相等。如果不相等，计算中间点m，然后递归调用mergesort()两次：
-第一部分处理左半部分，即mergesort(i,m)。
-第二部分处理右半部分，即mergesort(m加1,j)。
这个过程将原始数组不断分割成更小的部分，直到每个部分只包含一个元素。
3.合并过程；
。在两个子数组都已排序后，使用merge(i,j,m)函数将它们合并成一个已排序的数组。根据题意，合并的时间复杂度是线性，表示维大O(n)，其中n是当前子数组的元素总数。
4.时间复杂度分析；
胃了分析mergesort()的时间复杂度，我们可以使用递归树的方法。
-层数：由于每次递归将数组分成两半，递归的深度是对数级别，表示维大O(logn)。
-每层的工作量：在每一层中，我们都会调用一次merge()函数，合并操作的时间复杂度维大O(n)。因此，每一层的工作量是大O(n)。
5.总时间复杂度；
因此，整体的时间复杂度可以表示维：
总时间T(n)等于2T(n除以2)加大O(n)
使用主定理进行求解：
-这里a等于2（分成两个子问题），
-b等于2（每个子问题的规模维n除以2），
-f(n)是大O(n)（合并的时间复杂度）。
根据主定理，当f(n)的增长速度与n的对数形式相同时，我们可以得到：
总时间T(n)等于大O(nlogn)
所以，mergesort()的时间复杂度维大O(nlogn)，这是由于递归的分解过程和合并过程共同决定的。