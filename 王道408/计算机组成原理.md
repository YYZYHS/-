<center style="font-family: 华文新魏"><font size="12px" color="#4870ac">王道408 计算机组成原理</font></center>

[toc]

# 第1章 计算机系统概述

## 1.0 序言

- 计算唯一能识别的数据----`二进制 0/1`

- **电信号**:
  - **高电平 (High Level)**：指电信号的电压处于`较高`的状态。
    - 在数字系统中，通常表示逻辑"1"。
    - 高电平状态通常是指电压超过某个特定的阈值，以便被系统识别为"高"。
    - 在数字电路中，高电平状态可能代表着不同的意义，如代表着某个开关打开或者某个逻辑功能为真。
  
  - **低电平 (Low Level)**：与高电平相对，表示电信号的电压处于`较低`的状态。
    - 在数字系统中，通常表示逻辑"0"。
    - 与高电平类似，低电平状态也会被系统识别为"低"的状态。
    - 在数字电路中，低电平状态可能代表着不同的意义，如代表着某个开关关闭或者某个逻辑功能为假。
  
- 计算机通过`电信号`传递数据

## 1.1 计算机发展历程

### 1.1.0 什么是计算机系统

$$
\text{计算机系统}
	\left\{
		\begin{array}{l}
            \text{硬件}
            \\
            \text{软件}
                \left\{
                    \begin{array}{l}
                    	\text{系统软件} \rightarrow\text{用来管理整个计算机系统}
                    	\\
                    	\text{应用软件} \rightarrow\text{按任务需要编制成的各种程序}
                    \end{array}
                \right.
		\end{array}
	\right.
$$



- 计算机系统 = 硬件 + 软件
  - 硬件：计算机的`实体`，如主机、外设等。
  - 软件：由具有各类特殊功能的`程序`组成。
    - **系统软件**：用来`管理`整个计算机系统
      - E.g.:操作系统、数据库管理系统(DBMS)、标准程序库、网络软件、语言处理程序服务程序
    - **应用软件**：按任务需要编制成的`各种程序`
      - E.g.:抖音、王者荣耀、迅雷、美图秀秀…
- 计算机性能的好坏取决于`“软”、“硬”件功能的总和`。

### 1.1.1 计算机硬件的发展

- `了解`：第一台`电子数字计算机`：`ENIAC`(1946)
  - 采用`电子管`作为其逻辑元件

- 计算机硬件的发展历程⭐

| 发展阶段 |   时间    |         逻辑元件         | 速度(次/每秒) |      内存      |              外存              | 备注    |
| :------: | :-------: | :----------------------: | :-----------: | :------------: | :----------------------------: | ------------------------------------------------ |
|  第一代  | 1946-1957 |          电子管          |   几千-几万   | 汞延迟线、磁鼓 |         穿孔卡纸、纸袋         |                                                  |
|  第二代  | 1958-1964 |          晶体管          |  几万-几十万  |   磁芯存储器   |              磁带              | 操作系统开始出现                                 |
|  第三代  | 1964-1971 |     中小规模集成电路     | 几十万-几百万 |  半导体存储器  |           磁带、磁盘           | 高级语言快速发展<br />开始有了分时操作系统       |
|  第四代  | 1972-现在 | 大规模、超大规模集成电路 |  上千万-万亿  |  半导体存储器  | 磁盘、磁带、光盘、半导体存储器 | 开始出现“微处理器”、微型计算机、个人计算机（PC） |

### 1.1.2 计算机软件的发展

- 计算机语言的发展
  - 机器语言 --> 汇编语言 --> 高级语言

- 计算机系统的发展
  - 手工阶段 --> 批处理操作系统 --> 分时系统 --> 实时系统


### 1.1.3 目前的发展趋势

- 两极分化
  - 一极是微型计算机向更微型化、网络化、高性能、多用途方向发展;
  - 另一极是巨型机向更巨型化、超高速、并行处理、智能化方向发展。

## 1.2 计算机系统层次结构

### 1.2.1 计算机系统的组成

#### 1.2.1.1 早期的冯诺依曼机

![image-20240308203114110](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240308203114110.png)

- 冯诺依曼首次提出“**存储程序**”的概念：是指`将指令以二进制代码的形式事先输入计算机的主存储器`，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。
- **冯诺依曼结构及每部分的作用**
  - **输入设备**：将信息转换成机器能够识别的形式
  - **输出设备**：将结果转换成人们熟悉的形式
  - **存储器**：存放数据和程序
  - **运算器**：执行算术运算和逻辑运算
  - **控制器**：指挥程序运行
  - `Note`：在计算机系统中，软件和硬件在逻辑上是等效的。
- **冯诺依曼机的特点**
  1. 计算机由五大部件组成
  2. 指令和数据以同等地位存于存储器，可按地址寻访
  3. 指令和数据用二进制表示
  4. 指令由操作码和地址吗组成
  5. 存储程序
  6. <font color=red>以运算器为中心</font>：即输入/输出设备与存储器之间的数据传送通过运算器完成

#### 1.2.1.2 现代的计算机的结构

![image-20240308204139398](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240308204139398.png)

- 现代计算机：<font color=red>以存储器为中心</font>
  - CPU = 控制器 + 运算器 （随着现代工艺的发展，人们已经把控制器和运算器集成到了一起，也就是中央处理器CPU）
  - ![image-20240308204549101](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240308204549101.png)
  - ![image-20240308210604829](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240308210604829.png)

### 1.2.2 计算机硬件

#### 1.2.2.1 主存储器的基本组成

- 主存储器
  - ![image-20240308211254643](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240308211254643.png)
  - **存储体**：数据在存储体内按地址存储
  - **存储单元**：每个存储单元`存放一串二进制代码`，每个`地址`对应一个`存储单元`。
  - **存储字**：存储单元中`二进制代码`的`组合`。
  - **存储字长**：存储单元中`二进制代码`的`位数`。
  - **存储元**：即存储二进制的`电子元件`(一般是电容)，每个存储元可存`1bit`。
  - MAR VS MDR
    - **MAR (Memory Address Register)**：存储器`地址寄存器`，用于存储`要访问的存储器地址`。
      - 当计算机需要读取或写入存储器中的数据时，它首先将要访问的地址加载到 MAR 中。MAR 的值用于指示存储器中的特定位置，以便在存储器中读取或写入数据。
      - MAR位数反映存储单元的个数。
    - **MDR (Memory Data Register)**：存储器`数据寄存器`，用于存储从存储器中读取的数据，或者将要写入存储器的数据。
      - 当计算机需要从存储器中读取数据时，存储器将数据传送到 MDR 中。同样地，当计算机需要将数据写入存储器时，它首先将数据加载到 MDR 中，然后将数据写入存储器中的指定位置。
      - MDR的位数 = 存储字长
    - 例：
      - MAR = 4位 --> 总共有$2^4$个存储单元
      - MDR = 16位 --> 每个存储单元可以放16个bit，即1个字（word） = 16bit
    - 易混淆的点
      - `1B = 1个字节（Byte）= 8bit`
      - `1b = 1bit`
      - 一个字的长度是`MDR的位数`，因此其大小视计算机的`存储字长`而定

#### 1.2.2.2 运算器的基本组成

- 运算器
  - ![image-20240308215528876](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240308215528876.png)
  
  - 运算器：用于实现`算术运算`(如：加减乘除)和`逻辑运算`(如：与或非),他主要有四个寄存器:
  
    - **ACC(Accumulator)**：`累加器`，用于`存放操作数`，或`运算结果`。
    - **MQ(Multiple-Quotient Register)**：`乘商寄存器`，在乘、除运算时，用于`存放操作数`或`运算结果`。
    - **X**：`通用的操作数寄存器`，用于`存放操作数`
    - **ALU(Arithmetic and Logic Unit)**⭐⭐：`算术逻辑单元`，通过内部复杂的电路实现`算数运算、逻辑运算`
  
  - |      | 加             | 减             | 乘             | 除               |
    | ---- | -------------- | -------------- | -------------- | ---------------- |
    | ACC  | 被加数<br />和 | 被减数<br />差 | 乘积高位       | 被除数<br />余数 |
    | MQ   |                |                | 乘数、乘积低位 | 商               |
    | X    | 加数           | 减数           | 被乘数         | 除数             |

#### 1.2.2.3 控制器的基本组成

- 控制器
  - ![image-20240308222132405](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240308222132405.png)
  - 控制器：指挥程序运行，负责指导和管理计算机系统中的各种操作，它主要由三个寄存器组成：
    - **程序计数器PC(Program Counter)**：`取指令`，存放下一条指令地址，有自动加1功能。
    - **指令寄存器IR(Instruction Register)**：`分析指令`，存放当前执行的指令。
    - **控制单元CU(Control Unit)⭐⭐**：`执行指令`，给出控制信号。
#### 1.2.2.4 计算机的工作原理

![image-20240308223016389](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240308223016389.png)

以“取数”指令的执行位例

![image-20240308224043442](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240308224043442.png)

- 执行指令阶段，不同的指令具体步骤不同。
- CPU区分指令和数据的依据：根据指令周期的不同。

### 1.2.3 计算机系统的层次结构

![image-20240308225039341](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240308225039341.png)

#### 1.2.3.1 计算机系统的五层结构

$$
\text{计算机系统的五层结构}
\left\{
	\begin{array}{l}
		\text{M4:高级语言机器} & \text{执行高级语言}\\
		\text{M3:汇编语言机器} & \text{执行汇编语言}\\
		\text{M2:操作系统机器} & \text{向上提供广义指令}\\
		\text{M1:传统机器} & \text{执行机器语言指令}\\
		\text{M0:微程序机器} & \text{执行微指令}\\
	\end{array}
\right.
$$



#### 1.2.3.2 三种级别的语言

- 三种级别的语言
  - 高级语言
  - 汇编语言
  - 机器语言

- 编译程序 VS 解释程序
  - **编译程序**：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序（`只需翻译一次`）
  - **解释程序**：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句（`每次执行都要翻译`）
- ![image-20240308225528282](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240308225528282.png)

#### 1.2.3.3 计算机体系结构Vs计算机组成原理

- 计算机体系结构：机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性。（指令系统、数据类型、寻址技术、I/O机理）
  - 即：如何设计硬件与软件之间的接口。
- 计算机组成原理：实现计算机体系结构中所体现的属性，对程序员透明。（具体指令的实现）
  - 即：如何用硬件实现所定义的接口。



## 1.3 计算机的性能指标

### 1.3.1 计算机的主要性能指标

#### 1.3.1.1 存储器的性能指标

- **⭐⭐总容量** = 存储单元个数×存储字长 （bit） = 存储单元个数×存储字长/8 （Byte）
- E.g.：MAR为32位，MDR为8位，则存储器总容量 $\begin{array}{l} =2^{32} \times 8 \quad (bit) \\= 2^{32} \quad (Byte) \\= 2^2 \quad (GB) \\= 4GB\end{array}$
- 常见的容量单位：
  - $2^{10}:K$
  - $2^{20}:M$
  - $2^{30}:G$
  - $2^{40}:T$​
- `注` ：此处是指二进制数的位数，与数量单位不同

#### 1.3.1.2 CPU的性能指标

- **CPU主频**：CPU内数字脉冲信号振荡的频率。

  - CPU的时钟周期：一个脉冲信号的持续时间，单位——微妙，纳秒。
  - $CPU主频（时钟周期）= \frac{1}{CPU的时钟周期}(Hz)$
  - 例：CPU主频10Hz --> 10个/秒

- CPI（Clock cycle Per Instruction）:执行一条指令所需的时钟周期数。

  - 不同的指令，CPI不同，甚至相同的指令，CPI也可能有变化。

  - 执行一条指令的耗时= $CPI \times CPU时钟周期$

  - CPU执行时间（整个程序的耗时）=$\frac{CPU时钟周期数}{主频}=\frac{指令条数 \times CPI)}{主频}$

  - E.g.：

    > 某CPU主频为1000Hz,程序包含100条指令，平均来看指令的CPI=3。问：该程序在该CPU上执行需要多久？
    > $$
    > 100 \times 3 \times \frac{1}{1000} = 0.3(s)
    > $$

- IPS(Instructions Per Second)：每秒执行多少条指令。

  - $IPS=\frac{主频}{平均CPI}$​
  - 常用的单位：KIPS，MIPS

- FLOPS(Floating-point Operations Per Second)：每秒执行多少次浮点运算。

  - 常用的单位：KFLOPS，MFLOPS，GFLOPS，TFLOPS

- `注`：此处K、M、G、T为数量单位，$\begin{array}{l}K=Kilo=千=10^3\\M=Million=百万=10^6,\\G=Giga=十亿=10^9,\\T=Tera=万亿=10^{12}\end{array}$

#### 1.3.1.3 系统整体的性能指标

- 数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）
- 吞吐量：指系统在单位时间内处理情求的数量。
  - 它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。
- 响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。
  - 通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/O操作、操作系统开销等时间）
- 动态测试
  - 基准程序（跑分软件）：是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同的其它计算机性能进行比较。

#  第2章 数据的表示和运算

## 2.1 数制与编码

### 2.1.1 进位计数制

#### 2.1.1.1 十进制计数法

- 是“进位计数制”，有0~9，共十种符号，基于“乘法”思想的计数方法，逢十进一

- 符号反映权重,符号所在的位置也反映权重

- $$
  \begin{array}{l}
  十进制:\quad K_nK_{n-1}K_{n-2}...K_2K_1K_0K_{-1}K_{-2}...K_{-m}
  \\
  \qquad\qquad=K_{n} \times 10^{n}+K_{n-1} \times 10^{n-1}+...+K_{2} \times 10^{2}+K_{1} \times 10^{1}+K_{0} \times 10^{0}
  \\
  \qquad\qquad +K_{-1} \times 10^{-1}+K_{-2} \times 10^{-2}+...+K_{-m} \times 10^{-m}
  \\
  其中,10^{n}称为位权
  	\end{array}
  $$

#### 2.1.1.2 推广：r进制计数法

$$
\begin{array}{l}
r进制:\quad K_nK_{n-1}K_{n-2}...K_2K_1K_0K_{-1}K_{-2}...K_{-m}
\\
\qquad\qquad=K_{n} \times r^{n}+K_{n-1} \times r^{n-1}+...+K_{2} \times r^{2}+K_{1} \times r^{1}+K_{0} \times r^{0}
\\
\qquad\qquad +K_{-1} \times r^{-1}+K_{-2} \times r^{-2}+...+K_{-m} \times r^{-m}
\\
其中,r^{n}称为位权
	\end{array}
$$

- 基数：每个数码位所用到的不同符号的个数，r进制的基数为r
  - 二进制：0,1
  - 八进制：0,1,2,3,4,5,6,7
  - 十进制：0,1,2,3,4,5,6,7,8,9
  - 十六进制：0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F
- 二进制是最适合计算机处理的数据进制
  - 可使用两个稳定状态的物理器件表示
  - 0,1正好对应逻辑值假、真。方便实现逻辑运算
  - 可很方便地使用逻辑门电路实现算术运算

#### 2.1.1.3 任意进制→十进制

##### 2.1.1.3.1 方法

$$
\begin{array}{l}
r进制:\quad K_nK_{n-1}K_{n-2}...K_2K_1K_0K_{-1}K_{-2}...K_{-m}
\\
\qquad\qquad=K_{n} \times r^{n}+K_{n-1} \times r^{n-1}+...+K_{2} \times r^{2}+K_{1} \times r^{1}+K_{0} \times r^{0}
\\
\qquad\qquad +K_{-1} \times r^{-1}+K_{-2} \times r^{-2}+...+K_{-m} \times r^{-m}
\\
其中,r^{n}称为位权
	\end{array}
$$

将一个任意进制数转换为十进制数的步骤如下：

1. **确定原数的进制**: 首先，确定原数是哪种进制，比如二进制、八进制、十六进制等。

2. **展开原数**: 将原数按照对应的进制，按位展开，从右向左，每一位对应一个权重。

3. **计算权重**: 计算每一位的权重，权重是进制的基数的幂，幂的指数从零开始，向左递增。例如，在十进制中，第一位的权重为 $0$，第二位的权重为 $1$，以此类推。

4. **乘以权重并相加**: 将每一位的数值乘以对应的权重，并将结果相加，得到十进制数。

5. **得到结果**: 最终的和即为原数的十进制表示。

通过这种方法，可以将任意进制的数转换为十进制数。

##### 2.1.1.3.2 举例

举例来说，如果要将二进制数 $1011$ 转换为十进制数：

1. 确定原数的进制为二进制。
2. 展开原数得到 $1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0$。
3. 计算权重为 $2^3 = 8, 2^2 = 4, 2^1 = 2, 2^0 = 1$。
4. 将每一位的数值乘以对应的权重并相加，得到 $8 + 0 + 2 + 1 = 11$。
5. 结果为 $11$，因此二进制数 $1011$ 转换为十进制数为 $11$。

#### 2.1.1.4 二进制←→八进制十六进制

##### 2.1.1.4.1 二进制-->八进制

- 方法：3位一组，每组转换成对应的八进制符号，整数不足三位的，在数的左端加0补足三位，小数不足三位的，在数的右端加0补足三位。

- 举例：

- $$
  \begin{array}{l}
  \underline{\color{red}{00}1} \quad \underline{111} \quad \underline{000} \quad \underline{010} \,.\,\underline{011} \quad \underline{01\color{red}{0}}
  \\
  \quad1\qquad7\qquad0\qquad2 \,.\,\quad3\qquad2
  	\end{array}
  $$

##### 2.1.1.4.2 二进制-->十六进制

- 方法：4位一组，每组转换成对应的十六进制符号，整数不足四位的，在数的左端加0补足四位，小数不足四位的，在数的右端加0补足四位。

- 举例：

- $$
  \begin{array}{l}
  \underline{\color{red}{00}11} \quad \underline{1100} \quad \underline{0010}  \,.\,\underline{0110} \quad \underline{1\color{red}{000}}
  \\
  3\qquad\quad C\qquad\quad2\,\,\,.\,\quad6\qquad8
  	\end{array}
  $$

##### 2.1.1.4.3 八进制-->二进制

- 方法：每位八进制转换成对应的3位二进制
- 举例：$(251.5)_8 \to (010\,101\,001.\,101)_2$

##### 2.1.1.4.4 十六进制-->二进制

- 方法：每位十六进制转换成对应的4位二进制
- 举例：$(AE86.1)_{16} \to (1010\,1110\,1000\,0110.\,0001)_2$​

#### 2.1.1.5 十进制→任意进制

- 整数部分：**除基取余法**

  - 原理

    - $$
      \begin{array}{l}整数部分:
      \frac{K_{n} \times r^{n}+K_{n-1} \times r^{n-1}+...+K_{2} \times r^{2}+K_{1} \times r^{1}+K_{0} \times r^{0}}{r}
      \\
      \qquad \qquad=K_{n} \times r^{n-1}+K_{n-2} \times r^{n-3}+...+K_{2} \times r^{1}+K_{1} \times r^{0}+K_{0}
      \\
      其中:
      \\K_{n} \times r^{n-1}+K_{n-2} \times r^{n-3}+...+K_{2} \times r^{1}+K_{1} \times r^{0}是 {\color{red}商} ,
      \\K_{0}是 {\color{red}余数} ,且任一数码位K_i < r
      \end{array}
      $$

- 小数部分：**乘基取整法**

  - 原理

  	- $$
    \begin{array}{l}小数部分:
    (K_{-1} \times r^{-1}+K_{-2} \times r^{-2}+...+K_{-m} \times r^{-m}) \times r
    \\
    \qquad \qquad=K_{-1} \times r^{0}+K_{-2} \times r^{-1}+...+K_{-m} \times r^{-(m-1)}
    \\
    其中:
    \\K_{-1} \times r^{0}是 {\color{red}整数部分} ,
    \\K_{-2} \times r^{-1}+...+K_{-m} \times r^{-(m-1)}是 {\color{red}小数部分
    }
    \end{array}
  $$

- 方法总结

  1. 整数部分转换：`除基取余法`
     - 将十进制整数部分除以`目标进制基数`，得到`商`和`余数`，余数即为目标进制中的数码。
     - 重复以上步骤直至商为`0`，得到的`余数`按`相反顺序排列`即是目标进制的整数部分。

  2. 小数部分转换：`乘基取整法`
     - 将十进制小数部分`乘以目标进制基数`，得到的`整数部分`即为目标进制中的数码。
     - 将小数部分再次乘以基数，得到的小数部分再次进行上述步骤，直至`小数部分为0`或`达到所需的精度`。

  - 举例:**十进制数 123.456 转换为二进制数：**

    1. 整数部分：除基取余法
       - 123 ÷ 2 = 61 余 1
       - 61 ÷ 2 = 30 余 1
       - 30 ÷ 2 = 15 余 0
       - 15 ÷ 2 = 7 余 1
       - 7 ÷ 2 = 3 余 1
       - 3 ÷ 2 = 1 余 1
       - 1 ÷ 2 = 0 余 1

       故整数部分为 $1111011_{(2)}$


    2. 小数部分：乘基取整法
    
       - 0.456 × 2 = 0.912，整数部分为 0
    
       - 0.912 × 2 = 1.824，整数部分为 1
    
       - 0.824 × 2 = 1.648，整数部分为 1
    
       - 0.648 × 2 = 1.296，整数部分为 1
    
       - 0.296 × 2 = 0.592，整数部分为 0
    
       - 0.592 × 2 = 1.184，整数部分为 1
    
       - 0.184 × 2 = 0.368，整数部分为 0
    
       - 0.368 × 2 = 0.736，整数部分为 0
    
       - 0.736 × 2 = 1.472，整数部分为 1
    
       - 0.472 × 2 = 0.944，整数部分为 0
    
       - 0.944 × 2 = 1.888，整数部分为 1
    
       - 0.888 × 2 = 1.776，整数部分为 1
    
       - 0.776 × 2 = 1.552，整数部分为 1
    
       - 0.552 × 2 = 1.104，整数部分为 1
    
       - 0.104 × 2 = 0.208，整数部分为 0
    
       - 0.208 × 2 = 0.416，整数部分为 0
    
       - 0.416 × 2 = 0.832，整数部分为 0
    
       - 0.832 × 2 = 1.664，整数部分为 1
    
       故小数部分为 $0.01110111001100110011_{(2)}$

  3. 将整数部分和小数部分组合起来，得到二进制表示：$1111011.01110111001100110011_{(2)}$

#### 2.1.1.6 各种进制的常见书写方式

- 二进制
  - $(1010001010010)_{\color{red}{2}} $
  - $1010001010010\color{red}B$
- 八进制
  - $(1652)_{\color{red}{8}}$
- 十六进制
  - $(1652)_{\color{red}{16}}$
  - $1652{\color{red}{H}}$
  - ${\color{red}{0\mathrm{x}}}1652$
- 十进制
  - $(1652)_{\color{red}{10}}$
  - $1652{\color{red}{D}}$​

#### 2.1.1.7 真值和机器数

- **真值**：实际的带正负号的数值（人类习惯的样子）
- **机器数**：把正负号数字化的数（存到机器里的样子）

### 2.1.2 BCD码

- **BCD码（Binary Coded Decimal）**：一种用`二进制编码`表示`十进制数字`的`编码方式`。每个十进制数字都用相应的二进制数表示，通常是`4位二进制数`，每个数位对应着十进制数字的一个数位。

- BCD码的优点之一是`直接对应于人类对十进制数字的理解`，因此在数字显示、计算和存储等领域有着广泛的应用。

#### 2.1.2.1 8421码

- **8421码**：一种常见的BCD编码方式，每个十进制数字用4位二进制数表示，权值分别为`8、4、2和1`。
- **映射关系**：

  | 十进制数字 | 8421码 |
  | ---------- | ------ |
  | 0          | `0000` |
  | 1          | `0001` |
  | 2          | `0010` |
  | 3          | `0011` |
  | 4          | `0100` |
  | 5          | `0101` |
  | 6          | `0110` |
  | 7          | `0111` |
  | 8          | `1000` |
  | 9          | `1001` |

- **合法范围**：`0000`至`1001`，即十进制数字0到9。
- **加法操作**：与十进制加法类似，若相加结果超过9，则需`+0110`进行修正(强制`向高位进1`)。

#### 2.1.2.2 余3码
- 余码BCD码，即`8421码加上0011`。
- **映射关系**：

  | 十进制数字 | 余3码     |
  | ---------- | ---------- |
  | 0          | `0011`     |
  | 1          | `0100`     |
  | 2          | `0101`     |
  | 3          | `0110`     |
  | 4          | `0111`     |
  | 5          | `1000`     |
  | 6          | `1001`    |
  | 7          | `1010`     |
  | 8          | `1011`     |
  | 9          | `1100`     |

#### 2.1.2.3 2421码

- 又称斯蒂巴尼-格雷码，每个十进制数字用4位二进制数表示，权值分别为`2、4、2和1`。
- **映射关系**：

  | 十进制数字 | 2421码 |
  | ---------- | ------ |
  | 0          | 0000   |
  | 1          | 0001   |
  | 2          | 0010   |
  | 3          | 0011   |
  | 4          | 0100   |
  | 5          | 1011   |
  | 6          | 1100   |
  | 7          | 1101   |
  | 8          | 1110   |
  | 9          | 1111   |

- 为了防止二义性，表示0 ~ 4时`最高位为0`，表示5 ~ 9时`最高位为1`

### 2.1.3 无符号整数的表示和运算

**无符号整数**，即“`自然数`”，0、1、2、3、4…

#### 2.1.3.1 无符号整数的表示

- 计算机的`机器字长n`，限制了计算机最多只能`同时进行n位运算`，也限制了其通用寄存器只能`存n位比特数据`

- 无符号整数的全部二进制位都是`数值位`，`没有符号位`，第i位的位权是$2^{i-1}$
- n bit无符号整数`表示范围`$0 \sim 2^{n-1}$，超出则`溢出`，意味着该计算机无法一次处理这么多数据
- 可以表示的最小的数：`全0`，可以表示的最大的数：`全1`.

![image-20240322212014025](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240322212014025.png)

#### 2.1.3.2 无符号整数的加法运算

- 加法运算：从最低位开始，`按位相加`，并往更高位`进位`

#### 2.1.3.3 无符号整数的减法运算

- 计算机硬件做无符号整数的减法步骤：
  - “被减数”不变，减数`全部位按位取反`、`末位+1`，`减法变加法`
  - 从最低位开始，按位相加，并往更高位进位

### 2.1.4 带符号整数的表示和运算_原反补

**带符号整数**，即“`整数`”，-2、-1、0、1、2、3、4…

#### 2.1.4.1 原码、反码、补码的表示及相互转换

##### 2.1.4.1.1 原码表示

![image-20240322213455199](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240322213455199.png)

- 符号位`“0/1”`对应`“正/负”`，剩余的`数值位`表示`真值的绝对值`，符号位和数值位之间，用`逗号“,”`隔开
- 若机器字长为n+1位，则`带符号整数的原码表示范围`：$-(2^n-1)≤x≤2^n-1$​
- 真值0的原码有两种形式：（以8位机器字长的计算机为例）
  - $[+0]_原=0,0000000$
  - $[-0]_原=1,0000000$​

##### 2.1.4.1.2 原码的缺点

![image-20240322213524956](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240322213524956.png)

- 原码的缺点：`符号位不能参与运算`，需要设计复杂的硬件电路才能处理，费钱！贵！
- 用补码表示真值——`符号位可以参与运算`
- 补码数值位不能解读为`“位权”`

##### 2.1.4.1.3 原码→反码→补码的转换（机算）

- 正数：原码=反码=补码
- 负数
  - 原码←→反码：`符号位不变，数值位取反`
  - 反码→补码：`末位+1`

##### 2.1.4.1.3 原码、补码快速转换技巧（手算）

- 正数：原码=反码=补码
- 负数：原码←→补码：`从右往左找到第一个1，这个1左边的所有“数值位”按位取反`，符号位`保持不变`

#### 2.1.4.2 补码的运算

- 补码的**加法**：从最低位开始，`按位相加（符号位参与运算）`，并往更高位`进位`
- 补码的**减法**：$[A]_补 - [B]_补 =[A]_补 + [-B]_补  $
- $[B]_补 \leftrightarrow[-B]_补$
  - 机算方法：全部位按位取反、末位+1
  - 手算方法：`从右往左找到第一个1，这个1左边的所有“数值位”按位取反`，符号位`也要取反`

- 总结：
  - 带符号数补码的加法：从最低位开始，`按位相加（符号位参与运算）`，并往更高位`进位`
  - 带符号数补码的减法：（与不带符号的整数的减法操作一样）
    - “被减数”不变，减数`全部位按位取反`、`末位+1`，`减法变加法`
    - 从最低位开始，按位相加，并往更高位进位
  - 因为补码的存在，使得计算机中，带符号与不带符号的整数运算方式得到了`统一`，从而可以用同一套电路完成运算，节省了计算机的制作成本。

### 2.1.5 原反补移码的特性对比

| n+1 bit          | 特性                                          | 合法表示范围                           | 最大的数                                                    | 最小的数                                                     | 真值0的表示                                                  |
| ---------------- | --------------------------------------------- | -------------------------------------- | ----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 真值             | 实际的带正负号的数值                          | $-2^{n+1}-1 \sim 2^{n+1}-1$            | $+111...111$                                                | $-111...111$                                                 | $\pm 00...00$                                                |
| 带符号整数：原码 | 第一个 bit 表示符号位；0 表示正数，1 表示负数 | $-(2^n-1) \leq x \leq 2^n-1$           | $\begin{array}{c} 0,111...111 = \\ 2^n-1\end{array}$        | $\begin{array}{c} 1,111...111 = \\ -(2^n-1)\end{array}$      | $\begin{array}{l}[+0]_{\text{原}}=0,000...000\\ [-0]_{\text{原}}=1,000...000\end{array}$ |
| 带符号整数：反码 | 同上                                          | $-(2^n-1) \leq x \leq 2^n-1$           | $\begin{array}{c} 0,111...111 = \\  2^n-1 \end{array}$      | $\begin{array}{c} 1,000...000 = \\ -(2^n-1)\end{array}$      | $\begin{array}{l}[+0]_{\text{反}}=0,000...000\\ [-0]_{\text{反}}=1,111...111\end{array}$ |
| 带符号整数：补码 | 同上                                          | $ {\color{red}-2^n} \leq x \leq 2^n-1$ | $\begin{array}{c} 0,111...111 = \\ 2^n-1 \end{array}$       | $\color{red}\begin{array}{c} 1,000...000 = \\ -2^n\end{array}$ | $\color{red}\begin{array}{c} [0]_{\text{补}}=0,000...000 \\真值0只有一种补码\end{array}$ |
| 带符号整数：移码 | 第一个 bit 表示符号位；1 表示正数，0 表示负数 | $ {\color{red}-2^n} \leq x \leq 2^n-1$ | $\begin{array}{c} {\bf 1},111...111 = \\ 2^n-1 \end{array}$ | $\color{red}\begin{array}{c} {\bf 0},000...000 = \\ -2^n\end{array}$ | $\color{red}\begin{array}{c} [0]_{\text{移}}={\bf 1},000...000 \\真值0只有一种移码\end{array}$ |
| 无符号整数       | 不存在符号位；所有 bit 均表示数值             | $0 \leq x \leq 2^{n+1}-1$              | $\begin{array}{c} 1111...111 = \\  2^{n+1}-1 \end{array}$   | $\begin{array}{c} 0000...000 = \\ 0\end{array}$              | $0000...000$                                                 |

- 原码和反码的合法表示范围`完全相同`，都`有两种方法表示真值0`
- 补码的合法表示范围`比原码多一个负数`，`只有一种方法表示真值0`
- 移码的合法表示范围`比原码多一个负数`，`只有一种方法表示真值0`
- 常见考点：两个数A和B进行某种运算后，是否发生溢出？
  - 解法：`手算做题,可以带入十进制,验证其是否超出合法范围`

### 2.1.6 移码

#### 2.1.6.1 定义

![image-20240322223419856](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240322223419856.png)

- 补码←→移码：`符号位取反`
- 注意：移码只能`用于表示整数`
- 移码的真值0`只有一种表示形式`

#### 2.1.6.2 练习

- 定点整数=50，用8位原码、反码、补码、移码表示。
  $$
  \begin{array}{l}
  [x]_原=0011\,0010 \qquad [x]_反=0011\,0010
  \\ [x]_补=0011\,0010\qquad [x]_移=1011\,0010
  \end{array}
  $$
  
- 定点整数=-100，用8位原码、反码、补码、移码表示。
  $$
  \begin{array}{l}
  [x]_原=1110\,0100 \qquad [x]_反=1001\,1011
  \\ [x]_补=1001\,1100\qquad [x]_移=0001\,1100
  \end{array}
  $$
  
- 求下列各种码对应的真值：
  $$
  \begin{array}{l}
  [x]_原=1000\,1101 \to x=-13 \quad\quad\quad\,\,\, [x]_原=0000\,1101 \to x=13
  \\
  [x]_反=1000\,1101 \to x=-114 \quad\quad\quad [x]_反=0000\,1101 \to x=13
  \\
  [x]_补=1000\,1101 \to x=-115 \quad\quad\quad [x]_补=0000\,1101 \to x=13
  \\
  [x]_移=1000\,1101 \to x=13 \quad\quad\quad\quad\,\, [x]_移=0000\,1101 \to x=115
  \end{array}
  $$

### 2.1.7 定点小数

$$
定点数\left\{
	\begin{array}{l}
	定点整数 \to 带符号整数
	\\
	定点小数
	\end{array}
\right.
$$

![image-20240322230245308](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240322230245308.png)

- **定点整数**
  - 默认小数点隐含在`数值部分的最后`
  - 编码表示：`原码、反码、补码、移码`
- **定点小数**
  - 默认小数点隐含在`符号位的后面`
  - 编码表示：`原码、反码、补码`

#### 2.1.7.1 定点小数的原/反/补码

- 原码：`符号位“0/1”`对应`“正/负”`，符号位与数值位之间，用`点号“.”`隔开
- 定点小数原/反/补码的转换`与带符号整数的转换完全一样`

#### 2.1.7.2 定点小数的加/减运算（与带符号整数的运算一样）

- 对两个定点小数A、B进行加法/减法时，需要先转换为补码

- 计算机硬件如何做定点小数补码的加法：从最低位开始，按位相加（符号位参与运算），并往更高位进位
- 计算机硬件如何做定点小数补码的减法：
  - “被减数”不变，“减数”全部位按位取反、末位+1，减法变加法
  - 从最低位开始，按位相加，并往更高位进位

#### 2.1.7.3 定点小数vs定点整数

| n+1 bit        | 合法表示范围                          | 最大的数                                                | 最小的数                                                     | 真值0的表示                                                  |
| -------------- | ------------------------------------- | ------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定点整数：原码 | $-(2^n-1) \leq x \leq 2^n-1$          | $\begin{array}{c} 0,111...111 = \\ 2^n-1\end{array}$    | $\begin{array}{c} 1,111...111 = \\ -(2^n-1)\end{array}$      | $\begin{array}{l}[+0]_{\text{原}}=0,000...000\\ [-0]_{\text{原}}=0,000...000\end{array}$ |
| 定点整数：反码 | $-(2^n-1) \leq x \leq 2^n-1$          | $\begin{array}{c} 0,111...111 = \\  2^n-1 \end{array}$  | $\begin{array}{c} 1,000...000 = \\ -(2^n-1)\end{array}$      | $\begin{array}{l}[+0]_{\text{反}}=0,000...000\\ [-0]_{\text{反}}=0,111...111\end{array}$ |
| 定点整数：补码 | ${\color{red}-2^n} \leq x \leq 2^n-1$ | $\begin{array}{c} 0,111...111 = \\ 2^n-1 \end{array}$   | $\color{red}\begin{array}{c} 1,000...000 = \\ -2^n\end{array}$ | $\color{red}\begin{array}{c} [0]_{\text{补}}=0,000...000 \\真值0只有一种补码\end{array}$ |
| 定点小数：原码 | $-(1-2^{-n}) \leq x \leq 1-2^{-n}$    | $\begin{array}{c} 0.111...111 = \\ 1-2^{-n}\end{array}$ | $\begin{array}{c} 1.111...111 = \\ -(1-2^{-n})\end{array}$   | $\begin{array}{l}[+0]_{\text{原}}=0.000...000\\ [-0]_{\text{原}}=0.000...000\end{array}$ |
| 定点小数：反码 | $-(1-2^{-n}) \leq x \leq 1-2^{-n}$    | $\begin{array}{c} 0.111...111 = \\ 1-2^{-n}\end{array}$ | $\begin{array}{c} 1.111...111 = \\ -(1-2^{-n})\end{array}$   | $\begin{array}{l}[+0]_{\text{反}}=0.000...000\\ [-0]_{\text{反}}=0.111...111\end{array}$ |
| 定点小数：补码 | $-1 \leq x \leq 1-2^{-n}$             | $\begin{array}{c} 0.111...111 = \\ 1-2^{-n}\end{array}$ | $\color{red}\begin{array}{c} 1.000...000 = \\ -1\end{array}$ | $\color{red}\begin{array}{c} [0]_{\text{补}}=0.000...000 \\真值0只有一种补码\end{array}$ |

- 特别注意：定点小数和定点整数的位数扩展时，它们的`拓展位置`不一样
  - **定点小数**在`数值部分的末尾（右边）`补零
    - $[x]_原=1.110 \to [x]_原=1.110\color{red}0000$
  - **定点整数**在`数值部分的前端（左边）`补零
    - $[x]_原=1,110 \to [x]_原=1,{\color{red}0000}110$

## 2.2 运算方法和运算电路

### 2.2.0 奇偶校验码

#### 2.2.0.1 校验原理

- 在数据传输中，通常会在数据中添加一些`冗余信息（例如校验位）`，以允许接收方`检测到可能发生的错误`。
- 这些校验码可以基于不同的算法，如`奇偶校验`、`循环冗余校验（CRC）`等。
- 接收方会`使用相同的算法重新计算校验码`，并将其与接收到的数据进行比较，以检测传输中是否发生了错误。

#### 2.2.0.2 奇偶校验

- 奇校验码：整个校验码（有效信息位和校验位）中`"1"的个数为奇数`
- 偶校验码：整个校验码（有效信息位和校验位）中`"1"的个数为偶数`

> 【例】:给出两个编码1001101和1010111的奇校验码和偶校验码。
>
> ​		设最高位为校验位，余7位是信息位，则对应的奇偶校验码为：
> $$
> \begin{array}{l}
> 奇校验： \underline{1}100\,1101 \qquad \underline{0}101\,0111
> \\
> 偶校验：\underline{0}100\,1101 \qquad \underline{1}101\,0111
> \end{array}
> $$

#### 2.2.0.3 偶校验的硬件实现

- 各位信息进行`异或(模2加)运算`，得到的结果即为偶校验位

- $$
  \begin{array}{l}
  0 \oplus 0 = 0 \qquad 0 \oplus 1 = 1
  \\
  1 \oplus 0 = 1 \qquad 1 \oplus 1 = 0
  \end{array}
  $$

- 以编码1001101和1010111为例

  - 求偶校验位

    - $$
      \begin{array}{l}
      1 \oplus 0 \oplus 0 \oplus 1 \oplus 1 \oplus 0 \oplus 1=0
      \\1 \oplus 0 \oplus 1 \oplus 0 \oplus 1 \oplus 1 \oplus 1=1
      \end{array}
      $$

  - 进行偶校验(所有位进行亦或，结果为1说明出错)

    - $$
      \begin{array}{l}
      0 \oplus 1 \oplus 0 \oplus 0 \oplus 1 \oplus 1 \oplus 0 \oplus 1=0
      \\
      1 \oplus 1 \oplus 0 \oplus 1 \oplus 0 \oplus 1 \oplus 1 \oplus {\color{red}0}=1\to奇数个错误情况
      \\
      1 \oplus 1 \oplus 0 \oplus 1 \oplus 0 \oplus 1 \oplus {\color{red}0} \oplus {\color{red}0}={\color{red}0}\to偶数个错误情况
      \end{array}
      $$

    - 总结：奇偶校验码只能检测到单比特错误

### 2.2.1 电路的基本原理、加法器设计

#### 2.2.1.1 算术逻辑单元(ALU)

- ALU的功能

  - 算术运算：加、减、乘、除等

  - 逻辑运算：与、或、非、异或等

  - 辅助功能：移位、求补等

- ALU的图示

  - ![image-20240322234722944](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240322234722944.png)
  - ![image-20240322234757064](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240322234757064.png)
    - 右边的$S_3 \sim M$​引脚，负责`接收来自控制单元(CU)的控制信号`
      - 其中，M指明`ALU当前的工作模式（逻辑运算或算术运算）`，$S_3 \sim S_0$​是`当前要执行的具体运算`
    - 下方的$A_i$和$B_i$引脚用来`输入信号（操作数）`，上方的$F_i$引脚用来`输出信号（运算结果）`，同时，$A_i，B_i$和$F_i$的个数就是其`机器字长`
    - 其余的引脚是为了和`其他的芯片串联`而设计的，此处不深究。

#### 2.2.1.2 最基本的逻辑运算

##### 2.2.1.2.1 逻辑运算表达式

| 逻辑运算 | 符号 | 算术表达式                  | C++表达式             | 含义                                             |
| -------- | ---- | --------------------------- | --------------------- | ------------------------------------------------ |
| 与       | AND  | $Y = A \cdot B$             | A && B                | A 和 B 同时为真时，结果为真                      |
| 或       | OR   | $Y = A + B$                 | A \|\| B              | A 和 B 中至少一个为真时，结果为真                |
| 非       | NOT  | $Y = \overline{A}$          | !A                    | A 为假时，结果为真，A 为真时，结果为假           |
| 与非     | NAND | $Y = \overline{A \cdot B}$  | !(A && B) 或 !(A & B) | A 和 B 都为真时，结果为假                        |
| 或非     | NOR  | $Y = \overline{A + B}$      | !(A \|\| B)           | A 和 B 都为假时，结果为真                        |
| 亦或     | XOR  | $Y = A \oplus B$            | A ^ B                 | A 和 B 仅一个为真时，结果为真                    |
| 同或     | XNOR | $Y = \overline{A \oplus B}$ | !(A ^ B)              | A 和 B 相同时，结果为真；A 和 B 不同时，结果为假 |

- 在逻辑运算中，与（AND）、或（OR）、非（NOT）运算符有不同的优先级、结合律和分配律。

  - **优先级：**
    - 非（NOT）运算符的优先级最高。
    
    - 与（AND）运算符的优先级高于或（OR）运算符。
    
  - **结合律：**
  
    - 与（AND）运算符和或（OR）运算符都是左结合的，即连续使用时，先进行左侧的运算。
  
  - **分配律：**
  
    - 对于与（AND）和或（OR）运算符，它们分别满足分配律。
      - 对于与（AND）运算符：$A (B + C) = AB +AC$
      - 对于或（OR）运算符：$A +BC = (A+B) \cdot (A +C)$
  
- 这些性质在逻辑运算中非常重要，它们决定了表达式的计算顺序和结果。

##### 2.2.1.2.2 逻辑运算的真值表

- **与运算（AND）：**

	- | A    | B    | A && B |
| ---- | ---- | ------ |
| 0    | 0    | 0      |
| 0    | 1    | 0      |
| 1    | 0    | 0      |
| 1    | 1    | 1      |

- **或运算（OR）：**

	- | A    | B    | A \|\| B |
| ---- | ---- | -------- |
| 0    | 0    | 0        |
| 0    | 1    | 1        |
| 1    | 0    | 1        |
| 1    | 1    | 1        |

- **非运算（NOT）：**

	- | A    | !A   |
| ---- | ---- |
| 0    | 1    |
| 1    | 0    |

- **与非运算（NAND）：**

	- | A    | B    | !(A && B) |
| ---- | ---- | --------- |
| 0    | 0    | 1         |
| 0    | 1    | 1         |
| 1    | 0    | 1         |
| 1    | 1    | 0         |

- **或非运算（NOR）：**

	- | A    | B    | !(A \|\| B) |
| ---- | ---- | ----------- |
| 0    | 0    | 1           |
| 0    | 1    | 0           |
| 1    | 0    | 0           |
| 1    | 1    | 0           |

- **亦或运算（XOR）：**

	- | A    | B    | A ^ B |
| ---- | ---- | ----- |
| 0    | 0    | 0     |
| 0    | 1    | 1     |
| 1    | 0    | 1     |
| 1    | 1    | 0     |

- **同或运算（XNOR）：**

  - | A    | B    | A XNOR B |
  | ---- | ---- | -------- |
  | 0    | 0    | 1        |
  | 0    | 1    | 0        |
  | 1    | 0    | 0        |
  | 1    | 1    | 1        |

- 这些真值表显示了在不同输入情况下各逻辑运算的输出结果。

##### 2.2.1.2.3 各逻辑运算的门电路

![image-20240323000213495](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240323000213495.png)

![image-20240323001731648](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240323001731648.png)

![image-20240323002126343](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240323002126343.png)

- 门电路的输入/输出信号，就是`高/低电平信号（5V/1V）`

#### 2.2.1.3 用门电路求偶校验位

- 逻辑表达式是`对电路的数学化描述`
- 求奇偶校验1⊕0⊕0⊕1⊕1⊕0⊕1=0
  - 表达式1：(1⊕0)⊕(0⊕1)⊕(1⊕0)⊕1)=0
    - ![image-20240323002625643](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240323002625643.png)
  - 表达式2：求奇偶校验((((((1⊕0)⊕0)⊕1)⊕1)⊕0)⊕1)=0
    - ![image-20240323002717202](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240323002717202.png)

#### 2.2.1.4 一位全加器(FA,full adder)

##### 2.2.1.4.1 推导过程

- 从算术运算推演到逻辑运算

  - > $$
    > \begin{array}{l}
    > 二进制的加法运算和亦或逻辑运算如下
    > \\
    > 加法运算 \qquad\qquad\qquad\qquad 异或运算
    > \\
    > 0 + 0 = 0 \qquad\qquad\qquad\qquad 0 \oplus 0=0
    > \\
    > 0 + 1 = 1 \qquad\qquad\qquad\qquad 0 \oplus 1=1
    > \\
    > 1 + 0 = 1 \qquad\qquad\qquad\qquad 1 \oplus 0=1
    > \\
    > 1+ 1 = 0 \qquad\qquad\qquad\qquad 1 \oplus 1=0
    > \\
    > （进位1）
    > \\
    > 总结:二进制的{\color{red}加法算术运算}可以映射成{\color{red}亦或逻辑运算}
    > \end{array}
    > $$

- ![image-20240323005534588](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240323005534588.png)

- 规定：
  - 有A和B两个进行相加的二进制数，$A_i和B_i$分别是`A，B中的第i位的比特值`，称之为`本位`
  - 有$C_{i-1}$为`来自低位的进位`，$S_i$​为`本位的和`
  - $A_i和B_i$相加时，会产生`本位的和`$S_i$，同时产生`本位向高位进位的值`$C_i$

- **本位和**
  
  - $S_i=A_i \oplus  B_i \oplus  C_{i-1}$（输入中有奇数个1时为1（异或））
- **本位向高位的进位**
  
  - $C_i=A_iB_i+(A_i \oplus  B_i)C_{i-1}$
  - 当$C_i$为1时，必然发生以下的某一种情况
    - $A_iB_i$`两个本位都为1`的情况
    - $(A_i \oplus  B_i)C_{i-1}$`两个本位中有一个1，且来自低位的进位是1`的情况

##### 2.2.1.4.2 电路设计

![image-20240323003223856](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240323003223856.png)

![image-20240323003313364](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240323003313364.png)

#### 2.2.1.5 串行加法器

![image-20240323003459190](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240323003459190.png)

- **串行加法器**：只有`一个全加器`，数据`逐位串行`送入加法器中进行运算。`进位触发器`用来`寄存进位信号`，以便参与下一次运算。
- 如果操作数长n位，加法就要`分n次进行`，每次产生`一位和`，并且`串行逐位`地送回寄存器。

#### 2.2.1.6 并行加法器

![image-20240323003743332](./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.assets/image-20240323003743332.png)

- **串行进位的并行加法器**：把`n个`全加器`串接起来`，就可进行`两个n位数的相加`。
- 串行进位又称为`行波进位`，每一级进位直接`依赖于前一级的进位`，即进位信号是`逐级形成`的。

### 2.2.2 并行进位加法器

### 2.2.3 补码加减运算器

### 2.2.4 加减运算和溢出判断

### 2.2.5 标志位的生成

### 2.2.6 定点数的移位运算

### 2.2.7 原码的乘法运算

### 2.2.8 补码的乘法运算

### 2.2.9 原码的除法运算

### 2.2.10 补码的除法运算

### 2.2.11 C语言类型转换

### 2.2.12 数据的存储和排列

## 2.3 浮点数的表示与运算

### 2.3.1 浮点数的表示

### 2.3.2 IEEE754

### 2.3.3 浮点数的运算

