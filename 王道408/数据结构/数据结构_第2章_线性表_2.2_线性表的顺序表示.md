<center style="font-family: 华文新魏"><font size="12px" color="#4870ac">王道408 数据结构</font></center>

[toc]

# 第2章 线性表

## 2.2 线性表的顺序表示

### 2.2.1 顺序表的定义

- 顺序表：用`顺序存储`的方式实现的`线性表`

- 顺序存储：把`逻辑上相邻的元素`存储在`物理位置上也相邻`的`存储单元`中，元素之间的关系由`存储单元的邻接关系`来体现。

- 设线性表第一个元素的存放位置是$LOC(L)$（LOC是location的缩写），则第i位元素的地址为：
  $$
  LOC(i) = LOC(L) + i \times 数据元素的大小
  $$

- c语言通过`sizeof(ElemType)`函数知道一个数据元素的大小，其中，ElemType就是顺序表中存放的数据元素类型

### 2.2.2 顺序表的实现方式

$$
顺序表
\left\{
	\begin{array}{l}
	实现方式
	\left\{
        \begin{array}{l}
        静态分配 \to 使用“静态数组”实现,大小一旦确定就无法改变
        \\
        动态分配 \to 使用“动态数组”实现
        \left\{
            \begin{array}{l}
            顺序表存满时，可再用malloc函数或new关键字动态拓展顺序表的最大容量
            \\
            需要将数据元素复制到新的存储区域，并用free函数或delete关键字释放原区域
            \end{array}
        \right.
        \end{array}
	\right.
	\\
	特点
	\left\{
        \begin{array}{l}
        随机访问\to能在O(1)时间内找到第i个元素
        \\
        存储密度高
        \\
        拓展容量不方便
        \\
        插入、删除数据元素不方便
        \end{array}
	\right.
	\end{array}
\right.
$$

- 顺序表的`静态分配`和`动态分配`是两种不同的`内存管理方式`。

- **静态分配**：
  - **定义：**
    在静态分配中，数组的大小在`编译`时确定，程序在`运行前`就会为数组分配`固定大小的内存空间`。

  - **优点：**
    1. `速度较快`：数组的大小是`确定`的，不需要额外的`内存分配操作`，因此访问元素的速度较快。
    2. `简单`：不需要额外的内存管理操作，代码相对`简单`。
  - **缺点：**
    1. `内存浪费`：数组的大小是固定的，可能会浪费内存空间。
    2. `大小固定`：数组的大小在编译时确定，无法根据实际需要动态调整大小。

- **动态分配**：

  - **定义：**
    在动态分配中，数组的大小是在`运行`时`动态分配`的，程序可以根据需要`动态申请和释放内存空间`。

  - **优点：**
    1. `内存利用率高`：可以根据实际需要动态调整数组的大小，节省内存空间。
    2. `灵活性高`：数组大小可动态调整，适应性强。
  - **缺点：**
    1. `复杂性`：需要额外的内存管理操作，可能增加程序的复杂性。
    2. `内存碎片化`：频繁分配和释放内存可能会导致内存碎片问题。

### 2.2.3 静态顺序表的代码实现（以C语言为例）

#### 2.2.3.1 数据元素的代码描述

顺序表的特点是表中元素的`逻辑顺序`与其`物理顺序`相同，线性表中的任一数据元素都可以`随机存取`，所以线性表的顺序存储结构是一种`随机存取的存储结构`。通常用高级程序设计语言中的`数组`来描述线性表的顺序存储结构。

假定线性表的元素类型为ElemType，则线性表的顺序存储类型描述如下：

```c
// ====================数据类型别名========================
// 别名的好处是可以简化代码，提高代码的可读性
typedef int Elemtype;/// 静态顺序表的数据类型，此处为整型

// ====================全局变/常量========================
// 在静态顺序表中，其容量会在代码编译时即确定，代码运行时不可更改
#define MAX_SIZE 15	/// 静态顺序表的最大长度，用来规定顺序表的最大容量

// ====================结构体定义====================
/// 静态顺序表的结构体
typedef struct SqList
{
	Elemtype m_data[MAX_SIZE];/// 静态顺序表的数据域
	int m_length;/// 静态顺序表的长度
}SqList;/// 静态顺序表的别名
```

#### 2.2.3.2 静态顺序表的初始化

- 函数名：`bool initList(SqList* L)`

- 函数功能：
  - 本函数用于`初始化一个静态顺序表`，将其长度`置为0`。
- 函数思路：
  1. 判断参数是否合法，如果顺序表的指针`无效（即为NULL）`，则初始化失败
  2. 将静态顺序表的长度`置为0`。

- 注意：
  1. 因为要修改静态顺序表的数据，所以此处传入的是一个`指向静态顺序表的指针`，这样在函数内部修改静态顺序表的数据才会`影响到外部`。
  2. 静态顺序表的初始化操作的时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  3. 因为静态顺序表的存储空间是在`栈`上分配的，所以无需考虑`内存的释放问题`，当静态顺序表`所在的函数或者代码块`执行完毕后，静态顺序表的存储空间会`自动释放`。

```c
/**
* @brief 初始化静态顺序表
* @param L 待初始化的静态顺序表
* @return 初始化成功返回true，否则返回false
*/
bool initList(SqList* L)
{
	printf("[INFO] initList() is called!\n");
	// 判断参数是否合法
	if (NULL == L)
	{
		printf("[ERROR] initList() 参数错误,L为空，初始化失败！\n");
		return false;
	}
	// 初始化长度
	L->m_length = 0;
	printf("[INFO] 静态顺序表初始化成功！\n");
	return true;
}

```

#### 2.2.3.3 静态顺序的输出

- 函数名：`bool printList(const SqList* L)`

- 函数功能：
  - 本函数用于`输出静态顺序表的元素`。
- 函数思路：
  1. 判断`参数是否合法`，如果静态顺序表的指针`有效(即L不为NULL)`，则输出失败。
  2. 如果静态顺序表`为空`，则`无需输出`，直接`返回true`。
  3. 如果静态顺序表`不为空`，则`依次输出静态顺序表的元素`。
- 注意：
  1. 输出操作本身`不需要修改`静态顺序表的数据，所以传入的是一个`指向静态顺序表的常量指针（const SqList *）`，传入`指针`是为了`减少内存开销`，传入`常量`是为了`防止在不需要修改的情况下修改了数据`。
  2. 输出操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  3. 静态顺序表的位序是`从1开始`的，而数组的下标是`从0开始`的，不要混淆

```c
/**
* @brief 输出静态顺序表
* @param L 待输出的静态顺序表
* @return 输出成功返回true，否则返回false
*/
bool printList(const SqList* L)
{
	printf("[INFO] printList() is called!\n");
	if(NULL == L)
	{
		printf("[ERROR] printList() 参数错误,L为空，输出失败！\n");
		return false;
	}
	if(L->m_length == 0)
	{
		printf("[INFO] 静态顺序表为空，无需输出！\n");
		return true;
	}
	printf("[INFO] 静态顺序表的元素为：");
	for(int i = 0; i < L->m_length; i++)
	{
		printf("%d, ", L->m_data[i]);
	}
	printf("end\n");
	return true;
}
```

#### 2.2.3.4 静态顺序的表长

- 函数名称：`int length(const SqList* L)`
- 函数功能：
  -  本函数用于`获取静态顺序表的长度`。
- 函数思路：
  1. 判断参数是否合法，如果静态顺序表的指针`有效(即L不为NULL)`，则获取长度失败，返回`-1`。
  2. 合法性判断通过后，直接返回`静态顺序表的长度`。
- 注意：
  1. 获取长度操作本身`不需要修改`静态顺序表的数据，所以传入的是`一个指向静态顺序表的常量指针（const SqList *）`，传入指针是为了`减少内存开销`，传入常量是为了`防止在不需要修改的情况下修改了数据`。
  2. 获取长度操作的时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  3. 静态顺序表的长度是指`静态顺序表中元素的个数`，而不是静态顺序表的容量。
  4. 静态顺序表的位序是`从1开始`的，而数组的下标是`从0开始`的，不要混淆。

```c
/**
* @brief 输出静态顺序表的长度
* @param L 待输出的静态顺序表
* @return 返回静态顺序表的长度
*/
int length(const SqList* L)
{
	printf("[INFO] length() is called!\n");
	if(NULL == L)
	{
		printf("[ERROR] length() 参数错误,L为空，获取长度失败！\n");
		return -1;
	}
	return L->m_length;
}
```

#### 2.2.3.5 静态顺序表的判空

- 函数名：`bool isEmpty(const SqList *L)`
- 函数功能：
  - 本函数用于`判断静态顺序表是否为空`，如果静态顺序表为空，则返回`true`，否则返回`false`。
- 思路：
  1. 判断参数是否合法，如果静态顺序表的指针`有效(即L不为NULL)`，则`判空失败`，返回`false`。
  2. 如果静态顺序表的长度`为0`，则静态顺序表`为空`，返回`true`，否则返回`false`。
- 注意：
  1. 判空操作本身`不需要修改`静态顺序表的数据，所以传入的是一个`指向静态顺序表的常量指针（const SqList *）`，传入指针是为了`减少内存开销`，传入常量是为了`防止在不需要修改的情况下修改了数据`。
  2. 判空操作的时间复杂度为`O(1)`，空间复杂度为`O(1)`。

```c
/**
* @brief 静态顺序表判空操作
* @param L 待判断的静态顺序表
* @return 静态顺序表为空返回true，否则返回false
*/
bool isEmpty(const SqList *L)
{
	printf("[INFO] isEmpty() is called!\n");
	if(NULL == L)
	{
		printf("[ERROR] isEmpty() 参数错误,L为空，判空失败！\n");
		return false;
	}
	return L->m_length == 0;
}
```

#### 2.2.3.6 静态顺序表的按位查找算法

- 函数名：`bool getElem(const SqList* L, int i, Elemtype* e)`
- 函数功能：
  - 本函数用于`查找静态顺序表中第i个位置的元素`，并`将其存储到e中`。
- 思路：
  1. 判断参数是否合法，包括静态顺序表的指针是否`有效（即L不为NULL）`，顺序表是否`为空`，查找位置是否`合法`，只要有一个条件不满足，则`查找失败`。
  2. 查找元素，将`第i个位置`的元素（即`数组下标为i-1`的元素）存储到`e`中。
- 注意：
  - 查找操作本身`不需要修改`静态顺序表的数据，所以传入的是一个`指向静态顺序表的常量指针（const SqList *）`，传入指针是为了`减少内存开销`，传入常量是为了`防止在不需要修改的情况下修改了数据`。
  - 顺序表的查找操作的时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  - 参数i指的是`元素的位序`，`从1开始`，而数组下标是`从0开始`的，不要混淆

```c
/**
* @brief 静态顺序表的按位查找
* @param L 待查找的静态顺序表
* @param i 待查找的位置
* @param e 查找到的元素
* @return 查找成功返回true，否则返回false
*/
bool getElem(const SqList* L, int i, Elemtype* e)
{
	printf("[INFO] getElem() is called：尝试查找第%d位的元素\n", i);
	// 判断参数是否合法
	if(NULL == L)
	{
		printf("[ERROR] getElem() 参数错误,L为空，查找失败！\n");
		return false;
	}
	// 判断查找位置是否合法，该判断中已经隐含了静态顺序表是否为空的判断
	if(i < 1 || i > L->m_length)
	{
		printf("[ERROR] getElem() 参数错误,查找位置不合法，查找失败！\n");
		return false;
	}
	// 查找元素
	*e = L->m_data[i - 1];
	return true;
}
```

#### 2.2.3.7 静态顺序表的按值查找算法

- 函数名：`bool locateElem(const SqList* L, Elemtype e, int* i)`
- 函数功能：
  - 本函数用于`查找静态顺序表中元素值为e的元素`，并`将其位置存储到参数i中`。
- 思路：
  1. 判断参数是否合法，包括静态顺序表指针是否`有效（即L不为NULL）`，顺序表是否`不为空`，只要有一个合法条件不满足，则查找失败。
  2. 查找元素，从第一个元素`开始遍历`，查找`值为e的元素`，如果找到，则`将其位置存储到i中`，返回`true`，否则返回`false`。
- 注意：
  1. 查找操作本身`不需要修改`静态顺序表的数据，所以传入的是一个`指向静态顺序表的常量指针（const SqList *）`，传入指针是为了`减少内存开销`，传入常量是为了`防止在不需要修改的情况下修改了数据`。
  2. 最基础的按值查找有其`局限性`，即`只能找到第一个符合条件的元素`，如果有多个符合条件的元素，只会返回第一个符合的元素的位序。
  3. 查找操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  4. 顺序表的位序是`从1开始`的，而数组的下标是`从0开始`的，不要混淆

```c
/**
* @brief 静态顺序表的按值查找
* @param L 待查找的静态顺序表
* @param e 待查找的元素
* @param i 查找到的位置
* @return 查找成功返回true，否则返回false
*/
bool locateElem(const SqList* L, Elemtype e, int* i)
{
	printf("[INFO] locateElem() is called：尝试查找元素值为%d的元素\n", e);
	// 判断参数是否合法
	if(NULL == L)
	{
		printf("[ERROR] locateElem() 参数错误,L为空，查找失败！\n");
		return false;
	}
	// 查找元素，for循环中已经隐含了静态顺序表是否为空的判断，即L->m_length == 0时，不会进入for循环
	for(*i = 0; *i < L->m_length; (*i)++)
	{
		if(L->m_data[*i] == e)
		{
			(*i)++; // 位序从1开始
			return true;
		}
	}
	printf("[ERROR] 未找到值为%d的元素！\n", e);
	return false;
}
```

#### 2.2.3.8 静态顺序表的按位插入算法

- 函数名：`bool insertList(SqList* L, int i, Elemtype e)`
- 函数功能：
  - 本函数用于`在静态顺序表的第i个位置插入元素e`，如果`插入位置不合法`或者`静态顺序表已满`，则插入失败。
- 思路：
  1. 判断参数是否合法，包括静态顺序表是否`有效（即L不为NULL）`，插入位置是否`合法`，静态顺序表是否`未满`，只要有一个条件不满足，则插入失败。
  2. `将第i个元素及之后的元素依次后移`，为新元素腾出位置。
  3. 将新元素`插入到第i个位置`。
  4. 静态顺序表的`长度加1`。
- 注意：
  1. 在顺序表中，位序i`从1开始`，而数组下标`从0开始`，不要混淆。
  2. 因为需要修改静态顺序表的数据，所以此处顺序表传入的是`指针`，这样在函数内部修改静态顺序表的数据会影响到外部。
  3. 插入操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  4. 在移动元素的for循环中，j的本质是`数组下标`，当需要用j表示元素位序时，应该`+1`，所以根据“将第i个元素及之后的元素后移”这句话，位序j+1的范围为`[i,m_length]`，所以数组下标j的范围为`[i-1,m_length-1]`。

```c
/**
* @brief 静态顺序表的按位插入
* @param L 待插入的静态顺序表
* @param i 待插入的位置
* @param e 待插入的元素
* @return 插入成功返回true，否则返回false		   
*/
bool insertList(SqList* L, int i, Elemtype e)
{
	printf("[INFO] insertList() is called：尝试在第%d位插入新元素%d\n", i, e);
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表是否为空
	{
		printf("[ERROR] insertList() 参数错误,L为空，插入失败！\n");
		return false;
	}
	if (i < 0 || i > L->m_length + 1) // 判断插入位置是否合法
	{
		printf("[ERROR] insertList() 参数错误,插入位置不合法，插入失败！\n");
		return false;
	}
	if (L->m_length >= MAX_SIZE) // 判断静态顺序表是否已满
	{
		printf("[ERROR] insertList() 参数错误,静态顺序表已满，插入失败！\n");
		return false;
	}
	// 插入元素
	for(int j = L->m_length-1; j > i; j--) // 将第i个元素及之后的元素后移
	{
		L->m_data[j+1] = L->m_data[j];
	}
	L->m_data[i-1] = e; // 插入新元素
	L->m_length++;	// 表长加一
	printf("[INFO] 静态顺序表插入元素成功！\n");
	return true;
}
```

#### 2.2.3.9 静态顺序表的按位删除算法

- 函数名：`bool deleteList(SqList* L, int i, Elemtype* e)`
- 函数功能：
  - 本函数用于`删除静态顺序表中第i个位置的元素`，并`将被删除元素存储到e中`。
- 思路：
  1. 判断参数是否合法，包括静态顺序表是否`有效（即L不为NULL）`，静态顺序表是否`不为空`，删除位置是否`合法`，只要有一个条件不满足，则删除失败。
  2. 若通过合法性检查，则`将待删除元素存储到e中`。
  3. 将第`i`个元素之后的元素`依次前移一位`。
  4. 静态顺序表的`表长减一`。
- 注意：
  1. 在顺序表中，位序i`从1开始`，而数组下标`从0开始`，不要混淆。
  2. 因为需要修改静态顺序表的数据，所以此处顺序表传入的是`指针`，这样在函数内部修改静态顺序表的数据会`影响到外部`。
  3. 在for循环中，j的本质是`数组下标`，当用j来表示元素位序时，应该`+1`，所以根据“将第i个元素之后的元素依次前移一位”这句话，位序j+1的范围为`[i+1,m_length]`,因此，数组下标j的范围为`[i,m_length-1]`。
  4. 删除操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。

```c
/**
 * @brief 静态顺序表的删除操作
 * @param L 待删除的静态顺序表
 * @param i 待删除的位置
 * @param e 删除的元素
 * @return 删除成功返回true，否则返回false
 */
bool deleteList(SqList* L, int i, Elemtype* e)
{
	printf("[INFO] deleteList() is called：尝试删除第%d位的元素\n", i);
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表是否为空
	{
		printf("[ERROR] deleteList() 参数错误,L为空，删除失败！\n");
		return false;
	}
	if (i < 1 || i > L->m_length) // 判断删除位置是否合法
	{
		printf("[ERROR] deleteList() 参数错误,删除位置不合法，删除失败！\n");
		return false;
	}
	// 删除元素
	*e = L->m_data[i - 1]; // 保存删除的元素
	for(int j = i; j <= L->m_length - 1; j++) // 将第i个元素之后的元素前移
	{
		L->m_data[j - 1] = L->m_data[j];
	}

	L->m_length--; // 表长减一
	printf("[INFO] 静态顺序表删除元素成功！\n");
	return true;
}
```

#### 2.2.3.10 静态顺序表的销毁算法

- 函数名：`bool destoryList(SqList *L)`
- 函数功能：
  - 本函数用于`销毁一个静态顺序表`，因为静态顺序表的特殊性，此函数和`清空顺序表`的功能相同。
- 思路：
  1. 判断参数是否合法，如果静态顺序表的指针`无效（即为NULL）`，则销毁失败。
  2. 因为静态顺序表的存储空间是`在栈上分配`的，所以`不需要手动释放内存`，只需要将静态顺序表的`长度置为0`，以此表示静态顺序中已经没有元素即可。
- 注意：
  1. 因为要修改静态顺序表的数据，所以此处传入的是一个指向静态顺序表的`指针`，这样在函数内部修改静态顺序表的数据会`影响到外部`。

```c
/**
 * @brief 销毁静态顺序表
 * @param L 待销毁的静态顺序表
 * @return 销毁成功返回true，否则返回false
 */
bool destoryList(SqList *L)
{
	printf("[INFO] destoryList() is called!\n");
	// 判断参数是否合法
	if (NULL == L)
	{
		printf("[ERROR] destoryList() 参数错误,L为空，销毁失败！\n");
		return false;
	}
	// 销毁静态顺序表
	L->m_length = 0;
	printf("[INFO] 静态顺序表销毁成功！\n");
	return true;
}
```

#### 2.2.3.11 扩展1：静态顺序表的头插法

- 函数名：`bool push_front(SqList* L, Elemtype e)`
- 函数功能：
  - 本函数用于`在静态顺序表的表头插入元素e`，如果静态顺序表`已满`，则插入失败。
- 思路：
  1. 判断顺序表的指针是否`有效（即L不为NULL）`，如果无效，则插入失败。
  2. 判断静态顺序表是否`已满`，如果已满，则插入失败。
  3. 如果通过了安全性检查，将静态顺序表中的元素`依次后移`，为新元素腾出位置。
  4. 将新元素插入到`第1个位置`。
  5. 静态顺序表的长度`加1`。
- 注意：
  1. 头插操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  2. 头插操作是在静态顺序表的`表头`插入元素，所以插入后，原来的第1个元素变成了第2个元素，原来的第2个元素变成了第3个元素，以此类推。
  3. 静态顺序表的位序是`从1开始`的，而数组的下标是`从0开始`的，不要混淆。
  4. 因为需要修改静态顺序表的数据，所以此处传入的是一个指向静态顺序表的`指针`，这样在`函数内部`修改静态顺序表的数据会`影响到函数外部`。
  5. 在for循环中，j的本质是`数组下标`，当需要用j表示元素位序时，应该`+1`，所以根据“将第i个元素及之后的元素后移”这句话，位序j+1的范围为`[i,m_length]`,所以数组下标j的范围为`[i-1,m_length-1]`，这里i=1，所以数组下标j的范围为`[0,m_length-1`]。
  6. 在实际的开发中，头插法其实可以直接`调用insertList()函数`，将i设置为`1`即可，这里只是为了演示头插法的实现而特意写出算法的实现过程。

```c
/**
* @brief 静态顺序表的头插
* @param L 待插入的静态顺序表
* @param e 待插入的元素
* @return 插入成功返回true，否则返回false
*/
bool push_front(SqList* L, Elemtype e)
{
	printf("[INFO] push_back() is called：尝试在表头插入新元素%d\n", e);
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表指针是否有效
	{
		printf("[ERROR] push_back() 参数错误,L为空，插入失败！\n");
		return false;
	}
	if (L->m_length >= MAX_SIZE) // 判断静态顺序表是否已满
	{
		printf("[ERROR] push_back() 参数错误,静态顺序表已满，插入失败！\n");
		return false;
	}
	// 插入元素
	for(int j = L->m_length-1; j >= 0; j--) // 将第i个元素及之后的元素后移
	{
		L->m_data[j+1] = L->m_data[j];
	}
	L->m_data[0] = e; // 插入新元素
	L->m_length++;	// 表长加一
	printf("[INFO] 静态顺序表表头插入元素成功！\n");
	return true;
}
```

#### 2.2.3.12 扩展2：静态顺序表的尾插法

- 函数名：`bool push_back(SqList* L, Elemtype e)`
- 函数功能：
  - 本函数用于`在静态顺序表的表尾插入元素e`，如果静态顺序表`已满`，则插入失败。
- 思路：
  1. 判断顺序表的指针是否有效，如果`无效（即L为NULL）`，则插入失败。
  2. 判断静态顺序表是否已满，如果`已满`，则插入失败。
  3. 将新元素插入到第`m_length+1`个位置（即数组的第`m_length`个位置）。
  4. 静态顺序表的长度`加1`。
- 注意：
  1. 尾插操作的时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  2. 尾插操作是在静态顺序表的表尾插入元素，因为顺序表支持`随机访问`，所以`直接在表尾插入元素即可`。
  3. 静态顺序表的位序是`从1开始`的，而数组的下标是`从0开始`的，不要混淆。
  4. 因为需要修改静态顺序表的数据，所以此处传入的是一个指向静态顺序表的`指针`，这样在`函数内部`修改静态顺序表的数据会`影响到外部`。
  5. 在实际的开发中，尾插法其实可以直接调用`insertList()`函数，将i设置为`m_length+1`即可，这里只是为了演示尾插法的实现而特意写出算法的实现过程。

```c
/**
* @brief 静态顺序表的尾插
* @param L 待插入的静态顺序表
* @param e 待插入的元素
* @return 插入成功返回true，否则返回false
*/

bool push_back(SqList* L, Elemtype e)
{
	printf("[INFO] push_back() is called：尝试在表尾插入新元素%d\n", e);
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表指针是否有效
	{
		printf("[ERROR] push_back() 参数错误,L为空，插入失败！\n");
		return false;
	}
	if (L->m_length >= MAX_SIZE) // 判断静态顺序表是否已满
	{
		printf("[ERROR] push_back() 参数错误,静态顺序表已满，插入失败！\n");
		return false;
	}
	// 插入元素
	L->m_data[L->m_length] = e; // 插入新元素
	L->m_length++;	// 表长加一
	printf("[INFO] 静态顺序表表尾插入元素成功！\n");
	return true;
}
```

#### 2.2.3.13 扩展3：静态顺序表的头删法

- 函数名：`bool pop_front(SqList* L, Elemtype* e)`
- 函数功能：
  - 本函数用于`删除静态顺序表的表头元素`。
- 函数思路：
  1. 判断参数是否合法，如果静态顺序表的指针`无效（即L为NULL）`，则删除失败。
  2. 判断静态顺序表是否为空，如果`为空`，则删除失败。
  3. 通过合法性测试后，`将静态顺序表中的元素依次前移`，覆盖掉第1个元素。
  4. 静态顺序表的`长度减1`。
- 注意：
  1. 头删操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  2. 头删操作是删除静态顺序表的`表头元素`，删除后，原来的第2个元素变成了第1个元素，原来的第3个元素变成了第2个元素，以此类推。
  3. 静态顺序表的位序是`从1开始`的，而数组的下标是`从0开始`的，不要混淆。
  4. 因为需要修改静态顺序表的数据，所以此处传入的是一个指向静态顺序表的`指针`，这样在`函数内部`修改静态顺序表的数据会`影响到外部`。
  5. 在for循环中，j的本质是`数组下标`，当需要用j表示元素位序时，应该`+1`，所以根据“将第i个元素之后的元素前移”这句话，位序j+1的范围为`[i+1,m_length]`，所以数组下标j的范围为`[i,m_length-1]`，这里i=1，所以数组下标j的范围为`[1,m_length-1]`。

```c
/**
* @brief 静态顺序表的头删操作
* @param L 待删除的静态顺序表
* @param e 被删除的元素
* @return 删除成功返回true，否则返回false 			   
*/
bool pop_front(SqList* L, Elemtype* e)
{
	printf("[INFO] pop_front() is called：尝试删除表头元素\n");
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表是否为空
	{
		printf("[ERROR] pop_front() 参数错误,L为空，删除失败！\n");
		return false;
	}
	if (L->m_length == 0) // 判断静态顺序表是否为空
	{
		printf("[ERROR] pop_front() 参数错误,静态顺序表为空，删除失败！\n");
		return false;
	}
	// 删除元素
	*e = L->m_data[0]; // 保存被删除的元素
	for(int j = 1; j <= L->m_length-1; j++) // 将第i个元素之后的元素前移
	{
		L->m_data[j-1] = L->m_data[j];
	}
	L->m_length--;	// 表长减一
	printf("[INFO] 静态顺序表表头删除元素成功！\n");
	return true;
}
```

#### 2.2.3.14 扩展4：静态顺序表的尾删法

- 函数名：`bool pop_back(SqList* L, Elemtype* e)`
- 函数功能：
  - 本函数用于`删除静态顺序表的表尾元素`。

- 思路：
  1. 判断参数是否合法，如果静态顺序表的指针`无效（即L为NULL）`，则删除失败。
  2. 判断静态顺序表是否为空，如果`为空`，则删除失败。
  3. 通过合法性测试后，直接`返回静态顺序表的最后一个元素`，`静态顺序表的长度减1`即可。
- 注意：
  1. 尾删操作的时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  2. 尾删操作是删除静态顺序表的`表尾元素`，因为顺序表支持`随机访问`，所以直接删除表尾元素即可。
  3. 静态顺序表的位序是`从1开始`的，而数组的下标是`从0开始`的，不要混淆。
  4. 因为需要修改静态顺序表的数据，所以此处传入的是`一个指向静态顺序表的指针`，这样在`函数内部`修改静态顺序表的数据会`影响到外部`。

```c
/**
* @brief 静态顺序表的尾删操作
* @param L 待删除的静态顺序表
* @param e 被删除的元素
* @return 删除成功返回true，否则返回false
*/
bool pop_back(SqList* L, Elemtype* e)
{
	printf("[INFO] pop_back() is called：尝试删除表尾元素\n");
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表是否为空
	{
		printf("[ERROR] pop_back() 参数错误,L为空，删除失败！\n");
		return false;
	}
	if (L->m_length == 0) // 判断静态顺序表是否为空
	{
		printf("[ERROR] pop_back() 参数错误,静态顺序表为空，删除失败！\n");
		return false;
	}
	// 删除元素
	*e = L->m_data[L->m_length-1]; // 保存被删除的元素
	L->m_length--;	// 表长减一
	printf("[INFO] 静态顺序表表尾删除元素成功！\n");
	return true;
}

```

#### 2.2.3.15 扩展5：静态顺序表的冒泡排序算法

- 函数名：`bool sortListByBubble(SqList* L)`
- 函数功能：
  - 本函数用于对静态顺序表进行`冒泡排序`
- 函数思路：
  1. 判断参数是否合法，如果静态顺序表的指针`无效（即L为NULL）`，则排序失败。
  2. 通过合法性测试后，如果静态顺序表`为空`，则`无需排序`，直接`返回true`。
  3. 如果静态顺序表不为空，则`依次比较相邻的两个元素`，如果前一个元素`大于（或小于）`后一个元素，则`交换两个元素的位置`。
  4. 一轮比较下来，最大（或小于）的元素被交换到了`最后的位置`。
  5. 重复上述步骤，直到`所有元素都有序`。
- 注意：
  1. 冒泡排序的时间复杂度为`O(n^2)`，空间复杂度为`O(1)`。
  2. 冒泡排序是一种`稳定`的排序算法，即`相同元素的相对位置在排序前后不会发生变化`。
  3. 冒泡排序是一种`原地`排序算法，即`不需要额外的辅助空间`。
  4. 冒泡排序是一种`交换`排序算法，即通过不断的`交换相邻的元素`，将最大（或最小）的元素交换到`最后的位置`。
  5. 冒泡排序是一种简单的排序算法，适用于元素个数较少的情况。
  6. 冒泡排序的第一层循环控制`比较的轮数`，即需要比较`n-1`轮，因为最后一轮只剩下一个元素，不需要比较，因此其循环不变量i的范围为`[0,m_length-2]`。
  7. 冒泡排序的第二层循环控制`每轮比较的次数`，即每轮比较`n-1-i`次，因为每轮比较后，最大（或最小）的元素已经被交换到了最后的位置，不需要再比较， 因此其循环不变量j的范围为`[0,m_length-2-i]`。
  8. 注意，6和7中的i，j都是用来表示`数组下标`的，如果需要用来表示元素位序，应该`+1`。
  9. 此处的冒泡排序是`升序`排序，如果需要降序排序，只需要将if语句中的比较符号由`>`改为`<`即可。

```c
/**
* @brief 静态顺序表的冒泡排序操作
* @param L 待排序的静态顺序表
* @return 排序成功返回true，否则返回false
*/
bool sortListByBubble(SqList* L)
{
	printf("[INFO] sortListByBubble() is called：尝试对静态顺序表进行冒泡排序\n");
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表是否为空
	{
		printf("[ERROR] sortListByBubble() 参数错误,L为空，排序失败！\n");
		return false;
	}
	if (L->m_length == 0) // 判断静态顺序表是否为空
	{
		printf("[INFO] sortListByBubble() 参数错误,静态顺序表为空，无需排序！\n");
		return true;
	}
	// 排序
	for(int i = 0; i < L->m_length-1; i++) // 外层循环控制比较的轮数
	{
		for(int j = 0; j < L->m_length-1-i; j++) // 内层循环控制每轮比较的次数
		{
			if(L->m_data[j] > L->m_data[j+1]) // 如果前一个元素大于后一个元素，则交换两个元素的位置
			{
				Elemtype tmp = L->m_data[j];
				L->m_data[j] = L->m_data[j+1];
				L->m_data[j+1] = tmp;
			}
		}
	}
	printf("[INFO] 静态顺序表冒泡排序成功！\n");
	return true;
}

```

#### 2.2.3.16 扩展6：静态顺序表的选择排序算法

- 函数名：`bool sortListBySelect(SqList* L)`
- 函数功能：
  - 本函数用于对静态顺序表进行`选择排序`。
- 函数思路：
  1. 判断参数是否合法，如果静态顺序表的指针`无效（即L为NULL）`，则排序失败。
  2. 通过合法性测试后，如果静态顺序表`为空`，则`无需排序`，直接`返回true`。
  3. 如果静态顺序表`不为空`，依次找到静态顺序表中的`最小（或最大）元素`，将其与`第i个元素`交换位置。
  4. 重复上述步骤，直到所有元素都有序。
- 注意：
  1. 选择排序的时间复杂度为`O(n^2)`，空间复杂度为`O(1)`。
  2. 选择排序是一种`不稳定`的排序算法，即`相同元素的相对位置在排序前后可能发生变化`。
  3. 选择排序是一种`原地`排序算法，即`不需要额外的辅助空间`。
  4. 选择排序是一种`交换`排序算法，即通过不断的`交换元素的位置`，将最小（或最大）的元素交换到`最前面`。
  5. 选择排序是一种简单的排序算法，适用于元素个数较少的情况。
  6. 选择排序的第一层循环控制`比较的轮数`，即需要比较`n-1`轮，因为最后一轮只剩下一个元素，不需要比较，因此其循环不变量i的范围为`[0,m_length-2]`。
  7. 选择排序的第二层循环控制`每轮比较的次数`，因为每轮比较后，最小（或最大）的元素已经被交换到了`最前面`，不需要再比较，因此每轮比较的下标从`未比较过的元素`开始，即从`i+1`开始，而结束点一直为`m_length-1`，因此其循环不变量j的范围为`[i+1,m_length-1]`。
  8. 注意，6和7中的i，j都是用来表示`数组下标`的，如果需要用来表示元素位序，应该`+1`。
  9. 此处的选择排序是`升序`排序，如果需要降序排序，只需要将if语句中的比较符号由`<`改为`>`即可。

```c
/**
* @brief 静态顺序表的选择排序操作
* @param L 待排序的静态顺序表
* @return 排序成功返回true，否则返回false
*/
bool sortListBySelect(SqList* L)
{
	printf("[INFO] sortListBySelect() is called：尝试对静态顺序表进行选择排序\n");
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表是否为空
	{
		printf("[ERROR] sortListBySelect() 参数错误,L为空，排序失败！\n");
		return false;
	}
	if (L->m_length == 0) // 判断静态顺序表是否为空
	{
		printf("[INFO] sortListBySelect() 参数错误,静态顺序表为空，无需排序！\n");
		return true;
	}
	// 排序
	for(int i = 0; i < L->m_length-1; i++) // 外层循环控制比较的轮数
	{
		int min = i; // 记录最小元素的下标
		for(int j = i+1; j < L->m_length; j++) // 内层循环控制每轮比较的次数
		{
			if(L->m_data[j] < L->m_data[min]) // 如果第j个元素小于第min个元素，则更新min的值
			{
				min = j;
			}
		}
		if(min != i) // 如果min的值发生了变化，则交换两个元素的位置
		{
			Elemtype tmp = L->m_data[i];
			L->m_data[i] = L->m_data[min];
			L->m_data[min] = tmp;
		}
	}
	printf("[INFO] 静态顺序表选择排序成功！\n");
	return true;
}
```

#### 2.2.3.17 扩展7：静态顺序表的合并

- 函数名：`bool mergeList(SqList* L1, SqList* L2, SqList* L3)`
- 函数功能：
  - 本函数用于`将两个有序静态顺序表合并成一个有序静态顺序表`。
- 函数思路：
  1. 判断参数是否合法，如果静态顺序表的指针`无效（即L为NULL）`，则合并失败。
  2. 判断两个顺序表L1、L2的`长度之和`是否`大于L3的容量`，如果大于，则合并失败。
  3. 通过合法性测试后，如果静态顺序表L1`为空，`则`直接将L2复制到L3中`，合并成功。
  4. 如果静态顺序表L2`为空`，则`直接将L1复制到L3中`，合并成功。
  5. 如果L1、L2均`不为空`，则`依次比较`L1和L2中的元素，`将较小的元素插入到L3中`。
  6. 如果L1中的元素已经全部插入到L3中，则`将L2中的剩余元素插入到L3中`。
  7. 如果L2中的元素已经全部插入到L3中，则`将L1中的剩余元素插入到L3中`。
- 注意：
  1. 合并操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  2. 合并操作是将两个`有序静态顺序表`合并成一个新的有序静态顺序表，所以合并后的静态顺序表也是`有序`的，且合并后的静态顺序表的长度等于两个静态顺序表的`长度之和`。
  3. 合并操作是一种简单的合并算法，适用于两个静态顺序表的元素个数较少的情况。
  6. 合并操作是一种`插入排序`的变种，即通过不断的`比较`两个静态顺序表的元素，将较小的元素插入到新的静态顺序表中。
  7. 在合并算法中，需要维护`三个指针`，分别指向`三个静态顺序表的当前元素`，以便于比较和插入。
  8. 静态顺序表的局限性：静态顺序表的容量是`固定`的，不支持`动态扩容`，所以在合并操作中，需要保证合并后的静态顺序表的`容量足够`。

```c
/**
* @brief 两个有序静态顺序表的合并操作
* @param L1 第一个有序静态顺序表
* @param L2 第二个有序静态顺序表
* @param L3 合并后的有序静态顺序表
* @return 合并成功返回true，否则返回false
*/
bool mergeList(SqList* L1, SqList* L2, SqList* L3)
{
	printf("[INFO] mergeList() is called：尝试合并两个有序静态顺序表\n");
	// 判断参数是否合法
	if (NULL == L1 || NULL == L2 || NULL == L3) // 判断静态顺序表是否为空
	{
		printf("[ERROR] mergeList() 参数错误,L1或L2或L3为空，合并失败！\n");
		return false;
	}
	if (L1->m_length + L2->m_length > MAX_SIZE) // 判断静态顺序表的长度之和是否大于L3的容量
	{
		printf("[ERROR] mergeList() 参数错误,静态顺序表的长度之和大于L3的容量，合并失败！\n");
		return false;
	}
	// 合并
	int pos1 = 0; // 指向L1的当前元素
	int pos2 = 0; // 指向L2的当前元素
	int pos3 = 0; // 指向L3的当前元素
	while(pos1 < L1->m_length && pos2 < L2->m_length) // 比较L1和L2中的元素
	{
		if(L1->m_data[pos1] < L2->m_data[pos2]) // 如果L1中的元素小于L2中的元素，则将L1中的元素插入到L3中
		{
			L3->m_data[pos3++] = L1->m_data[pos1++];
		}
		else // 如果L1中的元素大于等于L2中的元素，则将L2中的元素插入到L3中
		{
			L3->m_data[pos3++] = L2->m_data[pos2++];
		}
	}
	while(pos1 < L1->m_length) // 如果L2中的元素已经全部插入到L3中，则将L1中的剩余元素插入到L3中
	{
		L3->m_data[pos3++] = L1->m_data[pos1++];
	}
	while(pos2 < L2->m_length) // 如果L1中的元素已经全部插入到L3中，则将L2中的剩余元素插入到L3中
	{
		L3->m_data[pos3++] = L2->m_data[pos2++];
	}
	L3->m_length = L1->m_length + L2->m_length; // 合并后的静态顺序表的长度等于两个静态顺序表的长度之和
	printf("[INFO] 静态顺序表合并成功！\n");
}
```

### 2.2.4 动态顺序表的代码实现（以C++语言为例）

#### 2.2.4.1 动态顺序表类的基本定义

在实现数据结构时，C语言和C++语言有一些显著的不同。C语言是一种过程式编程语言，通常通过结构体和函数的组合来实现数据结构，使用手动内存管理（如 `malloc` 和 `free`），并没有类和对象的概念。而C++作为一种面向对象编程语言，允许使用`类`和`对象`来`封装数据结构的属性和操作`。通过构造函数和析构函数，C++能够更加灵活地管理资源，并支持模板类，从而使得数据结构可以适用于任意的数据类型，增强了代码的可重用性。

在本节中，我们将以C++为例，介绍如何使用模板类实现一个支持任意数据类型的动态顺序表类。该类提供了顺序表的基本操作，包括插入、删除、查找、扩容等功能，并且提供了一些高级操作如去重、逆置和排序等。以下是动态顺序表类的基本定义：

```cpp
// ====================动态顺序表类定义====================
// 这里使用模板类实现，支持任意数据类型
template <class T>
class DSeqList		// D - Dynamic Se-Sequence
{
public:
    // 基本操作
    DSeqList(int capacity = 10);	/// 有参构造函数，默认容量为10
    ~DSeqList();	/// 析构函数
    bool init();	/// 初始化
    bool destroy();	/// 销毁
    bool clear();	/// 清空
    bool isEmpty() const;	/// 判空
    int length() const;	/// 求长度
    int capacity() const;	/// 求容量
    bool increase(int len);	/// 扩容
    bool insert(int i, T e);	/// 插入
    bool remove(int i, T& e);	/// 删除
    bool locate(T e, int& i) const;	/// 按值查找
    bool get(int i, T& e) const;	/// 按位查找
    bool set(int i, T e);	/// 赋值
    bool print() const;	/// 输出

    // 拓展操作
    bool push_front(T e);	/// 头插
    bool pop_front(T& e);	/// 头删
    bool push_back(T e);	/// 尾插
    bool pop_back(T& e);	/// 尾删

    // 高阶操作
    bool removeDuplicate();	/// 去重
    bool reverse();	/// 逆置
    bool merge(const DSeqList<T>& list);	/// 合并
    bool sortByInsert();	/// 插入排序
    bool swap(int i, int j);	/// 交换
    bool sortByQuick(int left = 1, int right = -1);	/// 快速排序

private:
    T* m_data;		/// 数据区
    int m_size;		/// 当前元素个数,即长度
    int m_capacity;	/// 当前容量,即最大元素个数
};
```

这个模板类 `DSeqList` 实现了一个支持动态扩容、插入、删除等操作的动态顺序表，它通过泛型模板支持任意类型的数据。

#### 2.2.4.2 动态顺序表的的有参构造函数

- 函数名：`template<class T> DSeqList<T>::DSeqList(int capacity)`
- 函数功能：
  - 本函数在动态顺序表对象创建时`被自动调用`，用于`初始化动态顺序表对象`。
- 函数思路：
  1. `初始化动态顺序表的容量`。
  2. 调用`init()函数`初始化动态顺序表，若初始化成功则什么都不做，否则`释放内存`。
- 注意：
  1. 该函数是构造函数，`不需要返回值`。
  2. 该函数在动态顺序表对象创建时被自动调用，无需用户手动调用。
  3. 该函数的参数用来`指定动态顺序表初始容量`，若不指定则默认为10（在`函数声明`时已经指定了默认值）。。
  4. 当用户自定义了有参构造函数时，`系统不会再提供无参构造函数`，因此如果需要用无参构造函数生成对象，需要`显式定义无参构造函数`。

```cpp
/*
* @brief 有参构造函数
* @param capacity 动态顺序表的容量
* @return 无，因为是构造函数，不需要返回值
*/
template<class T>
DSeqList<T>::DSeqList(int capacity)
{
	cout << endl << "[INFO] 构造函数DSeqList(int capacity)被调用" << endl;
	m_capacity = capacity;
	if (!init())
	{
		m_data = NULL;
		m_size = 0;
		m_capacity = 0;
	}
}
```

#### 2.2.4.3 动态顺序表的析构函数

- 函数名：`template<class T> DSeqList<T>::~DSeqList()`
- 函数功能：
  1. 本函数在动态顺序表对象销毁时`被自动调用`，用于`销毁动态顺序表对象`。
- 函数思路：
  1. 调用`destroy()`函数销毁动态顺序表对象。
- 注意：
  1. 该函数是析构函数，`不需要返回值`。
  2. 该函数在动态顺序表对象销毁时被自动调用，无需`用户手动调用`。

```cpp
/*
* @brief 析构函数
* @param 无
* @return 无，因为是析构函数，不需要返回值
*/
template<class T>
DSeqList<T>::~DSeqList()
{
	cout << endl << "[INFO] 析构函数~DSeqList()被调用" << endl;
	destroy();
}
```

#### 2.4.4.4 动态顺序表的初始化

- 函数名：`template<class T> bool DSeqList<T>::init()`
- 函数功能：
  - 本函数用于`初始化动态顺序表`。
- 函数思路：
  1. `申请动态顺序表的数据区`，若申请成功则初始化成功，否则初始化失败。
  2. 如果初始化成功，则`将当前元素个数置为0`，即长度为0。
  3. 返回初始化结果。
- 注意：
  1. 初始化操作会`改变动态顺序表的状态`，因此`不设置为常成员函数`。
  2. 初始化操作时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  3. 初始化操作会将数据域创建到堆，该操作可能会失败，因此在申请内存后一定要`判断是否申请成功`。

```cpp
/*
* @brief 初始化
* @param 无
* @return 初始化成功返回true，否则返回false
*/
template<class T>
bool DSeqList<T>::init()
{
	cout << endl << "[INFO] init()被调用" << endl;
	m_data = new T[m_capacity];
	if (NULL == m_data)
	{
		cout << "[ERROR] 内存分配失败，动态顺序表初始化失败！" << endl;
		return false;
	}
	m_size = 0;
	cout << "[INFO] 动态顺序表初始化成功！" << endl;
	return true;
}
```

#### 2.4.4.5 动态顺序表的销毁

- 函数名：`template<class T> bool DSeqList<T>::destroy()`
- 函数功能：
  1. 本函数用于`销毁动态顺序表`。
- 函数思路：
  1. `释放动态顺序表的数据区`，若释放成功则销毁成功，否则销毁失败。
  2. 如果销毁成功，则`将当前元素个数置为0`，即长度为0。
  3. 返回销毁结果。
- 注意：
  1. 销毁操作`会`改变动态顺序表的状态，因此`不设置为常成员函数`。
  2. 销毁操作时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  3. 销毁操作会释放动态顺序表的数据区，因此在销毁前需要判`断数据区指针是否合法`，如果指针为NULL则`不需要释放`。

``` cpp
/*
* @brief 销毁
* @param 无
* @return 销毁成功返回true，否则返回false
*/
template<class T>
bool DSeqList<T>::destroy()
{
	cout << endl << "[INFO] destroy()被调用" << endl;
	if (NULL != m_data)
	{
		delete[] m_data;
		m_data = NULL;
		m_size = 0;
		m_capacity = 0;
	}
	cout << "[INFO] 动态顺序表销毁成功！" << endl;
	return true;
}
```

#### 2.4.4.6 动态顺序表的清空

- 函数名：`template<class T> bool DSeqList<T>::clear()`
- 函数功能：
  1. 本函数用于`清空动态顺序表`。
- 函数思路：
  1. 将当前元素个数`置为0`，即`长度为0`。
  2. 清空成功返回true。
- 注意：
  1. 清空操作`会`改变动态顺序表的状态，因此`不设置`为常成员函数。
  2. 清空操作时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  3. 该清空操作是`逻辑上的清空`，因此`数据区的内存空间（即m_data）不会被释放`。

```cpp
/*
* @brief 清空
* @param 无
* @return 清空成功返回true，否则返回false
*/
template<class T>
bool DSeqList<T>::clear()
{
	cout << endl << "[INFO] clear()被调用" << endl;
	m_size = 0;
	return true;
}
```

#### 2.4.4.7 动态顺序表的判空

- 函数名称：`template<class T> bool DSeqList<T>::isEmpty() const`
- 函数功能：
  1. 本函数用于`判断动态顺序表是否为空`。

- 函数思路：
  1. 顺序表有`成员变量m_size`记录`当前元素个数`，若m_size为0则表示顺序表为空，因此直接返回`m_size是否为0`即可。
- 注意：
  1. 因为判空操作`不会`改变动态顺序表的状态，因此`设置`为`常成员函数`。
  2. 判空操作时间复杂度为`O(1)`，空间复杂度为`O(1)`。

```c++
/*
* @brief 判空
* @param 无
* @return 若动态顺序表为空则返回true，否则返回false
*/
template<class T>
bool DSeqList<T>::isEmpty() const
{
	cout << endl << "[INFO] isEmpty()被调用" << endl;
	return m_size == 0;
}
```

#### 2.4.4.8 动态顺序表的求长度操作

- 函数名称：`template<class T> int DSeqList<T>::length() const`
- 函数功能：
  1. 本函数用于`求动态顺序表的长度`。
- 函数思路：
  1. 顺序表有成员变量`m_size`记录当前元素个数，直接返回`m_size`即可。
- 注意：
  1. 因为求长度操作`不会`改变动态顺序表的状态，因此设置为`常成员函数`。
  2. 求长度操作时间复杂度为`O(1)`，空间复杂度为`O(1)`。

```cpp
/*
* @brief 求长度
* @param 无
* @return 返回动态顺序表的长度
*/
template<class T>
int DSeqList<T>::length() const
{
	cout << endl << "[INFO] length()被调用" << endl;
	return m_size;
}
```

#### 2.4.4.9 动态顺序表的求容量操作

- 函数名称：`template<class T> int DSeqList<T>::capacity() const`
- 函数功能：
  1. 本函数用于`求动态顺序表的容量（即表的最大长度）`。
 - 函数思路：
   1. 顺序表有成员变量`m_capacity`记录当前容量，直接返回`m_capacity`即可。
 - 注意：
   1. 因为求容量操作`不会`改变动态顺序表的状态，因此设置为`常成员函数`。
   2. 求容量操作时间复杂度为`O(1)`，空间复杂度为`O(1)`。

```cpp
/*
 * @brief 求容量
 * @param 无
 * @return 返回动态顺序表的容量
 */
template<class T>
int DSeqList<T>::capacity() const
{
	cout << endl << "[INFO] capacity()被调用" << endl;
	return m_capacity;
}
```

#### 2.4.4.10 动态顺序表的扩容

- 函数名称：`template<class T> bool DSeqList<T>::increase(int len)`
- 函数功能：
  1. 本函数用于`扩容动态顺序表`。
- 函数思路：
  1. `申请新的数据区，长度为原数据区长度加上扩容长度len`。
  2. `将原数据区的元素复制到新数据区`。
  3. `释放原数据区`。
  4. `将新数据区的地址赋给原数据区`。
  5. 扩容成功返回`true`。
- 注意：
  1. 扩容操作`会`改变动态顺序表的状态，因此`不设置`为常成员函数。
  2. 扩容操作时间复杂度为`O(m_size)`，空间复杂度为`O(len)`,其中`m_size`为当前元素个数, `len`为扩容长度。
  3. 扩容操作会`将数据域创建到堆`，该操作可能会`失败`，因此在申请内存后一定要`判断是否申请成功`。

```cpp
/*
* @brief 扩容
* @param len 扩容的长度
* @return 扩容成功返回true，否则返回false
*/
template<class T>
bool DSeqList<T>::increase(int len)
{
	cout << endl << "[INFO] increase(int len)被调用，扩容长度为" << len << endl;
	T* new_data = new T[m_capacity + len];
	if (NULL == new_data)
	{
		cout << "[ERROR] 内存分配失败，动态顺序表扩容失败！" << endl;
		return false;
	}
	// 将原数据区的元素复制到新数据区
	// 方法一：使用内存拷贝函数memcpy
	// memcpy(new_data, m_data, m_size * sizeof(T));

	// 方法二：通过for循环逐个复制
	for (int i = 0; i < m_size; i++)
	{
		new_data[i] = m_data[i];
	}
	delete[] m_data;
	m_data = new_data;
	m_capacity += len;
	cout << "[INFO] 动态顺序表扩容成功！" << endl;
	return true;
}
```

#### 2.4.4.11 动态顺序表的按位插入

- 函数名称：`template<class T> bool DSeqList<T>::insert(int i, T e)`
- 函数功能：
  - 本函数用于`在动态顺序表的第i个位置插入元素e`。
- 函数思路：
  1. 首先进行`合法性检查`，判断`动态顺序表是否已初始化`，`插入位置是否合法`，只要有一个不合法则插入失败。
  2. 判断动态顺序表是否`已满`，若已满则需要`先扩容再插入`，如果扩容失败则`插入失败`。
  3. `从后往前`遍历，`将第i个位置及其后的元素依次后移一位`。
  4. 将元素e`插入到第i个位置`。
  5. `元素个数加1`。
  6. 插入成功返回true。
- 注意：
  1. 顺序表的位序`从1开始`，而数组的下标`从0开始`，不要混淆。
  2. 在函数中，参数i是指`插入位置`，其本质为`顺序表的位序`，从`1`开始；
  3. 而for循环中的j变量的本质是`数组的下标`，从`0`开始，因此当用j来表示顺序表的位序时，需要`加1`。因此，由“将第i个位置及其后的元素依次后移一位”这句话可知j+1的范围为`[i,m_size]`,所以j的范围为`[i-1,m_size-1]`，所以for循环的范围为`[j=m_size-1;j>=i-1;j--]`。
  4. 因为插入操作会改变动态顺序表的状态，所以`不设置`为常成员函数。
  5. 插入操作时间复杂度为`O(n)`，空间复杂度为`O(1)`。

```cpp
/*
* @brief 按位插入
* @param i 插入位置
* @param e 插入元素
* @return 插入成功返回true，否则返回false
*/
template<class T>
bool DSeqList<T>::insert(int i, T e)
{
	cout << endl << "[INFO] insert(int i, T e)被调用，插入位置为" << i << "，插入元素为" << e << endl;
	if (NULL == m_data)
	{
		cout << "[ERROR] 动态顺序表未初始化！" << endl;
		return false;
	}
	if (i < 1 || i > m_size + 1)
	{
		cout << "[ERROR] 插入位置不合法！" << endl;
		return false;
	}
	if (m_size >= m_capacity)
	{
		cout << "[INFO] 动态顺序表已满，开始默认扩容10个元素" << endl;
		if (!increase(10))
		{
			cout << "[ERROR] 扩容失败，插入失败！" << endl;
			return false;
		}
	}
	for (int j = m_size - 1; j >= i - 1; j--)
	{
		m_data[j + 1] = m_data[j];
	}
	m_data[i - 1] = e;
	m_size++;
	return true;
}
```

#### 2.4.4.12 动态顺序表的按位删除

- 函数名称：`template<class T> bool DSeqList<T>::remove(int i, T& e)`
- 函数功能：
  * 			本函数用于`删除动态顺序表的第i个位置的元素`。
- 函数思路：
  1. 首先进行`合法性检查`，判断`动态顺序表是否已初始化`，`删除位置是否合法`，只要有一个不合法则删除失败。
  2. 若通过合法性检查，则`将被删除的元素赋值给e`。
  3. `从前往后`遍历，`将第i+1个位置及其后的元素依次前移一位`。
  4. 元素个数`减1`。
  5. 删除成功返回true。
- 注意：
  1. 顺序表的位序`从1开始`，而数组的下标`从0开始`，不要混淆。
  2. 在函数中，参数i是指`删除位置`，其本质为`顺序表的位序`，从`1`开始；
  3. 而for循环中的j变量的本质是`数组的下标`，从`0`开始，因此当用j来表示顺序表的位序时，需要`加1`。因此，由“将第i+1个位置及其后的元素依次前移一位”这句话可知j+1的范围为`[i+1,m_size]`,由于j是数组下标，所以j的范围为`[i,m_size-1]`，所以for循环的范围为`[j=i;j<=m_size-1;j++]`。
  4. 因为删除操作会改变动态顺序表的状态，所以`不设置`为常成员函数。
  5. 删除操作时间复杂度为`O(n)`，空间复杂度为`O(1)`。

```cpp
/*
* @brief 按位删除
* @param i 删除位置
* @param e 被删除元素
* @return 删除成功返回true，否则返回false
*/
template<class T>
bool DSeqList<T>::remove(int i, T& e)
{
	cout << endl << "[INFO] remove(int i, T& e)被调用，删除位置为" << i << endl;
	if (NULL == m_data)
	{
		cout << "[ERROR] 动态顺序表未初始化！" << endl;
		return false;
	}
	if (i < 1 || i > m_size)
	{
		cout << "[ERROR] 删除位置不合法！" << endl;
		return false;
	}
	e = m_data[i - 1];
	for (int j = i; j < m_size; j++)
	{
		m_data[j - 1] = m_data[j];
	}
	m_size--;
	return true;
}
```

#### 2.4.4.13 动态顺序表的按值查找

- 函数名称：`template<class T> bool DSeqList<T>::locate(T e, int& i) const`
- 函数功能：
  * 			本函数用于`在动态顺序表中查找元素e的位序`。
- 函数思路：
  1. 首先进行`合法性检查`，判断`动态顺序表是否已初始化`，如果未初始化则查找失败。
  2. 从第一个元素开始`遍历`，若找到元素e则返回true，否则返回false。
- 注意：
  1. 顺序表的位序`从1开始`，而数组的下标`从0开始`，不要混淆。
  2. 本函数无需`判空操作`，因为`for循环中已经包含了顺序表为空的情况`。
  3. 按值查找操作时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  4. 本函数不需要改变顺序表中的任何值，因此设置为`常成员函数`。

```cpp
/*
* @brief 按值查找
* @param e 要查找的元素
* @param i 用于返回元素的位序
* @return 查找成功返回true，否则返回false
*/
template<class T>
bool DSeqList<T>::locate(T e, int& i) const
{
	cout << endl << "[INFO] locate(T e, int& i)被调用，查找元素为" << e << endl;
	if (NULL == m_data)
	{
		cout << "[ERROR] 动态顺序表未初始化！" << endl;
		return false;
	}for (i = 0; i < m_size; i++)
	{
		if (m_data[i] == e)
		{
			cout << "[INFO] 元素" << e << "的位序为" << ++i << endl; // i+1为元素的位序
			return true;
		}
	}
	cout << "[INFO] 元素" << e << "不存在！" << endl;
	return false;
}
```

#### 2.4.4.14 动态顺序表的按位查找

- 函数名称：`template<class T> bool DSeqList<T>::get(int i, T& e) const`
- 函数功能：
  * 			本函数用于`在动态顺序表中查找位序为i的元素`。
- 函数思路：
  1. 首先进行`合法性检查`，判断`动态顺序表是否已初始化`，`查找位置是否合法`，只要有一个不合法则查找失败。
  2. 若通过合法性检查，则`将第i个位置的元素赋值给e`。
  3. 查找成功返回true。
- 注意：
  1. 顺序表的位序`从1开始`，而数组的下标`从0开始`，不要混淆。
  2. 本函数无需`判空操作`，因为在合法性检查中已经包含了`顺序表为空`的情况，即`（i < 1 || i > m_size）`中的`m_size为0`时。
  3. 按位查找操作时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  4. 本函数不需要改变顺序表中的任何值，因此设置为`常成员函数`。

```cpp
/*
* @brief 按位查找
* @param i 要查找的位序
* @param e 用于返回元素
* @return 查找成功返回true，否则返回false
*/
template<class T>
bool DSeqList<T>::get(int i, T& e) const
{
	cout << endl << "[INFO] get(int i, T& e)被调用，查找位序为" << i << endl;
	if (NULL == m_data)
	{
		cout << "[ERROR] 动态顺序表未初始化！" << endl;
		return false;
	}
	if (i < 1 || i > m_size)
	{
		cout << "[ERROR] 查找位置不合法！" << endl;
		return false;
	}
	e = m_data[i - 1];
	cout << "[INFO] 位序为" << i << "的元素为" << e << endl;
	return true;
}
```

#### 2.4.4.15 动态顺序表的赋值操作

- 函数名称：`template<class T> bool DSeqList<T>::set(int i, T e)`
- 函数功能：
  * 			本函数用于`将动态顺序表中第i个位置的元素赋值为e`。
- 函数思路：
  1. 首先进行`合法性检查`，判断`动态顺序表是否已初始化`，`赋值位置是否合法`，只要有一个不合法则赋值失败。
  2. 若通过合法性检查，则`将第i个位置的元素赋值为e`。
  3. 赋值成功返回true。
- 注意：
  1. 顺序表的位序`从1开始`，而数组的下标`从0开始`，不要混淆。
  2. 本函数无需`判空操作`，因为在`合法性检查`中已经包含了`顺序表为空`的情况，即`（i < 1 || i > m_size）`中的`m_size为0`时。
  3. 赋值操作时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  4. 本函数会改变顺序表中的值，因此`不设置`为常成员函数。

```cpp
/*
* @brief 赋值
* @param i 要赋值的位序
* @param e 赋值的元素
* @return 赋值成功返回true，否则返回false
*/
template<class T>
bool DSeqList<T>::set(int i, T e)
{
	cout << endl << "[INFO] set(int i, T e)被调用，赋值位置为" << i << "，赋值元素为" << e << endl;
	if (NULL == m_data)
	{
		cout << "[ERROR] 动态顺序表未初始化！" << endl;
		return false;
	}
	if (i < 1 || i > m_size)
	{
		cout << "[ERROR] 赋值位置不合法！" << endl;
		return false;
	}
	m_data[i - 1] = e;
	cout << "[INFO] 位序为" << i << "的元素赋值为" << e << endl;
	return true;
}
```

#### 2.4.4.16 动态顺序表的输出

- 函数名称：`template<class T> bool DSeqList<T>::print() const`
- 函数功能：
  * 			本函数用于`输出动态顺序表的所有元素`。
- 函数思路：
  1. 首先进行`合法性检查`，判断`动态顺序表是否已初始化`，如果未初始化则输出失败。
  2. 判断`动态顺序表是否为空`，如果为空则输出失败。
  3. 如果不为空，则`从第一个元素开始遍历输出所有元素`。
  4. 输出成功返回true。
- 注意：
  1. 输出操作`不会`改变动态顺序表的状态，因此设置为`常成员函数`。
  2. 输出操作时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  3. 顺序表的位序从`1`开始，而数组的下标从`0`开始，不要混淆。

```cpp
/*
* @brief 输出
* @param 无
* @return 输出成功返回true，否则返回false
* @note
* 		
*/
template<class T>
bool DSeqList<T>::print() const
{
	cout << endl << "[INFO] print()被调用" << endl;
	if (NULL == m_data)
	{
		cout << "[ERROR] 动态顺序表未初始化！" << endl;
		return false;
	}
	if (isEmpty())
	{
		cout << "[INFO] 动态顺序表为空！" << endl;
		return false;
	}
	cout << "[INFO] 动态顺序表的元素为：";
	for (int i = 0; i < m_size; i++)
	{
		cout << m_data[i] << " ";
	}
	cout << endl;
	return true;
}
```

#### 2.4.4.17 动态顺序表的头插元素

- 函数名称：`template<class T> bool DSeqList<T>::push_front(T e)`
- 函数功能：
  * 			本函数用于`在动态顺序表的头部插入元素e`。
- 函数思路：
  1. 首先进行`合法性检查`，判断`动态顺序表是否已初始化`，`是否已满`，若未初始则插入失败,若已满则需要考虑扩容。
  2. `从后往前`遍历，`将所有元素依次后移一位，空出第一个位置`。
  3. `将元素e插入到顺序表的第一个位置`，即`数组下标为0`的位置。
  4. 元素个数`加1`。
  5. 插入成功返回true。
- 注意：
  1. 顺序表的位序`从1开始`，而数组的下标`从0开始`，不要混淆。
  2. 在for循环中，j的本质是`数组下标`，当需要用j表示元素位序时，应该`+1`，所以根据插入操作中“将第i个元素及之后的元素后移”这句话，位序j+1的范围为`[i,m_size]`，又因为该函数是头插操作，所以`i=1`，j+1的范围为`[1,m_size]`，所以j的范围为`[0,m_size-1]`，所以for循环的范围为`[j=m_size-1;j>=0;j--]`。
  3. 因为插入操作`会改变`动态顺序表的状态，所以不设置为常成员函数。
  4. 该头插操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  5. 在实际的开发中，头插法其实可以直接调用`insert(1,e)`来实现，这里只是为了演示头插法的实现原理而特意写出来的。

```cpp
/*
* @brief 头插元素
* @param e 要插入的元素
* @return 插入成功返回true，否则返回false
*/
template<class T>
bool DSeqList<T>::push_front(T e)
{
	cout << endl << "[INFO] push_front(T e)被调用，插入元素为" << e << endl;
	if (NULL == m_data)
	{
		cout << "[ERROR] 动态顺序表未初始化！" << endl;
		return false;
	}
	if (m_size >= m_capacity)
	{
		cout << "[INFO] 动态顺序表已满，开始默认扩容10个元素" << endl;
		if (!increase(10))
		{
			cout << "[ERROR] 扩容失败，插入失败！" << endl;
			return false;
		}
	}
	for (int j = m_size - 1; j >= 0; j--)
	{
		m_data[j + 1] = m_data[j];
	}
	m_data[0] = e;
	m_size++;
	return true;
}
```

#### 2.4.4.17 动态顺序表的头删元素

- 函数名称：`template<class T> bool DSeqList<T>::pop_front(T& e)`
- 函数功能：
  1. 本函数用于`删除动态顺序表的表头元素`。
- 函数思路：
  1. 首先进行`合法性检查`，判断动态顺序表`是否已初始化`，`是否为空`，若未初始化或为空则删除失败。
  2. `将表头元素赋值给e`。
  3. `从前往后`遍历，`将第2个位置及其后的元素依次前移一位`，覆盖掉第1个位置的元素。
  4. 元素个数`减1`。
  5. 删除成功返回true。
- 注意：
  1. 顺序表的位序`从1开始`，而数组的下标`从0开始`，不要混淆。
  2. 因为删除操作`会改变`动态顺序表的状态，所以`不设置`为常成员函数。
  3. 该头删操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  4. 在for循环中，j的本质是`数组下标`，当需要用j表示元素位序时，应该`+1`，所以根据删除操作中“将第i+1个元素及之后的元素前移”这句话，位序j+1的范围为`[i+1,m_size]`，又因为该函数是头删操作，所以i=1，j+1的范围为`[2,m_size]`，所以j的范围为`[1,m_size-1]`，所以for循环的范围为`[j=1;j<=m_size-1;j++]`。
  5. 顺序表的头删操作其实可以直接调用`remove(1,e)`来实现，这里只是为了演示头删操作的实现原理而特意写出来的。

```cpp
/*
* @brief 头删元素
* @param e 用于返回被删除的元素
* @return 删除成功返回true，否则返回false
*/
template<class T>
bool DSeqList<T>::pop_front(T& e)
{
	cout << endl << "[INFO] pop_front(T& e)被调用" << endl;
	if (NULL == m_data)
	{
		cout << "[ERROR] 动态顺序表未初始化！" << endl;
		return false;
	}
	if (isEmpty())
	{
		cout << "[ERROR] 动态顺序表为空，删除失败！" << endl;
		return false;
	}
	e = m_data[0];
	for (int j = 1; j < m_size; j++)
	{
		m_data[j - 1] = m_data[j];
	}
	m_size--;
	return true;
}
```

#### 2.4.4.18 动态顺序表的尾插元素

- 函数名称：`template<class T> bool DSeqList<T>::push_back(T e)`
- 函数功能：
  * 			本函数用于`在动态顺序表的尾部插入元素e`。
- 函数思路：
  1. 首先进行`合法性检查`，判断动态顺序表`是否已初始化`，`是否已满`，若未初始则插入失败,若已满则需要考虑扩容。
  2. 将元素e插入到顺序表的第`m_size+1`个位置，即数组的第`m_size`个位置。
  3. 元素个数`加1`。
  4. 插入成功返回true。
- 注意：
  1. 顺序表的位序`从1开始`，而数组的下标`从0开始`，不要混淆。
  2. 在不考虑扩容操作的情况下，尾插操作的时间复杂度为`O(1)`，空间复杂度为`O(1)`；如果需要扩容，则时间复杂度为`O(m_size)`，空间复杂度为`O(len)`，其中m_size为当前元素个数，len为扩容长度。
  3. 顺序表的尾插操作其实可以直接调用`insert(m_size+1,e)`来实现，这里只是为了演示尾插操作的实现原理而特意写出来的。

```cpp
/*
* @brief 尾插元素
* @param e 要插入的元素
* @return 插入成功返回true，否则返回false
*/
template<class T>
bool DSeqList<T>::push_back(T e)
{
	cout << endl << "[INFO] push_back(T e)被调用，插入元素为" << e << endl;
	if (NULL == m_data)
	{
		cout << "[ERROR] 动态顺序表未初始化！" << endl;
		return false;
	}
	if (m_size >= m_capacity)
	{
		cout << "[INFO] 动态顺序表已满，开始默认扩容10个元素" << endl;
		if (!increase(10))
		{
			cout << "[ERROR] 扩容失败，插入失败！" << endl;
			return false;
		}
	}
	m_data[m_size] = e;
	m_size++;
	return true;
}
```

#### 2.4.4.19 动态顺序表的尾删元素

- 函数名称：`template<class T> bool DSeqList<T>::pop_back(T& e)`
- 函数功能：
  * 			本函数用于`删除动态顺序表的表尾元素`。
- 函数思路：
  1. 首先进行`合法性检查`，判断动态顺序表`是否已初始化`，`是否为空`，若未初始化或为空则删除失败。
  2. 将表尾元素赋值给e，即顺序表的第`m_size`个元素，数组下标为`m_size-1`的元素。
  3. 元素个数`减1`。
  4. 删除成功返回true。
- 注意：
  1. 顺序表的位序`从1开始`，而数组的下标`从0开始`，不要混淆。
  2. 因为删除操作`会改变`动态顺序表的状态，所以`不设置`为常成员函数。
  3. 该尾删操作的时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  4. 顺序表的尾删操作其实可以直接调用`remove(m_size,e)`来实现，这里只是为了演示尾删操作的实现原理而特意写出来的。

```cpp
/*
* @brief 尾删元素
* @param e 用于返回被删除的元素
* @return 删除成功返回true，否则返回false
*/
template<class T>
bool DSeqList<T>::pop_back(T& e)
{
	cout << endl << "[INFO] pop_back(T& e)被调用" << endl;
	if (NULL == m_data)
	{
		cout << "[ERROR] 动态顺序表未初始化！" << endl;
		return false;
	}
	if (isEmpty())
	{
		cout << "[ERROR] 动态顺序表为空，删除失败！" << endl;
		return false;
	}
	e = m_data[m_size - 1];
	m_size--;
	return true;
}
```

