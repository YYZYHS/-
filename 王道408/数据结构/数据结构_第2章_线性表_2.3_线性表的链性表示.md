<center style="font-family: 华文新魏"><font size="12px" color="#4870ac">王道408 数据结构</font></center>

[toc]

# 第2章 线性表

## 2.3 线性表的链式表示

### 2.3.1 单链表的基本概念

线性表的`链式存储结构`，也称为单链表，是指通过一组任意的存储单元来存储线性表中的数据元素的数据结构。为了维护数据元素之间的线性关系，每个链表结点不仅包含元素自身的信息，还包含一个指向其后继结点的指针。（即，`各结点间的先后关系通过指针来表示`）

单链表结点的结构如下图所示：

- `data（数据域）`：用于存放数据元素的值。
- `next（指针域）`：用于存放后继结点的地址。

这种结构使得单链表可以`动态地分配内存`，不需要事先确定数据元素的数量，并且在插入和删除操作时，能够灵活地调整数据元素的存储位置。

![单链表node结构](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%AC%AC2%E7%AB%A0_%E7%BA%BF%E6%80%A7%E8%A1%A8_2.3_%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E6%80%A7%E8%A1%A8%E7%A4%BA.assets/1732cf9467852a03tplv-t2oaga2asx-jj-mark3024000q75.png)

#### 2.3.1.1 单链表的优缺点

- **优点**
  1. **动态内存分配**：单链表可以根据需要动态地分配和释放内存，无需预先分配固定大小的存储空间，从而节省内存。

  2. **插入和删除操作高效**：插入和删除操作只需修改相关结点的指针，不涉及大量数据元素的移动，因此在任意位置进行插入和删除操作的时间复杂度为 `O(1)`。

  3. **更高的灵活性**：可以方便地调整链表的大小，适应不同数量的数据元素。


- **缺点**
  1. **访问速度较慢**：由于单链表的元素不是连续存储的，访问某个特定位置的元素需要从头结点开始逐一遍历，时间复杂度为 `O(n)`，不如数组的随机访问效率高。

  2. **额外的存储空间**：每个结点除了存储数据元素外，还需要存储一个指针，这些指针域占用了额外的存储空间。

  3. **不易实现逆向遍历**：单链表只能`从前向后遍历`，逆向遍历较为困难，需要额外的数据结构（如双链表）或额外的存储来记录遍历路径。

  4. **增加编程复杂性**：与数组相比，单链表的实现和操作相对复杂，尤其是在处理指针和内存管理时，需要更加小心。


总的来说，单链表适用于需要频繁插入和删除操作的应用场景，但在需要快速随机访问元素的情况下，效率不如数组。

#### 2.3.1.2 带头结点的单链表 V.S. 不带头结点的单链表

带头结点的单链表和不带头结点的单链表之间有一些关键的区别，主要体现在结构和操作上：

**带头结点的单链表**

1. **定义**：
   - 包含一个额外的`头结点`, 不直接存储数据，主要用于简化链表操作。

2. **优点**：
   - **简化操作**：插入和删除操作在链表的`头部`时不需要特殊处理。
   - **统一处理**：链表的所有操作（如查找、插入、删除）都可以统一处理，不需判断链表是否`为空`。

3. **缺点**：
   - **内存开销**：额外的`头结点`增加了内存消耗。

**不带头结点的单链表**

1. **定义**：
   - 第一个结点直接存储`数据`, 没有`头结点`。

2. **优点**：
   - **内存节省**：不需要额外的`头结点`, 节省内存。

3. **缺点**：
   - **特殊处理**：在链表`为空`或在头部进行插入和删除时需要特别处理，代码可能更复杂。

**总结**

选择使用`带头结点`或`不带头结点`的单链表，主要取决于具体应用场景和需求。如果希望简化操作并统一处理，`带头结点`的链表更为适合；如果内存限制较为严格且链表操作相对简单，则`不带头结点`的链表可能更优。

#### 2.3.1.3 头结点和头指针的区分

在单链表数据结构中，头结点（head node）和头指针（head pointer）是两个容易混淆但又各自不同的重要概念。让我们详细解释它们的定义和容易混淆的点。

**头结点（Head Node）**

头结点是指`链表中的第一个结点`，通常存储链表中的第一个元素的数据。在链表结构中，头结点本身就是一个结点，包含`数据域和指向下一个结点的指针（即next指针）`。

**头指针（Head Pointer）**

头指针是一个`指针变量`，它指向链表的第一个结点（即头结点）。头指针本身不存储链表的数据，它只是一个指针，用于`存储头结点的地址，以便能够访问链表`。

总结：不管带不带头结点，头指针始终指向链表的`第一个结点`，而头结点是带头结点链表中的第一个结点，结点内通常`不存储信息`。

#### 2.3.1.4 链表的扩展

链表是一种灵活的数据结构，具有许多扩展和变体，适用于不同的应用场景。

`双向链表`的每个结点有两个指针，分别指向`前一个结点`和`后一个结点`，可以更方便地在两端进行插入和删除操作，支持`从后向前`遍历。

`循环链表`的最后一个结点的指针指向链表的`头结点`, 形成一个闭环，处理某些需要持续遍历的场景时可以避免`空指针异常`。

`静态链表`使用数组模拟链表结构，通过下标进行链接，在内存管理上更简单，不需要动态分配内存，适用于`结点数固定`的场合。

链表的扩展形式丰富多样，选择合适的链表类型可以提高`算法效率`和`实现的灵活性`，适应不同的数据处理需求。

### 2.3.2 单链表结点的代码描述(以C语言为例)

```c
// 设置别名
typedef int Elemtype;
// 定义单链表结点结构体
typedef struct LNode {
    Elemtype data;         // 数据部分，可以根据实际需要定义不同类型的数据
    struct LNode *next;  // 指针部分，指向下一个结点的地址
} LNode, *LinkList;
```

在这个结构体中，`data` 是存储结点数据的变量，`next` 是一个指向 `struct LNode` 类型的指针，它指向链表中的下一个结点。通过这种方式，每个结点就能够存储自己的数据，并且通过 `next` 指针链接到下一个结点，从而形成一个链表。

#### 2.3.2.1 typedef关键字的用法

`typedef` 是C语言中的一个关键字，用于`为已有数据类型定义新的别名`。它的主要作用是增强代码的可读性和易用性，特别是在处理复杂的数据结构时，如结构体或者函数指针等。

**单链表结点定义时，为什么要使用 `typedef`？**

- 在单链表结点的定义中，使用 `typedef` 的主要原因有两点：

  - **简化类型名称**：定义单链表结点结构体时，结构体名 `struct LNode` 和指向该结构体的指针 `struct LNode *` 是比较冗长的。使用 `typedef` 可以为 `struct LNode` 定义一个更简洁的别名 `LNode`，使得代码更加清晰和简洁。
  - **抽象数据类型**：通过 `typedef`，可以将数据类型的实现与其名称分离开来。这样一来，如果需要修改数据类型或者在多个文件中使用相同的数据类型时，只需修改一处 `typedef` 定义即可，提高了代码的维护性和可重用性。



**`typedef` 的语法**

- `typedef` 的语法格式如下：

  ```c
  typedef existing_type new_type_name;
  ```

  - `existing_type` 是已有的数据类型，可以是基本数据类型（如 `int`, `float` 等），也可以是自定义的结构体、枚举类型等。
  - `new_type_name` 是为 `existing_type` 定义的新的别名。

#### 2.3.2.2 `LNode` VS `LinkList`

在这段代码中，`LNode`和`*LinkList`有不同的含义和用途：

1. `LNode`：
   - 这是一个`结构体类型`，表示`单链表中的一个结点`。定义了结点的`data（数据部分）`和`next（指向下一个结点的指针）`。

2. `LinkList`：
   - 这是一个指向`LNode`类型的`指针类型`。它代表了`一个指向链表的指针`，可以用来`方便地操作链表`，比如创建、插入、删除等。

**总结**

`LNode`是结点的具体类型，而`*LinkList`是一个指向该类型的指针，通常用来表示整个链表的头指针。

### 2.3.3 带头结点的单链表的实现（以C语言为例）

#### 2.3.3.1 单链表的结构定义

单链表的结构体通常包含`一个数据域`和`一个指向下一个节点的指针`。每个节点的结构体通常如下定义：

```c
// ============================预处理信息============================
typedef int bool;      // C语言没有bool类型，使用int模拟，0为false，非0为true
#define true 1         // 定义true为1
#define false 0        // 定义false为0
typedef int ElemType;  // 定义链表数据类型为int

// ============================单链表节点结构定义============================
typedef struct LNode {
    ElemType data;      // 数据
    struct LNode *next; // 指向下一个节点
} LNode, *LinkList;     // LNode为节点类型，LinkList为节点指针类型
```

**解释**：

- C语言本身没有`bool` 类型，因此用 `typedef int bool;` 定义，同时定义`0` 表示 `false`，非零值（如 `1`）表示 `true`，以此模拟布尔类型。
- `ElemType` 用于指定链表的数据类型，默认为 `int`，可以根据需要修改。
- `LNode` 结构体表示链表节点，包含数据域 `data` 和指针 `next`，用于链接下一个节点。
- `LinkList` 是指向链表头节点的指针类型，便于操作链表。

#### 2.3.3.2 初始化单链表

- 函数名称：`bool initList(LinkList *L)`

- 函数功能：初始化一个带头结点的单链表。

- 函数思路：  
  1. 在堆上分配内存生成头结点。  
  1. 判断`内存分配是否成功`，若失败则返回`false`。  
  1. 头结点的`next`指针指向`NULL`。  
  1. 初始化成功则返回`true`。


- 注意事项：  
  1. 参数L为`指向链表的指针`，其本质是一个`二级指针`，即`LNode **L`。
  2. 在堆上分配内存的操作有可能失败，所以需要`判断是否分配成功`。
  3. 头结点本身不存储数据，但遵循`定义变量即初始化`的原则，将头结点的`data域`初始化为0。
- 使用二级指针的原因
  - `L`是一个`指向指针的指针`，对`L`的操作会`改变L指向的地址的内容`。
  - `*L`是指`向链表的头指针`，即`头结点的地址`，对`*L`的操作会`改变头结点的内容`。
  - 因此，可以使用二级指针在函数内部改变`*L`的内容，从而改变`外部指针L指向的地址的内容`。
  - 如果参数是LinkList L（即LNode *L），即直接传递指针，那么只能改变`指针的内容`，无法改变`指针指向的地址的内容`。

```c
/**
 * @brief 初始化带头结点的单链表
 * @param LinkList *L 指向链表头指针的指针
 * @return bool 成功返回true，失败返回false
 */
bool initList(LinkList *L)
{
    printf("[INFO] initList()函数被调用...\n");
    *L = (LinkList)malloc(sizeof(LNode)); // 生成头结点
    if(NULL == *L)
    {
        printf("[ERROR] 初始化链表失败！ErrorText: 在堆上分配内存失败！\n");
        return false;
    }
    printf("[INFO] 初始化链表成功！\n");
    (*L)->data = 0; // 头结点不存储数据,但初始化为0
    (*L)->next = NULL;
    return true;
}
```

#### 2.3.3.3 销毁单链表

- 函数名称：`bool destroyList(LinkList *L)`
- 函数功能：销毁一个带头结点的单链表。
- 函数思路：  
  1. 判断链表指针是否`有效`（即`L和*L是否为NULL`），如果无效则`返回false`。
  2. 创建`两个临时指针p和q`，`p`指向`头结点`，`q`用于`释放结点`。
  3. `循环遍历链表`，释放每个结点的内存空间。
  4. 释放完所有结点后，将头指针`置为NULL`。
  5. 销毁成功`返回true`。
- 注意：
  1. 销毁链表时，需要`释放每个结点的内存空间`，否则会造成`内存泄漏`。
  1. 代码中释放结点内存的过程是`将首元素从链表中断开`，`原位于首元素之后的元素`成为新的首元素，然后释放`原首元素的内存`，如此循环。
  1. 销毁链表后，需要`将头结点的内存空间也释放掉`，同时`将头指针置为NULL`，否则在链表最终被销毁后，会导致`有一块分配到堆区的内存空间没有被释放`，造成`内存泄漏`。
  1. 销毁算法的时间复杂度为`O(n)`，其中n为`链表的长度`，空间复杂度为`O(1)`。
  1. 关于函数参数的说明，详见`initList()函数`的说明，简而言之，`initList()函数`和`destoryList()函数`都需要`对指向链表的指针进行操作`，所以参数必须是`指向“指向链表的指针”的指针`，而其他函数如`printList()`、`insertList()`等只需要对链表进行访问或操作，所以参数只需要是`指向链表的指针`即可。

```C
/**
 * @brief 销毁链表
 *      销毁一个带头结点的单链表
 * @param LinkList *L
 *      指向链表的指针
 * @return bool
 *      true: 销毁成功
 *      false: 销毁失败
 */
bool destroyList(LinkList *L)
{
    printf("[INFO] destroyList()函数被调用...\n");
    if(NULL == L || NULL == *L)
    {
        printf("[ERROR] 销毁链表失败！ErrorText: 链表不存在！\n");
        return false;
    }
    LinkList p = *L;    // 创建临时指针p指向头结点
    LinkList q = NULL;  // 创建临时指针q
    while(p->next != NULL) // 循环遍历链表
    {
        q = p->next;        // q指向第一个元素
        p->next = q->next;  // 断链操作，将首元素从链表中断开，头结点p指向第二个元素
        free(q);            // 释放原首元素q的内存空间
    }
    free(*L); // 释放头结点的内存空间
    *L = NULL;
    printf("[INFO] 销毁链表成功！\n");
    return true;
}
```

#### 2.3.3.4 打印链表

- 函数名称：`bool printList(const LinkList L)`

- 函数功能：本函数用于`打印一个带头结点的单链表`。
- 函数思路：
  1. 判断链表是否`有效`，即`L是否为NULL`，如果无效则`返回false`。
  2. 创建`临时指针p`指向`链表中的第一个元素`。
  3. `循环遍历链表`，打印每个元素的值。
  4. 打印成功`返回true`。
- 注意：
  1. 打印链表前，需要判断`链表是否存在`，否则有可能会导致`空指针异常`。
  2. 打印链表的时间复杂度为`O(n)`，其中n为`链表的长度`，空间复杂度为`O(1)`。
  3. 函数参数`const LinkList L`表示传递的是一个`常量指针`，使用`LinkList`而不是`LNode *L`是为了`增加代码的可读性`，且传递指针可`节省内存空间`，而用`const`修饰表示`不允许修改指针指向的内容`，这样可以`避免误操作`。

```c
/**
 * @brief 打印链表
 *      打印一个带头结点的单链表
 * @param const LinkList L
 *      链表
 * @return bool
 *      true: 打印成功
 *      false: 打印失败
 */
bool printList(const LinkList L)
{
    printf("[INFO] printList()函数被调用...\n");
    if(NULL == L)
    {
        printf("[ERROR] 打印链表失败！ErrorText: 链表不存在！\n");
        return false;
    }
    LinkList p = L->next; // 创建临时指针p指向链表中的第一个元素
    printf("[INFO] 链表元素：[HNode]-->"); // 打印头结点
    while(p != NULL)
    {
        printf("[%d]-->", p->data);
        p = p->next;
    }
    printf("[NULL]\n");
    return true;
}
```



### 2.3.4 不带头结点的单链表的实现（以C++语言为例）

### 2.3.5 双链表的相关概念

#### 2.3.5.1 双链表的基本概念

**单链表的局限**：

单链表只能从头节点到尾节点进行`单向遍历`，`不能反向遍历`。这导致在某些需要频繁访问前驱节点的操作中效率较低。此外，在单链表中插入或删除一个节点时，若需要访问前驱节点，也较为不便。

**双链表的定义**：

双链表是一种链表结构，其中每个节点包含三个部分：一个`存储数据的字段`，一个`指向前驱节点的指针`，以及一个`指向后继节点的指针`。通过这两个指针，可以实现`从任一节点向前和向后的双向遍历`。

![image-20240806000438537](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%AC%AC2%E7%AB%A0_%E7%BA%BF%E6%80%A7%E8%A1%A8_2.3_%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E6%80%A7%E8%A1%A8%E7%A4%BA.assets/image-20240806000438537.png)

![image-20240806000448242](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%AC%AC2%E7%AB%A0_%E7%BA%BF%E6%80%A7%E8%A1%A8_2.3_%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E6%80%A7%E8%A1%A8%E7%A4%BA.assets/image-20240806000448242.png)

**双链表 V.S. 单链表**：

双链表与单链表的主要区别在于`双链表的节点包含两个指针`，一个`指向前一个节点`，一个指向后一个节点。这使得双链表可以进行`双向遍历`，更加灵活。在`插入`和`删除`操作中，双链表也更为方便，因为`可以直接访问前驱节点`。然而，双链表比单链表占用更多的内存，因为每个节点需要额外存储一个指针（存储密度更低）。

#### 2.3.5.1 双链表结点的代码描述（以C语言为例）

在C语言中，双链表节点的结构体定义通常如下：

```c
// 定义双链表节点的结构体
typedef struct DNode {
    ElemType data;           	// 存储数据的字段
    struct DNode* prev; 		// 指向前一个节点的指针
    struct DNode* next; 		// 指向后一个节点的指针
} DNode, *DLinkList;
```

**代码描述**：

1. **定义结构体：** 使用 `typedef struct` 关键字定义一个名为 `DNode` 的结构体。（D指Double）
2. **数据字段：** 在结构体中包含一个 `ElemType` 类型的字段 `data`，用于存储节点的数据。
3. **前驱指针：** 包含一个指向 `DNode` 结构体类型的指针 `prev`，用于指向前一个节点。
4. **后继指针：** 包含一个指向 `DNode` 结构体类型的指针 `next`，用于指向后一个节点。
5. **类型定义：** 使用 `typedef` 关键字，将 `struct DNode` 重命名为 `DNode`，并将 `struct DNode*` 重命名为 `DLinkList`，方便在代码中使用。

通过这种定义方式，可以更简洁地使用 `DNode` 和 `DLinkList` 类型，而无需每次都写出完整的 `struct` 关键字。

### 2.3.6 带头结点的双链表的实现（以C语言为例）

### 2.3.7 不带头结点的双链表的实现（以C++语言为例）

### 2.3.8 循环双链表的相关概念

# 第3章 栈、队列和数组

# 第4章 串

# 第5章 树和二叉树

# 第6章 图

# 第7章 查找

# 第8章 排序