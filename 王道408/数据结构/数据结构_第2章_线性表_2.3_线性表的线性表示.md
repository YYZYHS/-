<center style="font-family: 华文新魏"><font size="12px" color="#4870ac">王道408 数据结构</font></center>

[toc]

# 第2章 线性表

## 2.3 线性表的链式表示

### 2.3.1 单链表的基本概念

线性表的`链式存储结构`，也称为单链表，是指通过一组任意的存储单元来存储线性表中的数据元素的数据结构。为了维护数据元素之间的线性关系，每个链表结点不仅包含元素自身的信息，还包含一个指向其后继结点的指针。（即，`各结点间的先后关系通过指针来表示`）

单链表结点的结构如下图所示：

- `data（数据域）`：用于存放数据元素的值。
- `next（指针域）`：用于存放后继结点的地址。

这种结构使得单链表可以`动态地分配内存`，不需要事先确定数据元素的数量，并且在插入和删除操作时，能够灵活地调整数据元素的存储位置。

![单链表node结构](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%AC%AC2%E7%AB%A0_%E7%BA%BF%E6%80%A7%E8%A1%A8_2.3_%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%A4%BA.assets/1732cf9467852a03tplv-t2oaga2asx-jj-mark3024000q75.png)

#### 2.3.1.1 单链表的优缺点

- **优点**
  1. **动态内存分配**：单链表可以根据需要动态地分配和释放内存，无需预先分配固定大小的存储空间，从而节省内存。

  2. **插入和删除操作高效**：插入和删除操作只需修改相关结点的指针，不涉及大量数据元素的移动，因此在任意位置进行插入和删除操作的时间复杂度为 `O(1)`。

  3. **更高的灵活性**：可以方便地调整链表的大小，适应不同数量的数据元素。


- **缺点**
  1. **访问速度较慢**：由于单链表的元素不是连续存储的，访问某个特定位置的元素需要从头结点开始逐一遍历，时间复杂度为 `O(n)`，不如数组的随机访问效率高。

  2. **额外的存储空间**：每个结点除了存储数据元素外，还需要存储一个指针，这些指针域占用了额外的存储空间。

  3. **不易实现逆向遍历**：单链表只能`从前向后遍历`，逆向遍历较为困难，需要额外的数据结构（如双链表）或额外的存储来记录遍历路径。

  4. **增加编程复杂性**：与数组相比，单链表的实现和操作相对复杂，尤其是在处理指针和内存管理时，需要更加小心。


总的来说，单链表适用于需要频繁插入和删除操作的应用场景，但在需要快速随机访问元素的情况下，效率不如数组。

#### 2.3.1.2 带头结点的单链表 V.S. 不带头结点的单链表

##### 2.3.1.2.1 带头结点的单链表

###### 特点

- **头结点**：包含一个`不存储实际数据的头结点（dummy node）`，主要用于`简化链表操作`。
- **头结点作用**：即使链表为空，`头结点依然存在`，方便对链表进行操作。

###### 优点

1. **操作简化**：无需特殊处理头结点和其他结点的操作，如插入、删除第一个结点与其他结点的`操作一致`，简化了代码逻辑。

2. **统一处理**：链表为空时，依然有头结点存在，可以统一处理所有结点的操作，避免了`空指针异常`。

3. **简化边界条件**：由于有头结点，处理链表头部操作时`无需考虑特殊边界条件`，如在头部插入或删除时，代码更加简洁。

###### 缺点

1. **额外的空间开销**：多了一个头结点，占用了一些额外的存储空间。

2. **稍微复杂的初始化**：需要在创建链表时初始化头结点。

##### 2.3.1.2.2 不带头结点的单链表

###### 特点

- **无头结点**：链表的第一个结点直接存储第一个数据元素。
- **直接操作**：所有结点都直接存储数据元素，没有额外的头结点。

###### 优点

1. **节省空间**：没有头结点，节省了一个结点的存储空间。

2. **简单初始化**：初始化时无需创建头结点，初始化过程稍微简单。

###### 缺点

1. **操作复杂**：头结点和其他结点的操作需要区别对待，如插入、删除第一个结点需要单独处理，增加了代码的复杂性。

2. **边界条件处理繁琐**：链表为空时，没有头结点存在，需要特别处理空链表的情况，容易导致空指针异常。

##### 2.3.1.2.3 总结

- **带头结点的单链表**：简化了链表操作和边界条件处理，适合更复杂的操作场景，虽然多了一个头结点会占用一点额外空间，但编程更加简洁和安全。
- **不带头结点的单链表**：节省了空间，初始化更简单，但在操作和边界条件处理上较为繁琐，适合简单链表操作的场景。

#### 2.3.1.3 头结点和头指针的区分

在单链表数据结构中，头结点（head node）和头指针（head pointer）是两个容易混淆但又各自不同的重要概念。让我们详细解释它们的定义和容易混淆的点。

**头结点（Head Node）**

头结点是指`链表中的第一个结点`，通常存储链表中的第一个元素的数据。在链表结构中，头结点本身就是一个结点，包含`数据域和指向下一个结点的指针（即next指针）`。

**头指针（Head Pointer）**

头指针是一个`指针变量`，它指向链表的第一个结点（即头结点）。头指针本身不存储链表的数据，它只是一个指针，用于`存储头结点的地址，以便能够访问链表`。

总结：不管带不带头结点，头指针始终指向链表的`第一个结点`，而头结点是带头结点链表中的第一个结点，结点内通常`不存储信息`。

#### 2.3.1.4 单链表的基本操作

1. **插入操作**：
   - **在头部插入（头插法）**：将新结点插入到链表的开头。
   - **在尾部插入（尾插法）**：将新结点插入到链表的末尾。
   - **在指定位置插入（按位插入）**：将新结点插入到链表的指定位置。
2. **删除操作**：
   - **删除头结点**：移除链表的第一个结点。
   - **删除尾结点**：移除链表的最后一个结点。
   - **删除指定结点**：移除链表中指定的结点。
3. **查找操作**：
   - **按值查找**：查找包含指定值的结点。
   - **按位置查找**：查找链表中指定位置的结点。
4. **遍历操作**：
   - 从头结点开始，依次访问每个结点，直到尾结点。

### 2.3.2 单链表结点的代码描述(以C语言为例)

```c
typedef int Elemtype;
// 定义单链表结点结构体
typedef struct LNode {
    Elemtype data;         // 数据部分，可以根据实际需要定义不同类型的数据
    struct LNode *next;  // 指针部分，指向下一个结点的地址
} LNode, *LinkList;
```

在这个结构体中，`data` 是存储结点数据的变量，`next` 是一个指向 `struct LNode` 类型的指针，它指向链表中的下一个结点。通过这种方式，每个结点就能够存储自己的数据，并且通过 `next` 指针链接到下一个结点，从而形成一个链表。

#### 2.3.2.1 typedef关键字的用法

`typedef` 是C语言中的一个关键字，用于`为已有数据类型定义新的别名`。它的主要作用是增强代码的可读性和易用性，特别是在处理复杂的数据结构时，如结构体或者函数指针等。

**单链表结点定义时，为什么要使用 `typedef`？**

- 在单链表结点的定义中，使用 `typedef` 的主要原因有两点：

  - **简化类型名称**：定义单链表结点结构体时，结构体名 `struct LNode` 和指向该结构体的指针 `struct LNode *` 是比较冗长的。使用 `typedef` 可以为 `struct LNode` 定义一个更简洁的别名 `LNode`，使得代码更加清晰和简洁。

- **抽象数据类型**：通过 `typedef`，可以将数据类型的实现与其名称分离开来。这样一来，如果需要修改数据类型或者在多个文件中使用相同的数据类型时，只需修改一处 `typedef` 定义即可，提高了代码的维护性和可重用性。


**`typedef` 的语法**

- `typedef` 的语法格式如下：

  ```c
  typedef existing_type new_type_name;
  ```

  - `existing_type` 是已有的数据类型，可以是基本数据类型（如 `int`, `float` 等），也可以是自定义的结构体、枚举类型等。
  - `new_type_name` 是为 `existing_type` 定义的新的别名。

#### 2.3.2.2 `LNode` VS `LinkList`

- `LinkList`等价于`LNode *`

- 前者强调这是`链表`，后者强调这是`结点`

- 合适的地方使用合适的名字，这样`代码的可读性更高`

### 2.3.3 带头结点的单链表的实现（以C语言为例）

### 2.3.4 不带头结点的单链表的实现（以C++语言为例）

### 2.3.5 双链表的相关概念

#### 2.3.5.1 双链表的基本概念

**单链表的局限**：

单链表只能从头节点到尾节点进行`单向遍历`，`不能反向遍历`。这导致在某些需要频繁访问前驱节点的操作中效率较低。此外，在单链表中插入或删除一个节点时，若需要访问前驱节点，也较为不便。

**双链表的定义**：

双链表是一种链表结构，其中每个节点包含三个部分：一个`存储数据的字段`，一个`指向前驱节点的指针`，以及一个`指向后继节点的指针`。通过这两个指针，可以实现`从任一节点向前和向后的双向遍历`。

![image-20240806000438537](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%AC%AC2%E7%AB%A0_%E7%BA%BF%E6%80%A7%E8%A1%A8_2.3_%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%A4%BA.assets/image-20240806000438537.png)

![image-20240806000448242](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E7%AC%AC2%E7%AB%A0_%E7%BA%BF%E6%80%A7%E8%A1%A8_2.3_%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%A4%BA.assets/image-20240806000448242.png)

**双链表 V.S. 单链表**：

双链表与单链表的主要区别在于`双链表的节点包含两个指针`，一个`指向前一个节点`，一个指向后一个节点。这使得双链表可以进行`双向遍历`，更加灵活。在`插入`和`删除`操作中，双链表也更为方便，因为`可以直接访问前驱节点`。然而，双链表比单链表占用更多的内存，因为每个节点需要额外存储一个指针（存储密度更低）。

#### 2.3.5.1 双链表结点的代码描述（以C语言为例）

在C语言中，双链表节点的结构体定义通常如下：

```c
// 定义双链表节点的结构体
typedef struct DNode {
    ElemType data;           	// 存储数据的字段
    struct DNode* prev; 		// 指向前一个节点的指针
    struct DNode* next; 		// 指向后一个节点的指针
} DNode, *DLinkList;
```

**代码描述**：

1. **定义结构体：** 使用 `typedef struct` 关键字定义一个名为 `DNode` 的结构体。（D指Double）
2. **数据字段：** 在结构体中包含一个 `ElemType` 类型的字段 `data`，用于存储节点的数据。
3. **前驱指针：** 包含一个指向 `DNode` 结构体类型的指针 `prev`，用于指向前一个节点。
4. **后继指针：** 包含一个指向 `DNode` 结构体类型的指针 `next`，用于指向后一个节点。
5. **类型定义：** 使用 `typedef` 关键字，将 `struct DNode` 重命名为 `DNode`，并将 `struct DNode*` 重命名为 `DLinkList`，方便在代码中使用。

通过这种定义方式，可以更简洁地使用 `DNode` 和 `DLinkList` 类型，而无需每次都写出完整的 `struct` 关键字。

### 2.3.6 带头结点的双链表的实现（以C语言为例）

### 2.3.7 不带头结点的双链表的实现（以C++语言为例）

### 2.3.8 循环双链表的相关概念

# 第3章 栈、队列和数组

# 第4章 串

# 第5章 树和二叉树

# 第6章 图

# 第7章 查找

# 第8章 排序