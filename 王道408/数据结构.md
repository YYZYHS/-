<center style="font-family: 华文新魏"><font size="12px" color="#4870ac">王道408 数据结构</font></center>

[toc]

# 第1章 绪论

$$
\text{绪论}
\left\{
    \begin{array}{l}
    	\text{数据结构的基本概念}
    	\\
    	\text{什么是算法}
    	\\
    	\text{算法的效率}
    	\left\{
    		\begin{array}{l}
    		\text{算法的时间复杂度★★★}
    		\\
			\text{算法的空间复杂度★}
    		\end{array}
    	\right.
    \end{array}
\right.
$$



## 1.0 数据结构在学什么

数据结构在学什么

- 学如何用程序代码把现实世界的问题**<font size=5px>信息化</font>**
- 学如何用计算机高效地处理这些信息**从而创造价值**

## 1.1 数据结构的基本概念

### 1.1.1 数据结构的基本概念

- **数据**
  - 数据是`信息的载体`,是描述客观事物属性的数、字符及所有能输入到计算机中并被`计算机程序识别和处理`的符号的集合。
  - 数据是计算机程序加工的原料。
- **数据元素**
  - `数据元素`是数据的基本单位，通常作为一个`整体`进行考虑和处理。
- **数据项**
  - 一个数据元素可由若干`数据项`组成，数据项是构成数据元素的`不可分割的最小单位`。
- **数据对象**
  - 数据对象是具有`相同性质`的数据元素的集合，是数据的一个子集。
  - ![image-20240307213709210](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20240307213709210.png)
- **数据结构**
  - 数据结构是相互之间存在一种或多种`特定关系`的数据元素的集合。

> 数据对象VS数据结构
>
> 数据对象更强调相同性质，而数据结构更强调数据元素之间的关系。
>
> - 相同的数据对象，在不同的条件下，可以组成不同的数据结构。
>
> - 同样的数据元素，可以组成不同的数据结构。
>
> - 不同的数据元素，可以组成相同的数据结构。

数据结构这门课着重关注的是`数据元素之间的关系`，和对这些数据元素的`操作`，而不关心具体的数据项内容。

### 1.1.2 数据结构的三要素


$$
\text{数据结构的三要素★★★}\left\{
    \begin{array}{l}
        \text{逻辑结构}\left\{
            \begin{array}{l}
            \text{集合结构}
            \\
            \text{线性结构} \rightarrow\text{一对一}
            \\
            \text{树形结构} \rightarrow\text{一对多}
            \\
            \text{图状(网状)结构} \rightarrow\text{多对多}
            \\
            \end{array}
        \right.
        \\
        \text{数据的运算}  \rightarrow\text{对运算的定义}
        \\
        \text{(物理结构)存储结构}\left\{
            \begin{array}{l}
            \text{顺序存储}
            \\
            	\left.
            	\begin{array}{l}
                \text{链式存储}
                \\
                \text{索引存储}
                \\
                \text{散列存储}
                \end{array}
                \right\}非顺序存储
            \end{array}
        \right.
    \end{array}
\right.
$$

#### 1.1.2.1 逻辑结构

- **逻辑结构**
  - **集合结构**：各个元素同属一个集合，别无其他关系。
  - **线性结构**：数据元素之间是`一对一`的关系。
    - 除了第一个元素，所有元素都有`唯一前驱`；
    - 除了最后一个元素，所有元素都有`唯一后继`。
  - **树形结构**：数据元素之间是`一对多`的关系。
  - **图状(网状)结构**：数据元素之间是`多对多`的关系。
  - ![img](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pbGxpb25Tb25n,size_16,color_FFFFFF,t_70.png)

#### 1.1.2.2 数据的运算

- **数据的运算**：针对于某种逻辑结构，结合实际需求，定义`基本运算`
  - 常有的基本运算：增删改查

#### 1.1.2.3 物理结构（存储结构）

- **物理结构（存储结构）**：指数据在计算机内存中的组织形式或存储方式。它描述了数据元素之间的逻辑关系和物理存储关系。
  - **顺序存储**：把`逻辑上相邻的元素`存储在`物理位置上也相邻`的`存储单元中`，元素之间的关系由`存储单元的邻接关系`来体现。
  - **链式存储**：`逻辑上相邻的元素在物理上可以不相邻`，借助`指示元素存储地址的指针`来表示元素之间的逻辑关系。
  - **索引存储**：在存储数据元素信息的同时，还`建立附加的索引表`。
    - 索引表中的每项称为`索引项`，索引项的一般形式是`(关键字,地址)`。
  - **散列存储**：根据元素的`关键字`直接`计算出该元素的存储地址`，又称`哈希(Hash)存储`。
    - 第六章中会详细讲解散列存储。
- 链式存储、索引存储、散列存储都是`非顺序存储结构`。
- 若采用`顺序存储`，则各个数据元素在物理上`必须是连续的`；
- 若采用`非顺序存储`，则各个数据元素在物理上`可以是离散的`。
- 数据的存储结构会
  - 影响存储空间分配的方便程度
  - 影响对数据运算的速度


#### 1.1.2.4 数据类型、抽象数据类型

- **数据类型**：是一个`值的集合`和`定义在此集合上的一组操作`的总称。
  - **原子类型**：其值`不可再分`的数据类型。
  - **结构类型**：其值`可再分解为若干成分(分量)`的数据类型。
  - **抽象数据类型(Abstract Data Type，ADT)**：是`抽象数据组织`及`与之相关的操作`。
    - 抽象数据类型(ADT)是指一个`数学模型`以及`定义在该模型上的一组操作`。抽象数据类型的定义仅取决于它的一组`逻辑特性`，而与其在计算机内部如何表示和实现无关。通常用`（数据对象、数据关系、基本操作集）`这样的三元组来表示。

## 1.2 算法和算法评价

### 1.2.1 算法的基本概念

#### 1.2.1.1 什么是算法

- **程序 = 数据结构 + 算法**
  - 数据结构：`要处理的信息`
  - 算法：`处理信息的步骤`
- **算法**的定义：算法是`对特定问题求解步骤的一种描述`，它是指令的有限序列，其中的每条指令表示一个或多个操作。

#### 1.2.1.2 算法的五个特性

- **算法的特性**
  - **有穷性**：一个算法必须总是在执行有穷步之后结束，且每一步都可在有穷时间内完成。
    - `注`：算法是`有穷`的，而程序可以是`无穷`的。
  - **确定性**：算法中每条指令必须`有确切的含义`，对于`相同的输入`只能得出`相同的输出`。
  - **可行性**：算法中描述的操作都可以通过`已经实现的基本运算执行有限次`来实现
  - **输入**：一个算法`有零个或多个输入`，这些输入`取自于某个特定的对象的集合`。
  - **输出**：一个算法`有一个或多个输出`，这些输出是`与输入有着某种特定关系的量`。

#### 1.2.1.3 “好”算法的特质

- **“好”算法的特质**
  - **正确性**：算法应能够`正确地解决求解问题`。
  - **可读性**：算法应具有`良好`的可读性，以帮助人们理解。
  - **健壮性**：输入`非法数据`时，算法能`适当地做出反应或进行处理`，而不会产生莫名其妙的输出结果。
  - **高效率与低存储量需求**:算法效率的度量是通过`时间复杂度`和`空间复杂度`来描述的；
    - 高效率：花的时间少，`时间复杂度低`。
    - 低存储量需求：不费内存，`空间复杂度低`。

### 1.2.2 算法的时间复杂度

- **算法的时间复杂度**：事前预估`算法时间开销`$T(n)$与`问题规模`$n$​​的关系。（T表示“time”）
- **语句的频度**：语句在算法中被重复执行的次数
- 算法中所有语句的`频度之和`记作$T(n)$,即：对应算法问题规模$n$的函数，时间复杂度主要是来分析$T(n)$​的数量级；
- **算法的时间复杂度不仅依赖于问题的规模n，也取决于待输入的数据的性质（例如：输入元素的初始状态）**
- **常见的时间复杂度**
  - $O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$​
  - 口诀：`常对幂指阶`
- **计算时间复杂度的技巧分析**
  - 顺序执行的代码只会影响常数项，可以忽略
  - 只需挑循环中的一个基本操作分析它的执行次数与n的关系即可
  - 如果有多层嵌套循环，只需关注最深层循环循环了几次
- **计算时间复杂度的技巧总结**
  1. 找到一个基本操作（最深层循环）
  2. 分析该基本操作的执行次数$×$与问题规模$n$的关系$x=f(n)$
  3. x的数量级$O(x)$就是算法时间复杂度$T(n)$（$T(n)=O(f(n))$）
- **时间复杂度分类**
  - 最好时间复杂度：**最好的情况下**，算法的时间复杂度
  - 最坏时间复杂度：**最坏的情况下**，算法的时间复杂度
  - 平均时间复杂度：**所有可能输入实例在同等概率出现的情况下**，算法的期望运行时间
  - 一般情况下，考虑最坏情况的时间复杂度（即：`最坏时间复杂度`），保证算法的运行时间不会更长
- O(n)的计算规则
  - 加法规则：$O(f(n))+O(g(n))=O(max(f(n),g(n)))$
    - 多项相加，只保留最高阶的项，且系数变为1
  - 乘法规则：$O(f(n)) \times O(g(n))=O(f(n) \times g(n))$​
    - 多项相乘，都保留

### 1.2.3 算法的空间复杂度

- **算法原地工作**——算法所需内存空间为`常量`

$$
计算空间复杂度
\left\{
	\begin{array}{l}
	普通程序
    \left\{
        \begin{array}{l}
        ①找到所占空间大小与问题规模相关的变量
        \\
        ②分析所占空间x与问题规模n的关系x=f(n)
        \\
        ③x的数量级O(x)就是算法空间复杂度S(n)
        \end{array}
    \right.
	\\
	递归程序
    \left\{
        \begin{array}{l}
        ①找到递归调用的深度x与问题规模n的关系x=f(n)
        \\
        ②x的数量级O(x)就是算法空间复杂度S(n)
        \\
        注：有的算法各层函数所需存储空间不同，分析方法略有区别
        \end{array}
    \right.
	\end{array}
\right.
$$





# 第2章 线性表
## 2.1 线性表的定义和基本操作

### 2.1.1 线性表的定义

- **线性表**是具有`相同数据类型`的$n(n \geq 0)$个`数据元素`的`有限序列`，其中$n$为`表长`，当n=0时线性表是一个`空表`。若用L命名线性表，则其一般表示为
  $$
  L=(a_{1},a_{2},...,a_{i},a_{i+1},...,a_{n})
  $$

  - 每个数据元素所占空间`一样大`
  - 线性表是`有限`且`有序`的

- 几个概念：

- **$a_i$​**是线性表中的“第i个”元素线性表中的`位序`

- **$a_1$** 是`表头元素`；**$a_n$**是`表尾元素`

- 除第一个元素外，每个元素有且仅有一个`直接前驱`

- 除最后一个元素外，每个元素有且仅有一个`直接后继`

- 注意： 线性表是一种`逻辑结构`，表示元素之间一对一的相邻关系。顺序表和链表是指`存储结构`。两者属于不同层面的概念，因此不要混淆。

- 线性表的特点

  - 表中元素的个数`有限`。

  - 表中元素具有`逻辑上的顺序性`。

  - 表中元素的数据类型都相同，这意味着`每个元素占有相同大小的存储空间`。


### 2.1.2 线性表的基本操作（C++写法）

| 函数                | 功能         | 具体说明                                          | 备注     |
| ------------------- | ------------ | ------------------------------------------------- | -------- |
| InitList(&L)        | 初始化表     | 构造一个空的线性表L,分配内存空间。                | 从无到有 |
| DestroyList(&L)     | 销毁操作     | 销毁线性表，并释放线性表L所占用的内存空间。       | 从有到无 |
| Listlnsert(&Li,e)   | 插入操作     | 在表L中的第i个位置上插入指定元素e。               |          |
| ListDelete(&L,i,&e) | 删除操作     | 删除表L中第i个位置的元素，并用e返回删除元素的值。 |          |
| LocateElem(L,e)     | 按值查找操作 | 在表L中查找具有给定关键字值的元素。               |          |
| GetElem(L,i)        | 按位查找操作 | 获取表L中第i个位置的元素的值                      |          |
| Length(L)           | 求表长       | 返回线性表L的长度，即L中数据元素的个数。          |          |
| PrintList(L)        | 输出操作     | 按前后顺序输出线性表L的所有元素值。               |          |
| Empty(L)            | 判空操作     | 若L为空表，则返回true,否则返回false。             |          |

- 对数据的操作（记忆思路）——创销、增删改查
- 函数名和参数的形式、命名都可改变，此处参考了严蔚敏版《数据结构》

## 2.2 线性表的顺序表示

### 2.2.1 顺序表的定义

- 顺序表：用`顺序存储`的方式实现的`线性表`

- 顺序存储：把`逻辑上相邻的元素`存储在`物理位置上也相邻`的`存储单元`中，元素之间的关系由`存储单元的邻接关系`来体现。

- 设线性表第一个元素的存放位置是$LOC(L)$（LOC是location的缩写），则第i位元素的地址为：
  $$
  LOC(i) = LOC(L) + i \times 数据元素的大小
  $$

- c语言通过`sizeof(ElemType)`函数知道一个数据元素的大小，其中，ElemType就是顺序表中存放的数据元素类型

### 2.2.2 顺序表的实现方式

$$
顺序表
\left\{
	\begin{array}{l}
	实现方式
	\left\{
        \begin{array}{l}
        静态分配 \to 使用“静态数组”实现,大小一旦确定就无法改变
        \\
        动态分配 \to 使用“动态数组”实现
        \left\{
            \begin{array}{l}
            顺序表存满时，可再用malloc函数或new关键字动态拓展顺序表的最大容量
            \\
            需要将数据元素复制到新的存储区域，并用free函数或delete关键字释放原区域
            \end{array}
        \right.
        \end{array}
	\right.
	\\
	特点
	\left\{
        \begin{array}{l}
        随机访问\to能在O(1)时间内找到第i个元素
        \\
        存储密度高
        \\
        拓展容量不方便
        \\
        插入、删除数据元素不方便
        \end{array}
	\right.
	\end{array}
\right.
$$

- 顺序表的`静态分配`和`动态分配`是两种不同的`内存管理方式`。

- **静态分配**：
  - **定义：**
    在静态分配中，数组的大小在`编译`时确定，程序在`运行前`就会为数组分配`固定大小的内存空间`。
  
  - **优点：**
    1. `速度较快`：数组的大小是`确定`的，不需要额外的`内存分配操作`，因此访问元素的速度较快。
    2. `简单`：不需要额外的内存管理操作，代码相对`简单`。
  - **缺点：**
    1. `内存浪费`：数组的大小是固定的，可能会浪费内存空间。
    2. `大小固定`：数组的大小在编译时确定，无法根据实际需要动态调整大小。
  
- **动态分配**：

  - **定义：**
    在动态分配中，数组的大小是在`运行`时`动态分配`的，程序可以根据需要`动态申请和释放内存空间`。
  
  - **优点：**
    1. `内存利用率高`：可以根据实际需要动态调整数组的大小，节省内存空间。
    2. `灵活性高`：数组大小可动态调整，适应性强。
  - **缺点：**
    1. `复杂性`：需要额外的内存管理操作，可能增加程序的复杂性。
    2. `内存碎片化`：频繁分配和释放内存可能会导致内存碎片问题。

### 2.2.3 静态顺序表的代码实现（以C语言为例）

#### 2.2.3.1 数据元素的代码描述

顺序表的特点是表中元素的`逻辑顺序`与其`物理顺序`相同，线性表中的任一数据元素都可以`随机存取`，所以线性表的顺序存储结构是一种`随机存取的存储结构`。通常用高级程序设计语言中的`数组`来描述线性表的顺序存储结构。

假定线性表的元素类型为ElemType，则线性表的顺序存储类型描述如下：

```c
// ====================数据类型别名========================
// 别名的好处是可以简化代码，提高代码的可读性
typedef int Elemtype;/// 静态顺序表的数据类型，此处为整型

// ====================全局变/常量========================
// 在静态顺序表中，其容量会在代码编译时即确定，代码运行时不可更改
#define MAX_SIZE 15	/// 静态顺序表的最大长度，用来规定顺序表的最大容量

// ====================结构体定义====================
/// 静态顺序表的结构体
typedef struct SqList
{
	Elemtype m_data[MAX_SIZE];/// 静态顺序表的数据域
	int m_length;/// 静态顺序表的长度
}SqList;/// 静态顺序表的别名
```

#### 2.2.3.2 静态顺序表的初始化

- 函数名：`bool initList(SqList* L)`

- 函数功能：
  - 本函数用于`初始化一个静态顺序表`，将其长度`置为0`。
- 函数思路：
  1. 判断参数是否合法，如果顺序表的指针`无效（即为NULL）`，则初始化失败
  2. 将静态顺序表的长度`置为0`。

- 注意：
  1. 因为要修改静态顺序表的数据，所以此处传入的是一个`指向静态顺序表的指针`，这样在函数内部修改静态顺序表的数据才会`影响到外部`。
  2. 静态顺序表的初始化操作的时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  3. 因为静态顺序表的存储空间是在`栈`上分配的，所以无需考虑`内存的释放问题`，当静态顺序表`所在的函数或者代码块`执行完毕后，静态顺序表的存储空间会`自动释放`。

```c
/**
* @brief 初始化静态顺序表
* @param L 待初始化的静态顺序表
* @return 初始化成功返回true，否则返回false
*/
bool initList(SqList* L)
{
	printf("[INFO] initList() is called!\n");
	// 判断参数是否合法
	if (NULL == L)
	{
		printf("[ERROR] initList() 参数错误,L为空，初始化失败！\n");
		return false;
	}
	// 初始化长度
	L->m_length = 0;
	printf("[INFO] 静态顺序表初始化成功！\n");
	return true;
}

```

#### 2.2.3.3 静态顺序的输出

- 函数名：`bool printList(const SqList* L)`

- 函数功能：
  - 本函数用于`输出静态顺序表的元素`。
- 函数思路：
  1. 判断`参数是否合法`，如果静态顺序表的指针`有效(即L不为NULL)`，则输出失败。
  2. 如果静态顺序表`为空`，则`无需输出`，直接`返回true`。
  3. 如果静态顺序表`不为空`，则`依次输出静态顺序表的元素`。
- 注意：
  1. 输出操作本身`不需要修改`静态顺序表的数据，所以传入的是一个`指向静态顺序表的常量指针（const SqList *）`，传入`指针`是为了`减少内存开销`，传入`常量`是为了`防止在不需要修改的情况下修改了数据`。
  2. 输出操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  3. 静态顺序表的位序是`从1开始`的，而数组的下标是`从0开始`的，不要混淆

```c
/**
* @brief 输出静态顺序表
* @param L 待输出的静态顺序表
* @return 输出成功返回true，否则返回false
*/
bool printList(const SqList* L)
{
	printf("[INFO] printList() is called!\n");
	if(NULL == L)
	{
		printf("[ERROR] printList() 参数错误,L为空，输出失败！\n");
		return false;
	}
	if(L->m_length == 0)
	{
		printf("[INFO] 静态顺序表为空，无需输出！\n");
		return true;
	}
	printf("[INFO] 静态顺序表的元素为：");
	for(int i = 0; i < L->m_length; i++)
	{
		printf("%d, ", L->m_data[i]);
	}
	printf("end\n");
	return true;
}
```

#### 2.2.3.4 静态顺序的表长

- 函数名称：`int length(const SqList* L)`
- 函数功能：
  -  本函数用于`获取静态顺序表的长度`。
-  函数思路：
  1. 判断参数是否合法，如果静态顺序表的指针`有效(即L不为NULL)`，则获取长度失败，返回`-1`。
  2. 合法性判断通过后，直接返回`静态顺序表的长度`。
- 注意：
  1. 获取长度操作本身`不需要修改`静态顺序表的数据，所以传入的是`一个指向静态顺序表的常量指针（const SqList *）`，传入指针是为了`减少内存开销`，传入常量是为了`防止在不需要修改的情况下修改了数据`。
  2. 获取长度操作的时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  3. 静态顺序表的长度是指`静态顺序表中元素的个数`，而不是静态顺序表的容量。
  4. 静态顺序表的位序是`从1开始`的，而数组的下标是`从0开始`的，不要混淆。

```c
/**
* @brief 输出静态顺序表的长度
* @param L 待输出的静态顺序表
* @return 返回静态顺序表的长度
*/
int length(const SqList* L)
{
	printf("[INFO] length() is called!\n");
	if(NULL == L)
	{
		printf("[ERROR] length() 参数错误,L为空，获取长度失败！\n");
		return -1;
	}
	return L->m_length;
}
```

#### 2.2.3.5 静态顺序表的判空

- 函数名：`bool isEmpty(const SqList *L)`
- 函数功能：
  - 本函数用于`判断静态顺序表是否为空`，如果静态顺序表为空，则返回`true`，否则返回`false`。
- 思路：
  1. 判断参数是否合法，如果静态顺序表的指针`有效(即L不为NULL)`，则`判空失败`，返回`false`。
  2. 如果静态顺序表的长度`为0`，则静态顺序表`为空`，返回`true`，否则返回`false`。
- 注意：
  1. 判空操作本身`不需要修改`静态顺序表的数据，所以传入的是一个`指向静态顺序表的常量指针（const SqList *）`，传入指针是为了`减少内存开销`，传入常量是为了`防止在不需要修改的情况下修改了数据`。
  2. 判空操作的时间复杂度为`O(1)`，空间复杂度为`O(1)`。

```c
/**
* @brief 静态顺序表判空操作
* @param L 待判断的静态顺序表
* @return 静态顺序表为空返回true，否则返回false
*/
bool isEmpty(const SqList *L)
{
	printf("[INFO] isEmpty() is called!\n");
	if(NULL == L)
	{
		printf("[ERROR] isEmpty() 参数错误,L为空，判空失败！\n");
		return false;
	}
	return L->m_length == 0;
}
```

#### 2.2.3.6 静态顺序表的按位查找算法

- 函数名：`bool getElem(const SqList* L, int i, Elemtype* e)`
- 函数功能：
  - 本函数用于`查找静态顺序表中第i个位置的元素`，并`将其存储到e中`。
- 思路：
  1. 判断参数是否合法，包括静态顺序表的指针是否`有效（即L不为NULL）`，顺序表是否`为空`，查找位置是否`合法`，只要有一个条件不满足，则`查找失败`。
  2. 查找元素，将`第i个位置`的元素（即`数组下标为i-1`的元素）存储到`e`中。
- 注意：
  - 查找操作本身`不需要修改`静态顺序表的数据，所以传入的是一个`指向静态顺序表的常量指针（const SqList *）`，传入指针是为了`减少内存开销`，传入常量是为了`防止在不需要修改的情况下修改了数据`。
  - 顺序表的查找操作的时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  - 参数i指的是`元素的位序`，`从1开始`，而数组下标是`从0开始`的，不要混淆

```c
/**
* @brief 静态顺序表的按位查找
* @param L 待查找的静态顺序表
* @param i 待查找的位置
* @param e 查找到的元素
* @return 查找成功返回true，否则返回false
*/
bool getElem(const SqList* L, int i, Elemtype* e)
{
	printf("[INFO] getElem() is called：尝试查找第%d位的元素\n", i);
	// 判断参数是否合法
	if(NULL == L)
	{
		printf("[ERROR] getElem() 参数错误,L为空，查找失败！\n");
		return false;
	}
	// 判断查找位置是否合法，该判断中已经隐含了静态顺序表是否为空的判断
	if(i < 1 || i > L->m_length)
	{
		printf("[ERROR] getElem() 参数错误,查找位置不合法，查找失败！\n");
		return false;
	}
	// 查找元素
	*e = L->m_data[i - 1];
	return true;
}
```

#### 2.2.3.7 静态顺序表的按值查找算法

- 函数名：`bool locateElem(const SqList* L, Elemtype e, int* i)`
- 函数功能：
  - 本函数用于`查找静态顺序表中元素值为e的元素`，并`将其位置存储到参数i中`。
- 思路：
  1. 判断参数是否合法，包括静态顺序表指针是否`有效（即L不为NULL）`，顺序表是否`不为空`，只要有一个合法条件不满足，则查找失败。
  2. 查找元素，从第一个元素`开始遍历`，查找`值为e的元素`，如果找到，则`将其位置存储到i中`，返回`true`，否则返回`false`。
- 注意：
  1. 查找操作本身`不需要修改`静态顺序表的数据，所以传入的是一个`指向静态顺序表的常量指针（const SqList *）`，传入指针是为了`减少内存开销`，传入常量是为了`防止在不需要修改的情况下修改了数据`。
  2. 最基础的按值查找有其`局限性`，即`只能找到第一个符合条件的元素`，如果有多个符合条件的元素，只会返回第一个符合的元素的位序。
  3. 查找操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  4. 顺序表的位序是`从1开始`的，而数组的下标是`从0开始`的，不要混淆

```c
/**
* @brief 静态顺序表的按值查找
* @param L 待查找的静态顺序表
* @param e 待查找的元素
* @param i 查找到的位置
* @return 查找成功返回true，否则返回false
*/
bool locateElem(const SqList* L, Elemtype e, int* i)
{
	printf("[INFO] locateElem() is called：尝试查找元素值为%d的元素\n", e);
	// 判断参数是否合法
	if(NULL == L)
	{
		printf("[ERROR] locateElem() 参数错误,L为空，查找失败！\n");
		return false;
	}
	// 查找元素，for循环中已经隐含了静态顺序表是否为空的判断，即L->m_length == 0时，不会进入for循环
	for(*i = 0; *i < L->m_length; (*i)++)
	{
		if(L->m_data[*i] == e)
		{
			(*i)++; // 位序从1开始
			return true;
		}
	}
	printf("[ERROR] 未找到值为%d的元素！\n", e);
	return false;
}
```

#### 2.2.3.8 静态顺序表的按位插入算法

- 函数名：`bool insertList(SqList* L, int i, Elemtype e)`
- 函数功能：
  - 本函数用于`在静态顺序表的第i个位置插入元素e`，如果`插入位置不合法`或者`静态顺序表已满`，则插入失败。
- 思路：
  1. 判断参数是否合法，包括静态顺序表是否`有效（即L不为NULL）`，插入位置是否`合法`，静态顺序表是否`未满`，只要有一个条件不满足，则插入失败。
  2. `将第i个元素及之后的元素依次后移`，为新元素腾出位置。
  3. 将新元素`插入到第i个位置`。
  4. 静态顺序表的`长度加1`。
- 注意：
  1. 在顺序表中，位序i`从1开始`，而数组下标`从0开始`，不要混淆。
  2. 因为需要修改静态顺序表的数据，所以此处顺序表传入的是`指针`，这样在函数内部修改静态顺序表的数据会影响到外部。
  3.  插入操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  4. 在移动元素的for循环中，j的本质是`数组下标`，当需要用j表示元素位序时，应该`+1`，所以根据“将第i个元素及之后的元素后移”这句话，位序j+1的范围为`[i,m_length]`，所以数组下标j的范围为`[i-1,m_length-1]`。

```c
/**
* @brief 静态顺序表的按位插入
* @param L 待插入的静态顺序表
* @param i 待插入的位置
* @param e 待插入的元素
* @return 插入成功返回true，否则返回false		   
*/
bool insertList(SqList* L, int i, Elemtype e)
{
	printf("[INFO] insertList() is called：尝试在第%d位插入新元素%d\n", i, e);
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表是否为空
	{
		printf("[ERROR] insertList() 参数错误,L为空，插入失败！\n");
		return false;
	}
	if (i < 0 || i > L->m_length + 1) // 判断插入位置是否合法
	{
		printf("[ERROR] insertList() 参数错误,插入位置不合法，插入失败！\n");
		return false;
	}
	if (L->m_length >= MAX_SIZE) // 判断静态顺序表是否已满
	{
		printf("[ERROR] insertList() 参数错误,静态顺序表已满，插入失败！\n");
		return false;
	}
	// 插入元素
	for(int j = L->m_length-1; j > i; j--) // 将第i个元素及之后的元素后移
	{
		L->m_data[j+1] = L->m_data[j];
	}
	L->m_data[i-1] = e; // 插入新元素
	L->m_length++;	// 表长加一
	printf("[INFO] 静态顺序表插入元素成功！\n");
	return true;
}
```

#### 2.2.3.9 静态顺序表的按位删除算法

- 函数名：`bool deleteList(SqList* L, int i, Elemtype* e)`
- 函数功能：
  - 本函数用于`删除静态顺序表中第i个位置的元素`，并`将被删除元素存储到e中`。
- 思路：
  1. 判断参数是否合法，包括静态顺序表是否`有效（即L不为NULL）`，静态顺序表是否`为空`，删除位置是否`合法`，只要有一个条件不满足，则删除失败。
  2. 若通过合法性检查，则`将待删除元素存储到e中`。
  3. 将第`i`个元素之后的元素`依次前移一位`。
  4. 静态顺序表的`表长减一`。
- 注意：
  1. 在顺序表中，位序i`从1开始`，而数组下标`从0开始`，不要混淆。
  2. 因为需要修改静态顺序表的数据，所以此处顺序表传入的是`指针`，这样在函数内部修改静态顺序表的数据会`影响到外部`。
  3. 在for循环中，j的本质是`数组下标`，当用j来表示元素位序时，应该`+1`，所以根据“将第i个元素之后的元素依次前移一位”这句话，位序j+1的范围为`[i+1,m_length]`,因此，数组下标j的范围为`[i,m_length-1]`。
  4. 删除操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。

```c
/**
 * @brief 静态顺序表的删除操作
 * @param L 待删除的静态顺序表
 * @param i 待删除的位置
 * @param e 删除的元素
 * @return 删除成功返回true，否则返回false
 */
bool deleteList(SqList* L, int i, Elemtype* e)
{
	printf("[INFO] deleteList() is called：尝试删除第%d位的元素\n", i);
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表是否为空
	{
		printf("[ERROR] deleteList() 参数错误,L为空，删除失败！\n");
		return false;
	}
	if (i < 1 || i > L->m_length) // 判断删除位置是否合法
	{
		printf("[ERROR] deleteList() 参数错误,删除位置不合法，删除失败！\n");
		return false;
	}
	// 删除元素
	*e = L->m_data[i - 1]; // 保存删除的元素
	for(int j = i; j <= L->m_length - 1; j++) // 将第i个元素之后的元素前移
	{
		L->m_data[j - 1] = L->m_data[j];
	}

	L->m_length--; // 表长减一
	printf("[INFO] 静态顺序表删除元素成功！\n");
	return true;
}
```

#### 2.2.3.10 静态顺序表的销毁算法

- 函数名：`bool destoryList(SqList *L)`
- 函数功能：
  - 本函数用于`销毁一个静态顺序表`，因为静态顺序表的特殊性，此函数和`清空顺序表`的功能相同。
- 思路：
  1. 判断参数是否合法，如果静态顺序表的指针`无效（即为NULL）`，则销毁失败。
  2. 因为静态顺序表的存储空间是`在栈上分配`的，所以`不需要手动释放内存`，只需要将静态顺序表的`长度置为0`，以此表示静态顺序中已经没有元素即可。
- 注意：
  1. 因为要修改静态顺序表的数据，所以此处传入的是一个指向静态顺序表的`指针`，这样在函数内部修改静态顺序表的数据会`影响到外部`。

```c
/**
 * @brief 销毁静态顺序表
 * @param L 待销毁的静态顺序表
 * @return 销毁成功返回true，否则返回false
 */
bool destoryList(SqList *L)
{
	printf("[INFO] destoryList() is called!\n");
	// 判断参数是否合法
	if (NULL == L)
	{
		printf("[ERROR] destoryList() 参数错误,L为空，销毁失败！\n");
		return false;
	}
	// 销毁静态顺序表
	L->m_length = 0;
	printf("[INFO] 静态顺序表销毁成功！\n");
	return true;
}
```

#### 2.2.3.11 扩展1：静态顺序表的头插法

- 函数名：`bool push_front(SqList* L, Elemtype e)`
- 函数功能：
  - 本函数用于`在静态顺序表的表头插入元素e`，如果静态顺序表`已满`，则插入失败。
- 思路：
  1. 判断顺序表的指针是否`有效（即L不为NULL）`，如果无效，则插入失败。
  2. 判断静态顺序表是否`已满`，如果已满，则插入失败。
  3. 如果通过了安全性检查，将静态顺序表中的元素`依次后移`，为新元素腾出位置。
  4. 将新元素插入到`第1个位置`。
  5.  静态顺序表的长度`加1`。
- 注意：
  1. 头插操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  2. 头插操作是在静态顺序表的`表头`插入元素，所以插入后，原来的第1个元素变成了第2个元素，原来的第2个元素变成了第3个元素，以此类推。
  3. 静态顺序表的位序是`从1开始`的，而数组的下标是`从0开始`的，不要混淆。
  4. 因为需要修改静态顺序表的数据，所以此处传入的是一个指向静态顺序表的`指针`，这样在`函数内部`修改静态顺序表的数据会`影响到函数外部`。
  5. 在for循环中，j的本质是`数组下标`，当需要用j表示元素位序时，应该`+1`，所以根据“将第i个元素及之后的元素后移”这句话，位序j+1的范围为`[i,m_length]`,所以数组下标j的范围为`[i-1,m_length-1]`，这里i=1，所以数组下标j的范围为`[0,m_length-1`]。
  6. 在实际的开发中，头插法其实可以直接`调用insertList()函数`，将i设置为`1`即可，这里只是为了演示头插法的实现而特意写出算法的实现过程。

```c
/**
* @brief 静态顺序表的头插
* @param L 待插入的静态顺序表
* @param e 待插入的元素
* @return 插入成功返回true，否则返回false
*/
bool push_front(SqList* L, Elemtype e)
{
	printf("[INFO] push_back() is called：尝试在表头插入新元素%d\n", e);
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表指针是否有效
	{
		printf("[ERROR] push_back() 参数错误,L为空，插入失败！\n");
		return false;
	}
	if (L->m_length >= MAX_SIZE) // 判断静态顺序表是否已满
	{
		printf("[ERROR] push_back() 参数错误,静态顺序表已满，插入失败！\n");
		return false;
	}
	// 插入元素
	for(int j = L->m_length-1; j >= 0; j--) // 将第i个元素及之后的元素后移
	{
		L->m_data[j+1] = L->m_data[j];
	}
	L->m_data[0] = e; // 插入新元素
	L->m_length++;	// 表长加一
	printf("[INFO] 静态顺序表表头插入元素成功！\n");
	return true;
}
```

#### 2.2.3.12 扩展2：静态顺序表的尾插法

- 函数名：`bool push_back(SqList* L, Elemtype e)`
- 函数功能：
  - 本函数用于`在静态顺序表的表尾插入元素e`，如果静态顺序表`已满`，则插入失败。
- 思路：
  1. 判断顺序表的指针是否有效，如果`无效（即L为NULL）`，则插入失败。
  2. 判断静态顺序表是否已满，如果`已满`，则插入失败。
  3. 将新元素插入到第`m_length+1`个位置（即数组的第`m_length`个位置）。
  4. 静态顺序表的长度`加1`。
- 注意：
  1. 尾插操作的时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  2. 尾插操作是在静态顺序表的表尾插入元素，因为顺序表支持`随机访问`，所以`直接在表尾插入元素即可`。
  3. 静态顺序表的位序是`从1开始`的，而数组的下标是`从0开始`的，不要混淆。
  4. 因为需要修改静态顺序表的数据，所以此处传入的是一个指向静态顺序表的`指针`，这样在`函数内部`修改静态顺序表的数据会`影响到外部`。
  5. 在实际的开发中，尾插法其实可以直接调用`insertList()`函数，将i设置为`m_length+1`即可，这里只是为了演示尾插法的实现而特意写出算法的实现过程。

```c
/**
* @brief 静态顺序表的尾插
* @param L 待插入的静态顺序表
* @param e 待插入的元素
* @return 插入成功返回true，否则返回false
*/

bool push_back(SqList* L, Elemtype e)
{
	printf("[INFO] push_back() is called：尝试在表尾插入新元素%d\n", e);
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表指针是否有效
	{
		printf("[ERROR] push_back() 参数错误,L为空，插入失败！\n");
		return false;
	}
	if (L->m_length >= MAX_SIZE) // 判断静态顺序表是否已满
	{
		printf("[ERROR] push_back() 参数错误,静态顺序表已满，插入失败！\n");
		return false;
	}
	// 插入元素
	L->m_data[L->m_length] = e; // 插入新元素
	L->m_length++;	// 表长加一
	printf("[INFO] 静态顺序表表尾插入元素成功！\n");
	return true;
}
```

#### 2.2.3.13 扩展3：静态顺序表的头删法

- 函数名：`bool pop_front(SqList* L, Elemtype* e)`
- 函数功能：
  - 本函数用于`删除静态顺序表的表头元素`。
- 函数思路：
  1. 判断参数是否合法，如果静态顺序表的指针`无效（即L为NULL）`，则删除失败。
  2.  判断静态顺序表是否为空，如果`为空`，则删除失败。
  3. 通过合法性测试后，`将静态顺序表中的元素依次前移`，覆盖掉第1个元素。
  4.  静态顺序表的`长度减1`。
- 注意：
  1. 头删操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  2. 头删操作是删除静态顺序表的`表头元素`，删除后，原来的第2个元素变成了第1个元素，原来的第3个元素变成了第2个元素，以此类推。
  3. 静态顺序表的位序是`从1开始`的，而数组的下标是`从0开始`的，不要混淆。
  4. 因为需要修改静态顺序表的数据，所以此处传入的是一个指向静态顺序表的`指针`，这样在`函数内部`修改静态顺序表的数据会`影响到外部`。
  5. 在for循环中，j的本质是`数组下标`，当需要用j表示元素位序时，应该`+1`，所以根据“将第i个元素之后的元素前移”这句话，位序j+1的范围为`[i+1,m_length]`，所以数组下标j的范围为`[i,m_length-1]`，这里i=1，所以数组下标j的范围为`[1,m_length-1]`。

```c
/**
* @brief 静态顺序表的头删操作
* @param L 待删除的静态顺序表
* @param e 被删除的元素
* @return 删除成功返回true，否则返回false 			   
*/
bool pop_front(SqList* L, Elemtype* e)
{
	printf("[INFO] pop_front() is called：尝试删除表头元素\n");
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表是否为空
	{
		printf("[ERROR] pop_front() 参数错误,L为空，删除失败！\n");
		return false;
	}
	if (L->m_length == 0) // 判断静态顺序表是否为空
	{
		printf("[ERROR] pop_front() 参数错误,静态顺序表为空，删除失败！\n");
		return false;
	}
	// 删除元素
	*e = L->m_data[0]; // 保存被删除的元素
	for(int j = 1; j <= L->m_length-1; j++) // 将第i个元素之后的元素前移
	{
		L->m_data[j-1] = L->m_data[j];
	}
	L->m_length--;	// 表长减一
	printf("[INFO] 静态顺序表表头删除元素成功！\n");
	return true;
}
```

#### 2.2.3.14 扩展4：静态顺序表的尾删法

- 函数名：`bool pop_back(SqList* L, Elemtype* e)`
- 函数功能：
  - 本函数用于`删除静态顺序表的表尾元素`。

- 思路：
  1. 判断参数是否合法，如果静态顺序表的指针`无效（即L为NULL）`，则删除失败。
  2. 判断静态顺序表是否为空，如果`为空`，则删除失败。
  3. 通过合法性测试后，直接`返回静态顺序表的最后一个元素`，`静态顺序表的长度减1`即可。
- 注意：
  1. 尾删操作的时间复杂度为`O(1)`，空间复杂度为`O(1)`。
  2. 尾删操作是删除静态顺序表的`表尾元素`，因为顺序表支持`随机访问`，所以直接删除表尾元素即可。
  3. 静态顺序表的位序是`从1开始`的，而数组的下标是`从0开始`的，不要混淆。
  4. 因为需要修改静态顺序表的数据，所以此处传入的是`一个指向静态顺序表的指针`，这样在`函数内部`修改静态顺序表的数据会`影响到外部`。

```c
/**
* @brief 静态顺序表的尾删操作
* @param L 待删除的静态顺序表
* @param e 被删除的元素
* @return 删除成功返回true，否则返回false
*/
bool pop_back(SqList* L, Elemtype* e)
{
	printf("[INFO] pop_back() is called：尝试删除表尾元素\n");
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表是否为空
	{
		printf("[ERROR] pop_back() 参数错误,L为空，删除失败！\n");
		return false;
	}
	if (L->m_length == 0) // 判断静态顺序表是否为空
	{
		printf("[ERROR] pop_back() 参数错误,静态顺序表为空，删除失败！\n");
		return false;
	}
	// 删除元素
	*e = L->m_data[L->m_length-1]; // 保存被删除的元素
	L->m_length--;	// 表长减一
	printf("[INFO] 静态顺序表表尾删除元素成功！\n");
	return true;
}

```

#### 2.2.3.15 扩展5：静态顺序表的冒泡排序算法

- 函数名：`bool sortListByBubble(SqList* L)`
- 函数功能：
  - 本函数用于对静态顺序表进行`冒泡排序`
- 函数思路：
  1. 判断参数是否合法，如果静态顺序表的指针`无效（即L为NULL）`，则排序失败。
  2. 通过合法性测试后，如果静态顺序表`为空`，则`无需排序`，直接`返回true`。
  3. 如果静态顺序表不为空，则`依次比较相邻的两个元素`，如果前一个元素`大于（或小于）`后一个元素，则`交换两个元素的位置`。
  4. 一轮比较下来，最大（或小于）的元素被交换到了`最后的位置`。
  5. 重复上述步骤，直到`所有元素都有序`。
- 注意：
  1. 冒泡排序的时间复杂度为`O(n^2)`，空间复杂度为`O(1)`。
  2. 冒泡排序是一种`稳定`的排序算法，即`相同元素的相对位置在排序前后不会发生变化`。
  3. 冒泡排序是一种`原地`排序算法，即`不需要额外的辅助空间`。
  4. 冒泡排序是一种`交换`排序算法，即通过不断的`交换相邻的元素`，将最大（或最小）的元素交换到`最后的位置`。
  5. 冒泡排序是一种简单的排序算法，适用于元素个数较少的情况。
  6. 冒泡排序的第一层循环控制`比较的轮数`，即需要比较`n-1`轮，因为最后一轮只剩下一个元素，不需要比较，因此其循环不变量i的范围为`[0,m_length-2]`。
  7. 冒泡排序的第二层循环控制`每轮比较的次数`，即每轮比较`n-1-i`次，因为每轮比较后，最大（或最小）的元素已经被交换到了最后的位置，不需要再比较， 因此其循环不变量j的范围为`[0,m_length-2-i]`。
  8. 注意，6和7中的i，j都是用来表示`数组下标`的，如果需要用来表示元素位序，应该`+1`。
  9. 此处的冒泡排序是`升序`排序，如果需要降序排序，只需要将if语句中的比较符号由`>`改为`<`即可。

```c
/**
* @brief 静态顺序表的冒泡排序操作
* @param L 待排序的静态顺序表
* @return 排序成功返回true，否则返回false
*/
bool sortListByBubble(SqList* L)
{
	printf("[INFO] sortListByBubble() is called：尝试对静态顺序表进行冒泡排序\n");
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表是否为空
	{
		printf("[ERROR] sortListByBubble() 参数错误,L为空，排序失败！\n");
		return false;
	}
	if (L->m_length == 0) // 判断静态顺序表是否为空
	{
		printf("[INFO] sortListByBubble() 参数错误,静态顺序表为空，无需排序！\n");
		return true;
	}
	// 排序
	for(int i = 0; i < L->m_length-1; i++) // 外层循环控制比较的轮数
	{
		for(int j = 0; j < L->m_length-1-i; j++) // 内层循环控制每轮比较的次数
		{
			if(L->m_data[j] > L->m_data[j+1]) // 如果前一个元素大于后一个元素，则交换两个元素的位置
			{
				Elemtype tmp = L->m_data[j];
				L->m_data[j] = L->m_data[j+1];
				L->m_data[j+1] = tmp;
			}
		}
	}
	printf("[INFO] 静态顺序表冒泡排序成功！\n");
	return true;
}

```

#### 2.2.3.16 扩展6：静态顺序表的选择排序算法

- 函数名：`bool sortListBySelect(SqList* L)`
- 函数功能：
  - 本函数用于对静态顺序表进行`选择排序`。
- 函数思路：
  1. 判断参数是否合法，如果静态顺序表的指针`无效（即L为NULL）`，则排序失败。
  2. 通过合法性测试后，如果静态顺序表`为空`，则`无需排序`，直接`返回true`。
  3. 如果静态顺序表`不为空`，依次找到静态顺序表中的`最小（或最大）元素`，将其与`第i个元素`交换位置。
  4. 重复上述步骤，直到所有元素都有序。
- 注意：
  1. 选择排序的时间复杂度为`O(n^2)`，空间复杂度为`O(1)`。
  2. 选择排序是一种`不稳定`的排序算法，即`相同元素的相对位置在排序前后可能发生变化`。
  3. 选择排序是一种`原地`排序算法，即`不需要额外的辅助空间`。
  4. 选择排序是一种`交换`排序算法，即通过不断的`交换元素的位置`，将最小（或最大）的元素交换到`最前面`。
  5. 选择排序是一种简单的排序算法，适用于元素个数较少的情况。
  6. 选择排序的第一层循环控制`比较的轮数`，即需要比较`n-1`轮，因为最后一轮只剩下一个元素，不需要比较，因此其循环不变量i的范围为`[0,m_length-2]`。
  7. 选择排序的第二层循环控制`每轮比较的次数`，因为每轮比较后，最小（或最大）的元素已经被交换到了`最前面`，不需要再比较，因此每轮比较的下标从`未比较过的元素`开始，即从`i+1`开始，而结束点一直为`m_length-1`，因此其循环不变量j的范围为`[i+1,m_length-1]`。
  8. 注意，6和7中的i，j都是用来表示`数组下标`的，如果需要用来表示元素位序，应该`+1`。
  9. 此处的选择排序是`升序`排序，如果需要降序排序，只需要将if语句中的比较符号由`<`改为`>`即可。

```c
/**
* @brief 静态顺序表的选择排序操作
* @param L 待排序的静态顺序表
* @return 排序成功返回true，否则返回false
*/
bool sortListBySelect(SqList* L)
{
	printf("[INFO] sortListBySelect() is called：尝试对静态顺序表进行选择排序\n");
	// 判断参数是否合法
	if (NULL == L) // 判断静态顺序表是否为空
	{
		printf("[ERROR] sortListBySelect() 参数错误,L为空，排序失败！\n");
		return false;
	}
	if (L->m_length == 0) // 判断静态顺序表是否为空
	{
		printf("[INFO] sortListBySelect() 参数错误,静态顺序表为空，无需排序！\n");
		return true;
	}
	// 排序
	for(int i = 0; i < L->m_length-1; i++) // 外层循环控制比较的轮数
	{
		int min = i; // 记录最小元素的下标
		for(int j = i+1; j < L->m_length; j++) // 内层循环控制每轮比较的次数
		{
			if(L->m_data[j] < L->m_data[min]) // 如果第j个元素小于第min个元素，则更新min的值
			{
				min = j;
			}
		}
		if(min != i) // 如果min的值发生了变化，则交换两个元素的位置
		{
			Elemtype tmp = L->m_data[i];
			L->m_data[i] = L->m_data[min];
			L->m_data[min] = tmp;
		}
	}
	printf("[INFO] 静态顺序表选择排序成功！\n");
	return true;
}
```

#### 2.2.3.17 扩展7：静态顺序表的合并

- 函数名：`bool mergeList(SqList* L1, SqList* L2, SqList* L3)`
- 函数功能：
  - 本函数用于`将两个有序静态顺序表合并成一个有序静态顺序表`。
- 函数思路：
  1. 判断参数是否合法，如果静态顺序表的指针`无效（即L为NULL）`，则合并失败。
  2. 判断两个顺序表L1、L2的`长度之和`是否`大于L3的容量`，如果大于，则合并失败。
  3. 通过合法性测试后，如果静态顺序表L1`为空，`则`直接将L2复制到L3中`，合并成功。
  4. 如果静态顺序表L2`为空`，则`直接将L1复制到L3中`，合并成功。
  5. 如果L1、L2均`不为空`，则`依次比较`L1和L2中的元素，`将较小的元素插入到L3中`。
  6. 如果L1中的元素已经全部插入到L3中，则`将L2中的剩余元素插入到L3中`。
  7.  如果L2中的元素已经全部插入到L3中，则`将L1中的剩余元素插入到L3中`。
- 注意：
  1. 合并操作的时间复杂度为`O(n)`，空间复杂度为`O(1)`。
  2. 合并操作是将两个`有序静态顺序表`合并成一个新的有序静态顺序表，所以合并后的静态顺序表也是`有序`的，且合并后的静态顺序表的长度等于两个静态顺序表的`长度之和`。
  3. 合并操作是一种简单的合并算法，适用于两个静态顺序表的元素个数较少的情况。
  4. 合并操作是一种`原地`合并算法，即`不需要额外的辅助空间`。
  5. 合并操作是一种`稳定`的合并算法，即相同元素的`相对位置`在合并前后`不会发生变化`。
  6. 合并操作是一种`插入排序`的变种，即通过不断的`比较`两个静态顺序表的元素，将较小的元素插入到新的静态顺序表中。
  7. 在合并算法中，需要维护`三个指针`，分别指向`三个静态顺序表的当前元素`，以便于比较和插入。
  8. 静态顺序表的局限性：静态顺序表的容量是`固定`的，不支持`动态扩容`，所以在合并操作中，需要保证合并后的静态顺序表的`容量足够`。

```c
/**
* @brief 两个有序静态顺序表的合并操作
* @param L1 第一个有序静态顺序表
* @param L2 第二个有序静态顺序表
* @param L3 合并后的有序静态顺序表
* @return 合并成功返回true，否则返回false
*/
bool mergeList(SqList* L1, SqList* L2, SqList* L3)
{
	printf("[INFO] mergeList() is called：尝试合并两个有序静态顺序表\n");
	// 判断参数是否合法
	if (NULL == L1 || NULL == L2 || NULL == L3) // 判断静态顺序表是否为空
	{
		printf("[ERROR] mergeList() 参数错误,L1或L2或L3为空，合并失败！\n");
		return false;
	}
	if (L1->m_length + L2->m_length > MAX_SIZE) // 判断静态顺序表的长度之和是否大于L3的容量
	{
		printf("[ERROR] mergeList() 参数错误,静态顺序表的长度之和大于L3的容量，合并失败！\n");
		return false;
	}
	// 合并
	int pos1 = 0; // 指向L1的当前元素
	int pos2 = 0; // 指向L2的当前元素
	int pos3 = 0; // 指向L3的当前元素
	while(pos1 < L1->m_length && pos2 < L2->m_length) // 比较L1和L2中的元素
	{
		if(L1->m_data[pos1] < L2->m_data[pos2]) // 如果L1中的元素小于L2中的元素，则将L1中的元素插入到L3中
		{
			L3->m_data[pos3++] = L1->m_data[pos1++];
		}
		else // 如果L1中的元素大于等于L2中的元素，则将L2中的元素插入到L3中
		{
			L3->m_data[pos3++] = L2->m_data[pos2++];
		}
	}
	while(pos1 < L1->m_length) // 如果L2中的元素已经全部插入到L3中，则将L1中的剩余元素插入到L3中
	{
		L3->m_data[pos3++] = L1->m_data[pos1++];
	}
	while(pos2 < L2->m_length) // 如果L1中的元素已经全部插入到L3中，则将L2中的剩余元素插入到L3中
	{
		L3->m_data[pos3++] = L2->m_data[pos2++];
	}
	L3->m_length = L1->m_length + L2->m_length; // 合并后的静态顺序表的长度等于两个静态顺序表的长度之和
	printf("[INFO] 静态顺序表合并成功！\n");
}
```

### 2.2.4 动态顺序表的代码实现（以C++语言为例）



## 2.3 线性表的链式表示

### 2.3.1 单链表的基本概念

线性表的`链式存储结构`，也称为单链表，是指通过一组任意的存储单元来存储线性表中的数据元素的数据结构。为了维护数据元素之间的线性关系，每个链表结点不仅包含元素自身的信息，还包含一个指向其后继结点的指针。（即，`各结点间的先后关系通过指针来表示`）

单链表结点的结构如下图所示：

- `data（数据域）`：用于存放数据元素的值。
- `next（指针域）`：用于存放后继结点的地址。

这种结构使得单链表可以`动态地分配内存`，不需要事先确定数据元素的数量，并且在插入和删除操作时，能够灵活地调整数据元素的存储位置。

![单链表node结构](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/1732cf9467852a03tplv-t2oaga2asx-jj-mark3024000q75.png)

#### 2.3.1.1 单链表的优缺点

- **优点**
  1. **动态内存分配**：单链表可以根据需要动态地分配和释放内存，无需预先分配固定大小的存储空间，从而节省内存。
     
  1. **插入和删除操作高效**：插入和删除操作只需修改相关结点的指针，不涉及大量数据元素的移动，因此在任意位置进行插入和删除操作的时间复杂度为 `O(1)`。
     
  1. **更高的灵活性**：可以方便地调整链表的大小，适应不同数量的数据元素。
     


- **缺点**
  1. **访问速度较慢**：由于单链表的元素不是连续存储的，访问某个特定位置的元素需要从头结点开始逐一遍历，时间复杂度为 `O(n)`，不如数组的随机访问效率高。
     
  1. **额外的存储空间**：每个结点除了存储数据元素外，还需要存储一个指针，这些指针域占用了额外的存储空间。
     
  1. **不易实现逆向遍历**：单链表只能`从前向后遍历`，逆向遍历较为困难，需要额外的数据结构（如双链表）或额外的存储来记录遍历路径。
     
  1. **增加编程复杂性**：与数组相比，单链表的实现和操作相对复杂，尤其是在处理指针和内存管理时，需要更加小心。
     


总的来说，单链表适用于需要频繁插入和删除操作的应用场景，但在需要快速随机访问元素的情况下，效率不如数组。

#### 2.3.1.2 带头结点的单链表 V.S. 不带头结点的单链表

##### 2.3.1.2.1 带头结点的单链表

###### 特点
- **头结点**：包含一个`不存储实际数据的头结点（dummy node）`，主要用于`简化链表操作`。
- **头结点作用**：即使链表为空，`头结点依然存在`，方便对链表进行操作。

###### 优点
1. **操作简化**：无需特殊处理头结点和其他结点的操作，如插入、删除第一个结点与其他结点的`操作一致`，简化了代码逻辑。
   
2. **统一处理**：链表为空时，依然有头结点存在，可以统一处理所有结点的操作，避免了`空指针异常`。
   
3. **简化边界条件**：由于有头结点，处理链表头部操作时`无需考虑特殊边界条件`，如在头部插入或删除时，代码更加简洁。

###### 缺点
1. **额外的空间开销**：多了一个头结点，占用了一些额外的存储空间。
   
2. **稍微复杂的初始化**：需要在创建链表时初始化头结点。

##### 2.3.1.2.2 不带头结点的单链表

###### 特点
- **无头结点**：链表的第一个结点直接存储第一个数据元素。
- **直接操作**：所有结点都直接存储数据元素，没有额外的头结点。

###### 优点
1. **节省空间**：没有头结点，节省了一个结点的存储空间。
   
2. **简单初始化**：初始化时无需创建头结点，初始化过程稍微简单。

###### 缺点
1. **操作复杂**：头结点和其他结点的操作需要区别对待，如插入、删除第一个结点需要单独处理，增加了代码的复杂性。
   
2. **边界条件处理繁琐**：链表为空时，没有头结点存在，需要特别处理空链表的情况，容易导致空指针异常。

##### 2.3.1.2.3 总结

- **带头结点的单链表**：简化了链表操作和边界条件处理，适合更复杂的操作场景，虽然多了一个头结点会占用一点额外空间，但编程更加简洁和安全。
- **不带头结点的单链表**：节省了空间，初始化更简单，但在操作和边界条件处理上较为繁琐，适合简单链表操作的场景。

#### 2.3.1.3 头结点和头指针的区分

在单链表数据结构中，头结点（head node）和头指针（head pointer）是两个容易混淆但又各自不同的重要概念。让我们详细解释它们的定义和容易混淆的点。

**头结点（Head Node）**

头结点是指`链表中的第一个结点`，通常存储链表中的第一个元素的数据。在链表结构中，头结点本身就是一个结点，包含`数据域和指向下一个结点的指针（即next指针）`。

**头指针（Head Pointer）**

头指针是一个`指针变量`，它指向链表的第一个结点（即头结点）。头指针本身不存储链表的数据，它只是一个指针，用于`存储头结点的地址，以便能够访问链表`。

总结：不管带不带头结点，头指针始终指向链表的`第一个结点`，而头结点是带头结点链表中的第一个结点，结点内通常`不存储信息`。

#### 2.3.1.4 单链表的基本操作

1. **插入操作**：
   - **在头部插入（头插法）**：将新结点插入到链表的开头。
   - **在尾部插入（尾插法）**：将新结点插入到链表的末尾。
   - **在指定位置插入（按位插入）**：将新结点插入到链表的指定位置。
2. **删除操作**：
   - **删除头结点**：移除链表的第一个结点。
   - **删除尾结点**：移除链表的最后一个结点。
   - **删除指定结点**：移除链表中指定的结点。
3. **查找操作**：
   - **按值查找**：查找包含指定值的结点。
   - **按位置查找**：查找链表中指定位置的结点。
4. **遍历操作**：
   - 从头结点开始，依次访问每个结点，直到尾结点。

### 2.3.2 单链表结点的代码描述(以C语言为例)

```c
typedef int Elemtype;
// 定义单链表结点结构体
typedef struct LNode {
    Elemtype data;         // 数据部分，可以根据实际需要定义不同类型的数据
    struct LNode *next;  // 指针部分，指向下一个结点的地址
} LNode, *LinkList;
```

在这个结构体中，`data` 是存储结点数据的变量，`next` 是一个指向 `struct LNode` 类型的指针，它指向链表中的下一个结点。通过这种方式，每个结点就能够存储自己的数据，并且通过 `next` 指针链接到下一个结点，从而形成一个链表。

#### 2.3.2.1 typedef关键字的用法

`typedef` 是C语言中的一个关键字，用于`为已有数据类型定义新的别名`。它的主要作用是增强代码的可读性和易用性，特别是在处理复杂的数据结构时，如结构体或者函数指针等。

**单链表结点定义时，为什么要使用 `typedef`？**

- 在单链表结点的定义中，使用 `typedef` 的主要原因有两点：

  - **简化类型名称**：定义单链表结点结构体时，结构体名 `struct LNode` 和指向该结构体的指针 `struct LNode *` 是比较冗长的。使用 `typedef` 可以为 `struct LNode` 定义一个更简洁的别名 `LNode`，使得代码更加清晰和简洁。
  
- **抽象数据类型**：通过 `typedef`，可以将数据类型的实现与其名称分离开来。这样一来，如果需要修改数据类型或者在多个文件中使用相同的数据类型时，只需修改一处 `typedef` 定义即可，提高了代码的维护性和可重用性。


**`typedef` 的语法**

- `typedef` 的语法格式如下：

    ```c
    typedef existing_type new_type_name;
    ```
    
    - `existing_type` 是已有的数据类型，可以是基本数据类型（如 `int`, `float` 等），也可以是自定义的结构体、枚举类型等。
    - `new_type_name` 是为 `existing_type` 定义的新的别名。
    

#### 2.3.2.2 `LNode` VS `LinkList`

- `LinkList`等价于`LNode *`

- 前者强调这是`链表`，后者强调这是`结点`

- 合适的地方使用合适的名字，这样`代码的可读性更高`

### 2.3.3 带头结点的单链表的实现（以C语言为例）

### 2.3.4 不带头结点的单链表的实现（以C++语言为例）

### 2.3.5 双链表的相关概念

#### 2.3.5.1 双链表的基本概念

**单链表的局限**：

单链表只能从头节点到尾节点进行`单向遍历`，`不能反向遍历`。这导致在某些需要频繁访问前驱节点的操作中效率较低。此外，在单链表中插入或删除一个节点时，若需要访问前驱节点，也较为不便。

**双链表的定义**：

双链表是一种链表结构，其中每个节点包含三个部分：一个`存储数据的字段`，一个`指向前驱节点的指针`，以及一个`指向后继节点的指针`。通过这两个指针，可以实现`从任一节点向前和向后的双向遍历`。

![image-20240806000438537](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20240806000438537.png)

![image-20240806000448242](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20240806000448242.png)

**双链表 V.S. 单链表**：

双链表与单链表的主要区别在于`双链表的节点包含两个指针`，一个`指向前一个节点`，一个指向后一个节点。这使得双链表可以进行`双向遍历`，更加灵活。在`插入`和`删除`操作中，双链表也更为方便，因为`可以直接访问前驱节点`。然而，双链表比单链表占用更多的内存，因为每个节点需要额外存储一个指针（存储密度更低）。

#### 2.3.5.1 双链表结点的代码描述（以C语言为例）

在C语言中，双链表节点的结构体定义通常如下：

```c
// 定义双链表节点的结构体
typedef struct DNode {
    ElemType data;           	// 存储数据的字段
    struct DNode* prev; 		// 指向前一个节点的指针
    struct DNode* next; 		// 指向后一个节点的指针
} DNode, *DLinkList;
```

**代码描述**：

1. **定义结构体：** 使用 `typedef struct` 关键字定义一个名为 `DNode` 的结构体。（D指Double）
2. **数据字段：** 在结构体中包含一个 `ElemType` 类型的字段 `data`，用于存储节点的数据。
3. **前驱指针：** 包含一个指向 `DNode` 结构体类型的指针 `prev`，用于指向前一个节点。
4. **后继指针：** 包含一个指向 `DNode` 结构体类型的指针 `next`，用于指向后一个节点。
5. **类型定义：** 使用 `typedef` 关键字，将 `struct DNode` 重命名为 `DNode`，并将 `struct DNode*` 重命名为 `DLinkList`，方便在代码中使用。

通过这种定义方式，可以更简洁地使用 `DNode` 和 `DLinkList` 类型，而无需每次都写出完整的 `struct` 关键字。

### 2.3.6 带头结点的双链表的实现（以C语言为例）

### 2.3.7 不带头结点的双链表的实现（以C++语言为例）

### 2.3.8 循环双链表的相关概念





# 第3章 栈、队列和数组
# 第4章 串
# 第5章 树和二叉树
# 第6章 图
# 第7章 查找
# 第8章 排序