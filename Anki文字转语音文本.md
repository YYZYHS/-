# C/C++编程

## C/C++编程0006 VS2022常用快捷键1

VS2022常用快捷键整理1：
一、调试运行：F5;
二、直接执行(不调试)：，啃臭，加F5;
三、停止调试：Shift，加F5;
四、单步调试：F10;
五、逐过程调试：F11;
六、调试时运行到光标处：啃臭，加F10;
七、重构 - 重命名：啃臭，加R, 啃臭，加R;
八、切换注释：啃臭，加K, 啃臭，加C;
九、取消注释：啃臭，加K, 啃臭，加U;
十、一键格式化代码：啃臭，加K, 啃臭，加F;
## C/C++编程0007 VS2022常用快捷键2

VS2022常用快捷键整理2：
一、全局搜索：啃臭,加Shift,加F；
二、查找所有引用：Shift,加F12；
三、打开代码定义：F12；
四、关闭当前文档：啃臭,加F4；
五、到光标上一个位置：啃臭,加横杠；
六、到光标下一个位置：啃臭,加Shift,加横杠；
七、切换头/源文件：啃臭,加K, 啃臭,加O；
八、速览声明/定义：啃臭,加K, 啃臭,加J；

# Git分布式版本控制工具
## Git分布式版本控制工具0002  版本控制的方式
版本控制的方式：
一、集中版本控制工具;简介：集中版本控制工具是指所有的文件版本都存储在中央服务器上，团队成员通过与中央服务器进行交互来管理文件版本。举例：SVN（Subversion）是一种流行的集中版本控制工具，它将所有的文件版本都存储在中央仓库中，并通过客户端与中央仓库进行交互。
二、分布式版本控制工具;简介：分布式版本控制工具是指每个开发者都拥有一份完整的代码仓库，并可以在本地进行版本控制操作，不需要与中央服务器直接交互。举例：Git是一种流行的分布式版本控制工具，每个开发者都可以在本地进行代码提交、分支管理等操作，然后再与其他开发者进行同步。

# Python编程基础

## Python0023 单行注释
单行注释有两种方式,一种是在代码后面加井号,另一种是单独一行写注释
## Python0022 Python中的注释

Python中的注释：
一、程序员在代码中对代码功能解释说明的标注性文字；
二、可以提高代码的可读性；
三、注释的内容将被Python解释器忽略，不被计算机执行；
四、注释分类：单行注释、多行注释和中文文档声明注释；

## Python0024 多行注释
多行注释练习：多行注释本质上是字符串,可以用三个单引号或者三个双引号包裹。

## Python0025 中文文档声明注释

中文文档声明注释练习;
中文文档声明注释是必须在文件的开头声明文件的编码格式;
举例:
横杠，星号，横杠, coding,冒号: utf-8 ,横杠，星号，横杠
## Python0026 Python中的缩进
代码缩进；是指每行语句开始前的空白区域，它用来表示Python程序间的包含和层次关系；类定义、函数定义、流程控制语句以及异常处理语句等行尾的冒号和下一行的缩进表示一个代码块的开始，而缩进结束，则表示一个代码块的结束；通常情况下采用4个空格作为一个缩进量

# 民法典

## 第一条
为了保护民事主体的合法权益，调整民事关系，维护社会和经济秩序，适应中国特色社会主义发展要求，弘扬社会主义核心价值观，根据宪法，制定本法。
## 第十九条
八周岁以上的未成年人为：限制民事行为能力人，实施民事法律行为由其法定代理人代理或者经其法定代理人同意、追认；但是，可以独立实施纯获利益的民事法律行为或者与其年龄、智力相适应的民事法律行为。

## 第二十条
不满八周岁的未成年人为：无民事行为能力人，由其法定代理人代理实施民事法律行为。
# 数据结构

## 数据结构0018 数据类型、抽象数据类型
数据类型，指的是一个值的集合以及定义在这个集合上的一组操作的总称。原子类型是指那些值不可再分的数据类型。而结构类型则是可以将其值分解为若干成分或分量的数据类型。抽象数据类型（ADT）是指一种数学模型，用来描述数据类型的抽象特性和对应的操作。
## 数据结构0042 静态分配_C语言版_静态顺序表的查找
C语言版-静态顺序表的查找:
注释：
一、Locate Element 函数用于按值查找元素 e 在顺序表 L 中的位置，返回其位序（位序从1开始）。
二、Get Element 函数用于按位查找顺序表 L 中位序为 i 的元素，返回其值。
三、若查找失败，Locate Element 返回0，Get Element 返回错误标志。

## 数据结构0045 静态分配_C++版_静态顺序表初始化和销毁
C++版-静态顺序表初始化和销毁：
注释：
一、Sequential List() 函数是默认构造函数，用于初始化顺序表，将长度初始化为0。
二、波浪号Sequential List() 函数是析构函数，用于清理顺序表的资源。由于静态顺序表的内存是在栈上分配的，因此无需手动释放内存，内存会在函数执行结束时自动释放，所以该析构函数为空函数。

## 数据结构0046 静态分配_C++版_静态顺序表插入
C++版-静态顺序表插入：
注释：
一、List Insert 函数用于在顺序表的第 i 个位置插入元素 e。
二、在插入和删除时，需要进行位置的合法性检查，包括检查插入位置是否合法，顺序表是否已满以及删除位置是否合法。
三、插入时，需要将第 i 个位置及其后的元素依次后移，并将元素 e 插入到第 i 个位置。
四、索引 i 从1开始。
五、插入和删除的时间复杂度为大O(n)。
## 数据结构0050 动态分配_C语言版_动态顺序表初始化和销毁
C语言版-动态顺序表初始化和销毁：
注释：
一、Init List() 函数用于初始化动态顺序表 L。
二、Destroy List() 函数用于销毁动态顺序表 L。
三、使用 malloc() 函数动态分配数组空间。malloc()原型 ：void *malloc(size_t size);malloc() 函数用于在堆上动态分配指定大小的内存空间，并返回一个指向该内存空间的指针。如果分配失败，则返回 NULL。
四、使用 free() 函数销毁数组空间。free()原型：void free(void *ptr);free() 函数用于释放之前使用 malloc()、calloc() 或 realloc() 分配的动态内存空间。被释放的内存空间会被归还给系统，并可以被系统重新分配给其他用途。
五、将顺序表的指针 data 置为 NULL。在释放动态分配的内存空间后，将指向该内存空间的指针设置为 NULL，可以防止程序继续引用已经释放的内存，避免产生野指针。
六、如果内存分配失败，需要进行相应的错误处理。
七、将顺序表的长度初始化为0，最大容量初始化为 MaxSize。

## 数据结构0051 动态分配_C语言版_动态顺序表的扩容
C语言版-动态顺序表的扩容：
Increase Size（） 函数用于增加顺序表的最大长度，它的主要工作如下：
一、将表的最大长度增加为原来的两倍。
二、使用 malloc 函数重新分配内存空间，并将新空间地址赋给 L点data指针。
三、如果分配失败，则输出提示信息。

## 数据结构0052 动态分配_C语言版_动态顺序表的按位插入
C语言版-动态顺序表的按位插入：
List Insert 函数用于在顺序表 L 的第 i 个位置插入元素 e。
如果插入位置不合法，则输出提示信息并返回。
如果顺序表已满，则调用 Increase Size 函数增加表最大长度。
插入元素后，顺序表的长度增加1。

## 数据结构0053 动态分配_C语言版_动态顺序表的按位删除
C语言版-动态顺序表的按位删除：
Lis tDelete 函数用于删除顺序表 L 的第 i 个位置的元素，并将删除的元素值存放到 e 中。如果删除位置不合法，则输出提示信息并返回。删除元素后，顺序表的长度减少1。
## 数据结构0054 动态分配_C语言版_动态顺序表的查找
C语言版-动态顺序表的查找:
注释：
一、Locate Element 函数用于按值查找顺序表 L 中元素 e，返回其在顺序表中的位置。如果找到元素，则返回其在顺序表中的位置（从1开始）。如果未找到元素，则返回0。
二、Get Element 函数用于按位查找顺序表 L 中第 i 个位置的元素。如果位置不合法，则输出提示信息并返回错误值。如果位置合法，则返回第 i 个位置的元素值。索引 i 从1开始。
三、插入和删除的时间复杂度为大O(n)。

## 数据结构0057 动态分配_C++版_动态顺序表初始化和销毁
C++版-动态顺序表初始化和销毁。
注释：
一、Dynamic Sequential List() 是默认构造函数，用于初始化顺序表，将容量初始化为某个值。默认构造函数是在没有提供任何参数的情况下调用的构造函数。在该情况下，Dynamic Sequential List() 会被调用，用于创建顺序表对象并将其容量初始化为某个值。
二、使用 new 关键字动态分配数组空间。new 关键字用于在堆上动态分配内存空间。在这里，new 被用来分配一个大小为 maxSize 的数组空间，并返回指向该空间的指针。
三、使用 delete 关键字销毁动态分配的数组空间。delete 关键字用于释放之前使用 new 关键字分配的动态内存空间。在这里，delete 中括号 被用来释放动态分配的数组空间。
四、波浪号Dynamic Sequential List() 是析构函数，用于释放顺序表的内存。析构函数是在对象销毁时自动调用的函数。在这里，波浪号Dynamic Sequential List() 被用来释放顺序表对象所分配的内存空间。
# 操作系统
## 操作系统0008  并发和共享的关系

并发和共享是计算机系统中密切相关的概念。并发性指的是系统中同时存在多个运行着的程序，这些程序可以在同一时刻执行不同的任务或操作。共享性则是指系统中的资源（如内存、文件、设备等）可以被多个并发执行的进程共同使用。

这两者是互为存在条件的：如果没有并发性，即系统只能同时运行一个程序，那么共享性就失去了意义，因为资源不需要被多个进程共享。反之，如果失去了共享性，即资源不能被多个进程共同使用，系统的资源利用效率可能会降低，因为每个进程可能需要独占一份资源，导致资源浪费和性能下降。

因此，并发性和共享性相辅相成，是确保计算机系统能够高效运行的重要条件之一。

## 操作系统0026 中断机制的基本原理

不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。

## 操作系统0028 系统调用VS库函数——系统调用
系统调用VS库函数之系统调用的相关概念：

一、系统调用是操作系统提供给用户空间程序与操作系统内核间交互的接口。
二、它们通常提供了对底层硬件资源（如文件系统、网络、进程管理等）的访问。
三、系统调用由操作系统内核实现和维护，而且执行系统调用会导致用户空间程序的特权级别从用户态切换到内核态。


## 操作系统0034 系统调用的必须性：实现进程间通信

系统调用的必要性之一是实现进程间通信。在多进程或多线程的环境中，不同的进程或线程需要进行通信和协作。操作系统提供了各种机制来支持进程间通信，如管道、消息队列、共享内存等，而这些机制通常需要通过系统调用来完成。

## 操作系统0051 原语
原语是一种特殊的程序，具有原子性，即操作要么全部执行，要么都不执行，执行期间不可中断。它位于操作系统的最底层，是最接近硬件的部分。原语的特点之一是运行时间较短，并且经常被频繁调用。

## 操作系统0053 微内核VS大内核

微内核与大内核在操作系统设计中有着显著的区别。微内核将操作系统的核心功能模块化，大部分系统服务和功能实现为用户空间的进程或服务。这种架构通过微内核提供的通信机制来实现模块间的交互，因而涉及相对频繁的CPU状态切换。

相反，大内核设计则倾向于将核心功能尽可能集成在内核中，使得这些功能在内核态直接运行，从而提高系统的整体性能。由于大部分功能在内核态运行，这种设计导致相对较少的CPU状态切换。

需要注意的是，CPU状态的切换是有一定成本的，因为它需要消耗时间。频繁地进行状态切换会降低系统的性能，因此在选择操作系统设计架构时，需权衡这些因素。

## 操作系统0058 操作系统引导（开机过程）
操作系统引导过程（即，开机过程）。
一、C P U从一个特定主存地址开始，取指令，执行R O M中的引导程序(先进行硬件自检，再开机)；
二、将磁盘的第一块主引导记录读入内存，执行磁盘引导程序，扫描分区表；
三、从活动分区(又称主分区，即安装了操作系统的分区)读入分区引导记录，执行其中的程序；
四、从根目录下找到完整的操作系统初始化程序（即启动管理器）并执行，完成“开机”的一系列动作；

## 操作系统0060 虚拟机的分类

虚拟机可分为两类，第一类V M M直接运行在硬件上  ；第二类V M M运行在宿主操作系统上。

在对物理资源的控制权上，第一类虚拟机直接运行在硬件之上，能直接控制和分配物理资源；第二类虚拟机则运行在主机操作系统之上，依赖于主机操作系统为其分配物理资源。

在资源分配方式上，第一类虚拟机在安装虚拟客户操作系统时，虚拟机管理程序要在原本的硬盘上自行分配存储空间，类似于外核的分配方式，分配未经抽象的物理硬件。第二类虚拟机的虚拟客户操作系统拥有自己的虚拟磁盘，该盘实际上是主机操作系统文件系统中的一个大文件。虚拟客户操作系统分配到的内存是虚拟内存。

在性能上，第一类虚拟机的性能更好。第二类虚拟机的性能更差，因为其需要主机操作系统作为“中介”。

在可支持的虚拟机数量上，第一类虚拟机可以支持更多的虚拟机，因为不需要和主机操作系统竞争资源，相同的硬件资源可以支持更多的虚拟机。第二类虚拟机可以支持的数量较少，因为主机操作系统本身需要使用物理资源，主机操作系统上运行的其他进程也需要物理资源。

在虚拟机的可迁移性上，第一类虚拟机的可迁移性较差。第二类虚拟机的可迁移性更好，只需导出虚拟机镜像文件即可迁移到另一台主机操作系统上，因此商业化应用更广泛。

在运行模式上，第一类虚拟机管理程序运行在最高特权（Ring 0）等级下，可以执行最高特权的指令。第二类虚拟机管理程序部分运行在用户态、部分运行在内核态。虚拟客户操作系统发出的系统调用会被虚拟机管理程序截获，并转化为虚拟机管理程序对主机操作系统的系统调用。

## 操作系统0062 进程的组成

进程由几个主要组成部分构成：

首先是PCB（进程控制块），它包含着进程的描述信息、进程的控制和管理信息、资源分配清单以及处理机相关信息。

其次是程序段，包括程序的代码（指令序列），描述了进程执行的操作和指令流程。

最后是数据段，存放运行过程中产生的各种数据，例如程序中定义的变量和其他数据。

这些组成部分共同定义了一个进程的结构和运行时所需的资源。

## 操作系统0065 进程控制块PCB
进程控制块（PCB）

PCB是进程存在的唯一标志。当操作系统创建进程时，会为每个进程创建一个对应的PCB。当进程结束时，系统会回收其对应的PCB。

在进程创建时，操作系统会分配一个唯一且不重复的进程ID（PID），这可以看作是进程的“身份证号”。

PCB包含了操作系统对进程管理所需的所有信息。它记录了进程的当前状态、程序计数器、内存分配情况、调度信息、打开文件列表以及其他与进程相关的信息。操作系统通过访问和更新PCB来管理各个并发运行的进程。

## 操作系统0072 终止态
一个进程可以通过执行exit系统调用，请求操作系统终止它自己。这时候，该进程会进入“终止态”，操作系统会从CPU中移除该进程，并且回收它所占用的内存空间以及其他资源。最后，操作系统还会释放该进程的PCB（即，进程控制块），以便将其重新用于其他目的或者释放相应的系统资源。
# 计算机组成原理

## 计算机组成原理0052 8421码

当谈及8 4 2 幺码时，我们指的是一种常见的BCD编码方式，即二进制码的十进制表示。每个十进制数字用4位二进制数来表示，这些二进制位的权值分别是8、4、2和1。具体的映射关系如下：

十进制数字0对应8 4 2 幺码的0000；
十进制数字幺对应8 4 2 幺码的000幺；
十进制数字2对应8 4 2 幺码的00幺0；
十进制数字3对应8 4 2 幺码的00幺幺；
十进制数字4对应8 4 2 幺码的0幺00；
十进制数字5对应8 4 2 幺码的0幺0幺；
十进制数字6对应8 4 2 幺码的0幺幺0；
十进制数字7对应8 4 2 幺码的0幺幺幺；
十进制数字8对应8 4 2 幺码的幺000；
十进制数字9对应8 4 2 幺码的幺00幺。
在进行8 4 2 幺码的加法操作时，与十进制加法类似。如果相加的结果超过了9，需要使用+0幺幺0进行修正，这相当于强制向高位进一。总结来说，8 4 2 幺码是一种简单而有效的方式，用来将十进制数字表示为二进制，并且支持基本的加法运算。

## 计算机组成原理0054 2421码
2 4 2 幺码，又称斯蒂巴尼-格雷码，它是一种用于表示十进制数字的编码方式。每个十进制数字用四位二进制数来表示，其权值分别为2、4、2和幺。
具体的映射关系如下：
十进制数字 0 对应的2 4 2 幺码是 0000。
十进制数字 1 对应的2 4 2 幺码是 000幺。
十进制数字 2 对应的2 4 2 幺码是 00幺0。
十进制数字 3 对应的2 4 2 幺码是 00幺幺。
十进制数字 4 对应的2 4 2 幺码是 0幺00。
十进制数字 5 对应的2 4 2 幺码是 幺0幺幺。
十进制数字 6 对应的2 4 2 幺码是 幺幺00。
十进制数字 7 对应的2 4 2 幺码是 幺幺0幺。
十进制数字 8 对应的2 4 2 幺码是 幺幺幺0。
十进制数字 9 对应的2 4 2 幺码是 幺幺幺幺。
为了避免二义性，规定如下：当表示0至4时，最高位为0；当表示5至9时，最高位为1。
这样做可以确保在使用2 4 2 幺码时不会产生混淆。

## 计算机组成原理0058 原码的缺点
原码的缺点很明显：符号位不能直接参与运算，这就需要设计复杂的硬件电路来处理，增加了成本和复杂度。相比之下，补码表示真值的方式则克服了这些问题：符号位可以直接参与运算，简化了硬件电路设计，并且在计算机系统中更为普遍。然而，补码数值位不能简单地按照原来的“位权”来解读，这是需要注意的一个重要点。

## 计算机组成原理0060 原码、补码快速转换技巧（手算）
针对原码和补码的快速转换技巧（即，手算技巧），对于正数而言，原码、反码和补码是相等的。而对于负数，我们需要进行原码到补码的转换。具体步骤是从右往左找到第一个1，将这个1左边的所有“数值位”按位取反，而符号位保持不变。

## 计算机组成原理0063 原反补移码的特性对比
n+1个比特长度的真值，其特性是实际的带正负号的数值。其合法表示范围为：负的2的n+1次幂减1，到2的n+1次幂减1；其最大数的写法为：正号，n+1个1；其最小数的写法为：负号，n+1个1；其真值0的表示方法为：正负n+1个0

n+1个比特长度的带符号整数的原码，其特性是第一个比特位表示符号位，0，代表正数，1，代表负数，剩下n比特位为数值位。其合法表示范围为：负的2的n次幂减1到2的n次幂减1。其最大数的写法为：0，逗号，n个1，等于2的n次幂减1；其最小数的写法为：1，逗号，n个1，等于负的2的n次幂减1；其真值0的表示方法为：正0的原码等于，0，逗号，n个0；负0的原码等于，1，逗号，n个0；

n+1个比特长度的带符号整数的反码，其特性是正数不变，负数则在原码的基础上数值位按位取反。其第一个比特位表示符号位，0，代表正数，1，代表负数，剩下n比特位为数值位。其合法表示范围为：负的2的n次幂减1到2的n次幂减1。其最大数的写法为：0，逗号，n个1，等于2的n次幂减1；其最小数的写法为：1，逗号，n个0，等于负的2的n次幂减1；其真值0的表示方法为：正0的反码等于，0，逗号，n个0；负0的反码等于，1，逗号，n个1；

n+1个比特长度的带符号整数的补码，其特性是正数不变，负数则在反码的基础上加1。其第一个比特位表示符号位，0，代表正数，1，代表负数，剩下n比特位为数值位。其合法表示范围为：负的2的n次幂到2的n次幂减1。其最大数的写法为：0，逗号，n个1，等于2的n次幂减1；其最小数的写法为：1，逗号，n个0，等于负的2的n次幂；真值0，只有一种补码，其表示方法为：0，逗号，n个0；

n+1个比特长度的带符号整数的移码，其特性是：一个真值的移码和补码仅差一个符号位，即x补的符号位取反，即可得到x移。因此，其第一个比特位表示符号位，但，1，代表正数，0，代表负数，剩下n比特位为数值位。其合法表示范围为：负的2的n次幂到2的n次幂减1。其最大数的写法为：1，逗号，n个1，等于2的n次幂减1；其最小数的写法为：0，逗号，n个0，等于负的2的n次幂；真值0，只有一种移码，其表示方法为：1，逗号，n个0；

n+1个比特长度的无符号整数，其特性是不存在符号位；所有 比特位 均表示数值；其合法表示范围为：0，到2的n+1次幂减1。其最大数的写法为：n+1个1，等于2的n+1次幂减1；其最小数的写法为：n+1个0，等于0；真值0的表示方法为：n+1个0；

## 计算机组成原理0073 定点小数vs定点整数
n+1个比特长度的定点整数的原码，其合法表示范围为：负的2的n次幂减1到2的n次幂减1。其最大数的写法为：0，逗号，n个1，等于2的n次幂减1；其最小数的写法为：1，逗号，n个1，等于负的2的n次幂减1；其真值0的表示方法为：正0的原码等于，0，逗号，n个0；负0的原码等于，1，逗号，n个0；

n+1个比特长度的定点整数的反码。其合法表示范围为：负的2的n次幂减1到2的n次幂减1。其最大数的写法为：0，逗号，n个1，等于2的n次幂减1；其最小数的写法为：1，逗号，n个0，等于负的2的n次幂减1；其真值0的表示方法为：正0的反码等于，0，逗号，n个0；负0的反码等于，1，逗号，n个1；

n+1个比特长度的定点整数的补码。其合法表示范围为：负的2的n次幂到2的n次幂减1。其最大数的写法为：0，逗号，n个1，等于2的n次幂减1；其最小数的写法为：1，逗号，n个0，等于负的2的n次幂；真值0，只有一种补码，其表示方法为：0，逗号，n个0；

n+1个比特长度的定点小数的原码，其合法表示范围为：负的1减2的负n次幂，到1减2的负n次幂。其最大数的写法为：0，小数点，n个1，等于1减2的负n次幂；其最小数的写法为：1，小数点，n个1，等于负的1减2的负n次幂。其真值0的表示方法为：正0的原码等于，0，小数点，n个0；负0的原码等于，1，小数点，n个0；

n+1个比特长度的定点小数的反码，其合法表示范围为：负的1减2的负n次幂，到1减2的负n次幂。其最大数的写法为：0，小数点，n个1，等于1减2的负n次幂；其最小数的写法为：1，小数点，n个0，等于负的1减2的负n次幂。其真值0的表示方法为：正0的反码等于，0，小数点，n个0；负0的反码等于，1，小数点，n个1；

n+1个比特长度的定点小数的补码，其合法表示范围为：负1，到1减2的负n次幂。其最大数的写法为：0，小数点，n个1，等于1减2的负n次幂；其最小数的写法为：1，小数点，n个0，等于负1。真值0，只有一种补码，其表示方法为：0，小数点，n个0；

## 计算机组成原理0077 偶校验的硬件实现
偶校验的硬件实现：各位信息进行异或运算(即，模2加运算)，得到的结果即为偶校验位的值。
进行偶校验时，对数据的所有位进行异或操作，结果为1说明出错；
注意：奇偶校验码只能检测到单比特错误

## 计算机组成原理0081 74181 4位ALU的实际图
7 4 1 8 1，4位ALU的实际图如上所示：
右边的S3到M引脚接收来自控制单元（CU）的控制信号。M指明ALU当前的工作模式，可以是逻辑运算或算术运算，而S3到S0则指明具体要执行的运算类型。
下方的A i和B i引脚用于输入信号（即，操作数），上方的F i引脚用于输出信号（即，运算结果）。A i, B i和F i的数量与机器字长相对应。
其余的引脚设计用于与其他芯片串联，详细功能不在此深究。

## 计算机组成原理0082 逻辑运算
逻辑运算	符号	算术表达式	C++表达式	含义
逻辑运算整理：
一、逻辑运算与，符号A N D；算术表达式：Y=A点B；C++表达式：A 与 B；含义：A 和 B 同时为真时，结果为真。

二、逻辑运算或，符号O R；算术表达式：Y=A加B；C++表达式：A 或 B；含义：A 和 B 中至少一个为真时，结果为真。

三、逻辑运算非，符号N O T；算术表达式：Y = A上划线；C++表达式：非A；含义：A 为假时，结果为真，A 为真时，结果为假。

四、逻辑运算与非，符号N A N D；算术表达式：Y=A点B上划线；C++表达式：A 与 B的非，或者，A按位与B的非；含义：A 和 B 同时为真时，结果为假。

五、逻辑运算或非，符号N O R；算术表达式：Y=A加B上划线；C++表达式：A 或 B的非；含义：A 和 B 都为假时，结果为真。

六、逻辑运算亦或，符号X O R；算术表达式：Y=A异或B；C++表达式：A 异或 B；含义：A 和 B 仅一个为真时，结果为真。

七、逻辑运算同或，符号X N O R；算术表达式：Y=A异或B上划线；C++表达式：A 异或 B的非；含义：A 和 B 相同时，结果为真；A 和 B 不同时，结果为假。

## 计算机组成原理0094 一位全加器_推导过程
二进制的加法算术运算可以通过亦或逻辑运算来映射。

在这个运算中，我们有两个二进制数 A 和 B 进行相加，每个数的每一位用 A i 和 B i 表示，称为本位。

此外，还有一个来自低位的进位 C I减1，以及本位的和 Si。

本位的和 Si 可以通过以下公式得到：Si = A I ，异或 B I， 异或 C I减1。根据异或性质可知，当输入中有奇数个1时，结果为1。

本位向高位的进位 C I 可以通过以下公式计算：C I = A I & B I 的值，与 (A I 异或 B I) & C I减1的值相或。
当 C I = 1 时，表示发生了进位，这可能是由于 A I 和 B I 都为1，或者其中一个为1并且来自低位的进位 C I减1 也为1。

这些规则定义了二进制加法运算中本位和进位的生成方式，可以有效地进行二进制加法运算。

## 计算机组成原理0098 一位全加器_串行加法器解释
一位全加器之串行加法器解释：
串行加法器采用单个全加器，数据逐位依次送入进行运算。进位触发器用于存储进位信号，以便在下一次运算中使用。对于长度为n位的操作数，加法操作需要分n次进行，每次生成一位和，然后逐位串行地送回到寄存器中。

# 计算机网络

## 计算机网络0004 计算机网络的组成部分
计算机网络由硬件、软件、协议（即，一系列规则和约定的集合）组成

## 计算机网络0006 计算机网络的组成：边缘部分

计算机网络的组成之：边缘部分。
边缘部分是用户直接使用的部分。它指的是网络的边缘节点，也就是连接到网络的终端用户设备和终端服务器的部分。边缘部分包括个人计算机、智能手机、平板电脑、服务器等各种终端设备。这些设备位于网络的边缘，是网络的最终源和目的地。在边缘部分，用户可以通过终端设备访问各种网络服务，如网页浏览、电子邮件、视频流媒体、社交网络等。边缘部分的特点是连接数量庞大、地理分布广泛、服务种类繁多。
边缘部分间的通信称为端和端之间的通信，其本质则是进程间的通信，它主要有两种方式：
第一种是C/S方式（即：Client-Server）。在C/S模型中，有一个中心化的服务器负责接收和处理客户端的请求。客户端向服务器发送请求，服务器处理这些请求并返回相应的结果。这种模型常见于许多网络应用程序，如Web浏览器和Web服务器之间的通信，电子邮件客户端和电子邮件服务器之间的通信，以及许多其他类型的客户端应用程序与服务器之间的通信。
第二种是P2P方式（即：Peer-to-Peer）。在P2P模型中，所有参与者都可以充当客户端和服务器。每个节点（或对等方）可以向其他节点发送请求或提供服务。P2P网络中的节点之间直接通信，而不需要中心化的服务器来处理通信。这种模型常见于文件共享应用程序、即时通讯应用程序和视频流分享应用程序等。

## 计算机网络0007 计算机网络的组成：核心部分
计算机网络的组成之：核心部分。
核心部分为边缘部分服务，它是指网络的核心节点，也就是网络中的主干部分。核心部分包括了主干链路、路由器、交换机等设备，负责在网络中转发和路由数据流量。核心部分通常由高速、高容量的设备组成，用于处理大量数据流量，并确保数据能够有效地从源节点传输到目的节点。核心部分的特点是速度快、容量大、高度可靠。

## 计算机网络0008 计算机网络的组成：按功能组成角度

按功能组成角度来看，计算机网络由下面两部分组成：
一、通信子网：用于实现数据通信(它由各种传输介质、通信设备、相应的网络协议组成）。
二、资源子网：用于实现资源共享和数据处理(它是实现资源共享功能的设备和软件的集合）。

## 计算机网络0009 计算机网络的分类
计算机网络可以根据不同的标准进行分类。
首先，按照分布范围分为四类：广域网（W A N），它使用交换技术；城域网（M A N）；局域网（L A N），它使用广播技术；以及个人区域网（P A N）。
其次，按使用者分为专用网和公用网。
然后，按交换类型分为三类：电路交换、报文交换和分组交换。
再者，按拓扑结构分为总线型、星型、环型和网状型，其中网状型常用于广域网。
最后，按传输技术分为广播式网络和点对点网络。广播式网络共享公共通信信道，而点对点网络使用分组存储转发和路由选择机制。
## 计算机网络0011 标准的分类
标准可以分为两类：
第一类是法定标准。法定标准是由权威机构制定的正式的、合法的标准。例如，O S I。
第二类是事实标准。事实标准是指某些公司的产品在竞争过程中占据了主流，时间长了，这些产品中的协议和技术就成了标准。例如：T C P/I P。
## 计算机网络0014 速率

速率，也叫数据率或数据传输率或比特率，指的是连接在计算机网络上的主机在数字信道上传送数据位数的速率。通常用比特每秒（b p s）来表示。速率决定了数据在网络中的传输速度，可以描述为单位时间内传输的数据量。例如，一个网络连接的速率为1 兆比特每秒，意味着每秒钟可以传输1百万比特的数据。

比特是计算机和数字通信中的最小单位，通常表示为一或零。比特是计算机中的基本数据单位，可以代表数字、字符、图像、音频等各种类型的信息。比特是计算机数据处理和通信的基础，所有的数字信息都可以通过比特来表示和传输。

常用的单位有比特每秒、千比特每秒、兆比特每秒、吉比特每秒和太比特每秒。

## 计算机网络0015 速率VS存储容量
速率单位和存储容量单位的对比如下：

首先是千的单位。
在速率中，千表示为：1千比特每秒，等于10的3次方比特每秒。
在存储容量中，千表示为1K B，等于2的10次方字节，也就是1024，再乘以2的3次方比特。
需要注意的是：在速率中，千用小写k表示，而在存储容量中，千用大写K表示。

接下来是兆的单位。
在速率中，兆表示为：1兆比特每秒，等于10的6次方比特每秒。
在存储容量中，兆表示为1M B，等于2的20次方字节，也就是1024K，再乘以2的3次方比特。

然后是吉的单位。
在速率中，吉表示为：1吉比特每秒，等于10的9次方比特每秒。
在存储容量中，吉表示为1G B，等于2的30次方字节，也就是1024M，再乘以2的3次方比特。

最后是太的单位。
在速率中，太表示为：1太比特每秒，等于10的12次方比特每秒。
在存储容量中，太表示为1T B，等于2的40次方字节，也就是1024G，再乘以2的3次方比特。
需要注意的是，1字节等于8比特。

## 计算机网络0016 带宽
带宽，英文Band width。在信号处理领域，带宽指的是某个信号的频带宽度，即信号所包含的频率范围，等于信号的最高频率和最低频率之差，单位是赫兹。而在计算机网络中，带宽表示网络通信线路传送数据的能力，通常指单位时间内从网络的某一点到另一点所能通过的最高数据率。带宽的单位有比特每秒、千比特每秒）、兆比特每秒等。网络的带宽决定了数据传输的速度和吞吐量。

## 计算机网络0033 ISO/OSI参考模型解释通信过程之：**接收端**：

ISO-OSI参考模型解释通信过程之：接收端：

从下往上,ISO-OSI参考模型在接收端的通信过程如下：

一、物理层（第1层），该层负责接收电信号，并转换为数据。

二、数据链路层（第2层），该层负责从物理层接收数据，并将其转发给网络层。

三、网络层（第3层），该层负责根据目标地址将数据传输到目标主机。

四、传输层（第4层），该层负责接收数据块，并将其重组成完整的数据。

五、会话层（第5层），该层负责管理会话，确保数据的可靠传输。

六、表示层（第6层），该层负责对数据进行解密、解析等处理。

七、应用层（第7层），该层负责将数据交给应用程序进行处理。

# 高中数学

## 高中数学0004 集合的表示法

集合的表示法有：

一、自然语言法：用文字叙述的形式来描述集合。

二、列举法：把集合中的元素一一列举出来，写在大括号内表示集合。

三、描述法：其格式为：大括号，x，x具有的性质，其中， x 为集合的代表元素。

四、图示法：用数轴或韦恩图来表示集合。

## 高中数学0006 集、真子集、集合相等等相关概念
集、真子集、集合相等，等相关概念：
1、子集，记做："A ,包含于 B，或者，B ，包含 A"。其意义为：A 中的任一元素，都属于 B。其性质如下：1、A ，包含于 A；2、空集，包含于 A；3、若A， 包含于 B，且B， 包含于 C，则A ，包含于 C；4、若A ，包含于 B，且B ，包含于 A，则A，=B；
2、真子集，记做：A ，真包含于 B，或者B， 真包含 A，其意义为：A ，包含于 B，且 B 中至少有一元素不属于 A。其性质如下：1、空集，不真包含于 A；2、若A， 真包含于 B，且B，真 包含于 C，则A ，真包含于 C。
3、集合相等，记做：A等于B，其意义为：A 中的任一元素都属于 B， B 中的任一元素都属于 A；其性质如下：1、A ,包含于 B；2、B ,包含于 A

## 高中数学0008 交集、并集、补集
1、交集，记作A交B，其意义为：x，x属于A，且x属于B；其性质如下：1、A交A=A；2、A交空集=空集；3、A交B包含于A，A交B包含于B
2、并集，记作A并B，其意义为：x，x属于A，或x属于B；其性质如下：1、A并A=A；2、A并空集=A；3、A并B包含A，A并B包含B
3、补集，记作A的补，其意义为：x，x属于全集S，且x不属于A；其性质如下：1、A交A的补=全集；2、A并A的补=空集；3、A补的补=A；全集的补=空集；4、A交B的补=A补并B补；A并B的补=A补交B补

## 高中数学0010 一元二次不等式的解法

一元二次不等式的判别式是： delta 等于 b 平方减 4ac。

对于一元二次方程 a x的平方加 bx 加 c 等于零，其中 a 大于零来说，有以下情况：当 delta 大于零时，它有两个实根。这两个实根分别是 x 1，2 ，等于 2a分之负 b 加减 根号下 的 b 平方减 4ac ，其中 x1 小于 x2。当 delta 等于零时，实根 x1 等于 x2 等于 负的2a分之b。当 delta 小于零时，一元二次方程没有实根。

针对 a x 的平方加 bx 加 c 大于零，其中 a 大于零来说，情况如下：当 delta 大于零时，其解集是 x 小于 x1 或 x 大于 x2。当 delta 等于零时，其解集是 x 不等于 负的2a分之b。当 delta 小于零时，其解集是 实数集 R。

对于 a x 的平方加 bx 加 c 小于零，其中 a 大于零来说，解集如下：当 delta 大于零时，解集是 x1 小于 x 小于 x2。当 delta 等于零或小于零时，解集为空集。

## 高中数学0011 函数的概念
一、设A-B是两个非空的数集，如果按照某种对应法则f，对于集合 A 中任何一个数 ，在集合 B 中都有唯一确定的数 f(x) 和它对应， 那么这样的对应 （包括集合 A-B， 以及 A 到 B 的对应法则 f）叫做集合 A 到 B的一个函数，记作 f:A到B.
二、函数的三要素 : 定义域、值域和对应法则．
三、只有定义域相同，且对应法则也相同的两个函数才是同一函数

## 高中数学0012 区间的概念及表示法
设a、b是两个实数，且a小于b。
满足a小于等于x小于等于b的实数x的集合叫做闭区间，记作闭区间a到b。
满足a小于x小于b的实数x的集合叫做开区间，记作开区间a到b。
满足a小于等于x小于b，或a小于x小于等于b的实数x的集合叫做半开半闭区间，分别记作左闭右开a到b和左开右闭a到b。
满足x大于等于a，x大于a，x小于等于b，x小于b的实数x的集合分别记作左闭右开a到正无穷)，开区间(a到正无穷)，左开右闭(负无穷到b和开区间(负无穷到b)。
注意，对于集合{x，a小于x小于b}与开区间(a到b)，前者a可以大于或等于b，而后者必须a小于b。即前者可以不成立，为空集；而后者必须成立。

## 高中数学0017 求函数的定义域原则5
求函数的定义域原则5：y = Tangent-x中，x 不等于k派加二分之派，其中，K属于整数

## 高中数学0030 函数的单调性的定义及判定方法
关于函数的单调性及其判定方法：
函数的性质包括增函数和减函数。
增函数的定义是：如果对于定义域内某个区间上的任意两个自变量值x1和x2，当x1小于x2时，总有f(x1)小于f(x2)，那么我们就说f(x)在这个区间上是增函数。
判定增函数的方法有以下几种：
1. 利用定义；
2. 利用已知函数的单调性；
3. 利用函数图像（在某个区间上图像上升则为增）；
4. 利用复合函数。
减函数的定义是：如果对于定义域内某个区间上的任意两个自变量值x1和x2，当x1小于x2时，总有f(x1)大于f(x2)，那么我们就说f(x)在这个区间上是减函数。
判定减函数的方法包括：
1. 利用定义；
2. 利用已知函数的单调性；
3. 利用函数图像（在某个区间上图像下降则为减）；
4. 利用复合函数。

# 高质量C++/C编程指南及编码规范

## 指南及规范0013_代码行内的空格2
【规则 2-3-4】‘逗号’之后要留空格，如 Function(x, y, z)。如果‘分号’不是一行的结束符号，其后要留空格，如 for (initialization; condition; update)。

【规则 2-3-5】赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符等二元操作符的前后应当加空格。

【规则 2-3-6】一元操作符前后不加空格。

【规则 2-3-7】象取值运算符这类操作符前后不加空格。

【建议 2-3-1】对于表达式比较长的 for 语句和 if 语句，为了紧凑起见可以适当地去掉一些空格，

## 指南及规范0018_类的版式
类的版式主要有两种方式：
（1）将 private 类型的数据写在前面，而将 public 类型的函数写在后面，如示例 2-7（a）。采用这种版式的程序员主张类的设计“以数据为中心”，重点关注类的内部结构。
（2）将 public 类型的函数写在前面，而将 private 类型的数据写在后面，如示例 2-7（b）采用这种版式的程序员主张类的设计“以行为为中心”，重点关注的是类应该提供什么样的接口（或服务）。
建议读者采用“以行为为中心”的书写方式，即首先考虑类应该提供什么样的函数。


## 指南及规范0021_共性规则3

【规则 3-1-5】程序中不要出现标识符完全相同的局部变量和全局变量，尽管两者的作用域不同而不会发生语法错误，但会使人误解。  
  
【规则 3-1-6】变量的名字应当使用“名词”或者“形容词＋名词”的格式。

## 指南及规范0022_共性规则4
【规则 3-1-7】全局函数的名字应当使用“动词”或者“动词＋名词”（动宾词组）。类的成员函数应当只使用“动词”，被省略掉的名词就是对象本身。

【规则 3-1-8】用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。

## 指南及规范0025_简单的 Windows 应用程序命名规则2
简单的 Windows 应用程序命名规则2：
【规则 3-2-3】常量全用大写的字母，用下划线分割单词。
【规则 3-2-4】静态变量加前缀 s_（表示 static）。

## 指南及规范0030_复合表达式2
【规则 4-2-1】不要编写太复杂的复合表达式。
【规则 4-2-2】不要有多用途的复合表达式。
【规则 4-2-3】不要把程序中的复合表达式与“真正的数学表达式”混淆

## 指南及规范0031_if 语句_布尔变量与零值比较
【规则 4-3-1】不应直接用TRUE、FALSE或者，1、0，来比较布尔变量。
根据布尔类型的定义，零值表示“假”（记为FALSE），任何非零值表示“真”（记为TRUE）。不同编程语言中TRUE的具体取值并无统一标准，例如Visual C++中TRUE为1，而Visual Basic中TRUE为负一。
以布尔变量名为flag为例，正确的比较方式如下：
if (flag) // 表示flag为真；
if (非flag) // 表示flag为假；除此以外的比较方式都被视为不良编程风格。

## 指南及规范0032_if 语句_整型变量与零值比较

【规则 4-3-2】应当将整型变量用“等于等于”或“不等于”直接与 0 比较。

## 指南及规范0033_if 语句_浮点变量与零值比较
【规则 4-3-3】不可将浮点变量用“等于等于”，或“不等于”与任何数字比较。

千万要留意，无论是 float 还是 double 类型的变量，都有精度限制。所以一定要避免将浮点变量用“等于等于”，或“不等于”与数字比较，应该设法转化成“大于等于”或“小于等于”的 形式。

## 指南及规范0039_switch 语句
【规则 4-6-1】每个 case 语句的结尾不要忘了加 break，否则将导致多个分支重叠（除非有意使多个分支重叠）。  
  
【规则 4-6-2】不要忘记最后那个 default 分支。即使程序真的不需要 default 处理，也应该保留语句 default : break; 这样做并非多此一举，而是为了 防止别人误以为你忘了 default 处理
## 指南及规范0040_goto 语句

goto 语句至少有一处可显神通，它能从多重循环体中咻地一下子跳到外面，用不着写很多次的 break 语句;  
例如

## 指南及规范0042_const 与 \#define 的比较

C++ 语言可以用 const 来定义常量，也可以用\#define 来定义常量。但是前者比后者有更多的优点：
一、 const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换时，可能会产生意料不到的错误（边际效应）。
二、 有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。

## 指南及规范0053_返回值的规则2

【规则 6-2-3】不要将正常值和错误标志混在一起返回。正常值用输出参数获得， 而错误标志用 return 语句返回。

【建议 6-2-1】有时候函数原本不需要返回值，但为了增加灵活性如支持链式表达，可以附加返回值。
## 指南及规范0056_函数内部实现的规则2

【规则 6-3-2】在函数体的“出口处”，对 return 语句的正确性和效率进行检查。 如果函数有返回值，那么函数的“出口处”是 return 语句。不要轻视 return 语句。如果 return 语句写得不好，函数要么出错，要么效率低下。

注意事项如下：
（1）return 语句不可返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。
（2）要搞清楚返回的究竟是“值”、“指针”还是“引用”。 
（3）如果函数返回值是一个对象，要考虑 return 语句的效率。

例如:return String(s1 + s2);这是临时对象的语法，表示“创建一个临时对象并返回它”。不要以为它与“先创建一个局部对象 temp 并返回它的结果”是等价的，如 String temp(s1 + s2); return temp;
首先，temp 对象被创建，同时完成初始化； 然后拷贝构造函数把 temp 拷贝到保存返回值的外部存储单元中；最后，temp 在函数结束时被销毁（调用析构函数）。
然而“创建一个临时对象并返回它”的过程是不同的，编译器直接把临时对象创建并初始化在外部存储单元中，省去了拷贝和析构的花费，提高了效率。 

类似的，不要将 return int(x + y);写成int temp = x + y; return temp;
由于内部数据类型如 int， float， double 的变量不存在构造函数与析构函数，虽然该“临时变量的语法”不会提高多少效率，但是程序更加简洁易读。

## 指南及规范0059_其它建议3
【建议 6-4-4】不仅要检查输入参数的有效性，还要检查通过其它途径进入函数体内的变量的有效性，例如全局变量、文件句柄等。  
  
【建议 6-4-5】用于出错处理的返回值一定要清楚，让使用者不容易忽视或误解错误情况。

## 指南及规范0063_使用断言4

【规则 6-5-1】使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的。  
  
【规则 6-5-2】在函数的入口处，使用断言检查参数的有效性（合法性）。
## 指南及规范0066_引用与指针的比较2

引用的主要功能是传递函数的参数和返回值。C++语言中，函数的参数和返回值的传递方式有三种： 值传递、指针传递和引用传递。

以下是“值传递”的示例程序。由于 Func1 函数体内的 x 是外部变量 n 的一份拷贝，改变 x 的值不会影响 n, 所以 n 的值仍然是 0。

以下是“指针传递”的示例程序。由于 Func2 函数体内的 x 是指向外部变量 n的指针，改变该指针的内容将导致 n 的值改变，所以 n 的值成为 10。

以下是“引用传递”的示例程序。由于 Func3 函数体内的 x 是外部变量 n 的引用，x 和 n 是同一个东西，改变 x 等于改变 n，所以 n 的值成为 10。

## 指南及规范0065_引用与指针的比较1

以下程序中，n 是 m 的一个引用物（reference），m 是被引用物（referent）。
n 相当于 m 的别名（绰号），对 n 的任何操作就是对 m 的操作。例如有人名叫王小毛，他的绰号是“三毛”。说“三毛”怎么怎么的，其实就是对王小毛说三道四。 所以 n 既不是 m 的拷贝，也不是指向 m 的指针，其实 n 就是 m 它自己。

引用的一些规则如下：
（1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。
（2）不能有 NULL 引用，引用必须与合法的存储单元关联（指针则可以是 NULL）。
（3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。

## 指南及规范0075——下面以字符串为例比较指针与数组的特性——1.修改内容

下例中：
字符数组 a 的容量是 6 个字符，其内容为 hello\0。a 的内容可以改变，如 a[0]等于 'X'。
指针 p 指向常量字符串“world”（位于静态存储区，内容为 world\0），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句 p[0]等于 'X'有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。

## 指南及规范0092——成员函数的重载、覆盖与隐藏_重载与覆盖

成员函数被重载的特征：
（1）相同的范围（在同一个类中）。
（2）函数名字相同。
（3）参数不同。
（4）virtual 关键字可有可无。
覆盖是指派生类函数覆盖基类函数，特征是：
（1）不同的范围（分别位于派生类与基类）。
（2）函数名字相同。
（3）参数相同。
（4）基类函数必须有 virtual 关键字。
## 指南及规范0093——成员函数的重载、覆盖与隐藏_令人迷惑的隐藏规则

派生类的函数屏蔽了与其同名的基类函数，规则如下：
（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏（注意别与重载混淆）。
（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。


## 指南及规范0094——成员函数的重载、覆盖与隐藏_摆脱隐藏
如果语句一定要调用基类的函数，那么在派生类中直接以基类，双冒号，函数名的格式调用即可。

## 指南及规范0095——参数的缺省值

有一些参数的值在每次函数调用时都相同，书写这样的语句会使人厌烦。C++语言采用参数的缺省值使书写变得简洁（在编译时，缺省值由编译器自动插入）。

【规则 8-3-1】参数缺省值只能出现在函数的声明中，而不能出现在定义体中。

【规则 8-3-2】如果函数有多个参数，参数只能从后向前挨个儿缺省，否则将导致函数调用语句怪模怪样。

要注意，使用参数的缺省值并没有赋予函数新的功能，仅仅是使书写变得简洁一些。它可能会提高函数的易用性，但是也可能会降低函数的可理解性。所以只能适当地使用参数的缺省值，要防止使用不当产生负面效果。

## 指南及规范0096——运算符重载_概念
在 C++语言中，可以用关键字 operator 加上运算符来表示函数，叫做运算符重载。
运算符与普通函数在调用时的不同之处是：1、对于普通函数，参数出现在圆括号内；2、而对于运算符，参数出现在其左、右侧。
如果运算符被重载为全局函数，那么只有一个参数的运算符叫做一元运算符， 有两个参数的运算符叫做二元运算符。
如果运算符被重载为类的成员函数，那么一元运算符没有参数，二元运算符只有一个右侧参数，因为对象自己成了左侧参数。
运算符的重载规则如下：1、所有的一元运算符都建议重载为成员函数；2、等于号，小括号，中括号，箭头符号这四类，只能重载为成员函数；3、加等于，减等于，除等于，乘等于，与等于，或等于，非等于，取模等于，右移等于，左移等于这些符号，建议重载为成员函数；剩下的所有其它运算符，建议重载为全局函数。

## 指南及规范0097——运算符重载_不能被重载的运算符
在 C++运算符集合中，有一些运算符是不允许被重载的。这种限制是出于安全方面的考虑，可防止错误和混乱。
（1）不能改变 C++内部数据类型（如 int, float 等）的运算符。
（2）不能重载点运算符，因为点运算符在类中对任何成员都有意义，已经成为标准用法。
（3）不能重载目前 C++运算符集合中没有的符号，如井号，艾特符号，美元符号等。原因有两点，一是难以理解，二是难以确定优先级。
（4）对已经存在的运算符进行重载时，不能改变优先级规则，否则将引起混乱。

## 指南及规范0098——函数内联_用内联取代宏代码
C++ 语言的函数内联机制既具备宏代码的效率，又增加了安全性，而且可以自由操作类的数据成员。  
所以在 C++ 程序中，应该用内联函数取代所有宏代码，“断言 assert”是唯一的例外。